
## 在小程序探索道路上的方向调整
> 作者：YufJ

### 开始

时间回到2020年初，当时公司内部已经有了第三版hybrid方案了，简称hybrid3。采用的也是双线程方案，应用离线包拆分为JSC的逻辑层，webview的渲染层。从这个视角看架构与小程序是一样的，但是hybrid3的逻辑层其实又与小程序不太一样，逻辑层做的事情太多了。由于技术栈使用的是React所以把整个应用的执行全部放在了逻辑层，形象的比喻那就是一个webview渲染版的ReactNative。

由于公司在小程序上的开发投入都很多，业务比较依赖小程序技术，公司开始在内部IM上尝试小程序方案为后续这些业务在主板App接入做准备。既然使用小程序当然整个开发方式编码方式都是和小程序保持一致的，业务开发是也是模版、样式、逻辑、配置等等，基本确定了对外的接入方式了。 小程序的基础库能力以及编译构建能力的实现，老板当时拍板可以沿用hybrid3的方案，将小程序的DSL转换成React不就完美了嘛。至此小程序整体基调基本定了，后面可以开始着手踩其中的坑了。

上面核心功能其实就是小程序DSL转React编译和基础库。先说小程序DSL转React，由于对小程序一直保持一些关注所以第一时间想到的就是Taro，隐约记得Taro有个convert功能完全符合我们的需求将小程序转成类React。基础库实现基于已经将小程序转为React，所以逻辑层需要将每次的更新的vdom信息通知到渲染层，可以改造react-dom或者编写自定义渲染器。

### 问题

#### 静态转译不能解决的问题

转译能力完全不能hold业务方法编写小程序的各种姿势，比如template深度嵌套、template传值等等问题，没办法只能fork下来魔改了。

逻辑层代码生成依赖小程序DSL的js文件中Page、Component函数调用语法，一旦业务方的小程序使用了类似wepy这样的第三方框架，或者自己封装了Page、Component等函数调用，静态转译将一无是处。因此这一版小程序对开发者使用存在很大的限制，并不是一个标准的小程序。

#### service层过重，webview层过轻

我们将整个react应用全部放在了service线程，其中包含组件的实现，这样带来了很多问题。

我们提供的组件原本就是内置组件这些组件是可以不设置DOM、BOM的限制，但我们都统一放到了service中，自己给自己设了一道坎。为了解决组件的原生能力，service中内置组件不去实现具体的功能，只负责数据的接收传递，然后在webview层再实现一个具体功能的组件。


### 继续探索

经过上一阶段的踩坑，基于小程序DSL做静态转译这条路肯定错误的。因此想做小程序就得与业界对齐，知道业界是怎么实现的。

> 注明：以下探索均为通过正当途径获取，即通过各家的小程序IDE中内置基础库。

#### 揭秘支付宝小程序

整体架构：

webview：渲染基于React、React-DOM，内置组件也是React实现组件加部分Native组件组合。

业务方代码的模版文件与样式文件会打包到webview，例如页面A入口：

```js

Page({
  usingComponents: {
    'com-a': 'xxxx/components/a'
  },
  get render() {
    return require('xxxx/pages/a/a.axml')
  },
  get style() {
    return require('xxxx/pages/a/a.acss')
  }
})

```

webview基础库中提供Page的实现。

service：全局对外函数，my birdge，app实例、page实例以及路由堆栈管理，全局事件监听


#### 揭秘字节小程序

webview: 基于自研类react框架Yaw渲染；内置组件基于Polymer实现，与基础库解耦。