/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/@babel/runtime/helpers/assertThisInitialized.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/assertThisInitialized.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

module.exports = _assertThisInitialized;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/asyncToGenerator.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/asyncToGenerator.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

module.exports = _asyncToGenerator;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/classCallCheck.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/classCallCheck.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

module.exports = _classCallCheck;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/createClass.js":
/*!************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/createClass.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

module.exports = _createClass;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/defineProperty.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/defineProperty.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

module.exports = _defineProperty;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js ***!
  \*********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _arrayLikeToArray; });
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js ***!
  \**********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _arrayWithoutHoles; });
/* harmony import */ var _arrayLikeToArray_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./arrayLikeToArray.js */ "./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js");

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return Object(_arrayLikeToArray_js__WEBPACK_IMPORTED_MODULE_0__["default"])(arr);
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/iterableToArray.js":
/*!********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/iterableToArray.js ***!
  \********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _iterableToArray; });
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js ***!
  \**********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _nonIterableSpread; });
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js ***!
  \**********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _toConsumableArray; });
/* harmony import */ var _arrayWithoutHoles_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./arrayWithoutHoles.js */ "./node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js");
/* harmony import */ var _iterableToArray_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./iterableToArray.js */ "./node_modules/@babel/runtime/helpers/esm/iterableToArray.js");
/* harmony import */ var _unsupportedIterableToArray_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./unsupportedIterableToArray.js */ "./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js");
/* harmony import */ var _nonIterableSpread_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./nonIterableSpread.js */ "./node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js");




function _toConsumableArray(arr) {
  return Object(_arrayWithoutHoles_js__WEBPACK_IMPORTED_MODULE_0__["default"])(arr) || Object(_iterableToArray_js__WEBPACK_IMPORTED_MODULE_1__["default"])(arr) || Object(_unsupportedIterableToArray_js__WEBPACK_IMPORTED_MODULE_2__["default"])(arr) || Object(_nonIterableSpread_js__WEBPACK_IMPORTED_MODULE_3__["default"])();
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js ***!
  \*******************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _unsupportedIterableToArray; });
/* harmony import */ var _arrayLikeToArray_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./arrayLikeToArray.js */ "./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js");

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return Object(_arrayLikeToArray_js__WEBPACK_IMPORTED_MODULE_0__["default"])(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Object(_arrayLikeToArray_js__WEBPACK_IMPORTED_MODULE_0__["default"])(o, minLen);
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/extends.js":
/*!********************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/extends.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _extends() {
  module.exports = _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  module.exports["default"] = module.exports, module.exports.__esModule = true;
  return _extends.apply(this, arguments);
}

module.exports = _extends;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/get.js":
/*!****************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/get.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var superPropBase = __webpack_require__(/*! ./superPropBase.js */ "./node_modules/@babel/runtime/helpers/superPropBase.js");

function _get(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    module.exports = _get = Reflect.get;
    module.exports["default"] = module.exports, module.exports.__esModule = true;
  } else {
    module.exports = _get = function _get(target, property, receiver) {
      var base = superPropBase(target, property);
      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);

      if (desc.get) {
        return desc.get.call(receiver);
      }

      return desc.value;
    };

    module.exports["default"] = module.exports, module.exports.__esModule = true;
  }

  return _get(target, property, receiver || target);
}

module.exports = _get;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/getPrototypeOf.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _getPrototypeOf(o) {
  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  module.exports["default"] = module.exports, module.exports.__esModule = true;
  return _getPrototypeOf(o);
}

module.exports = _getPrototypeOf;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/inherits.js":
/*!*********************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/inherits.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var setPrototypeOf = __webpack_require__(/*! ./setPrototypeOf.js */ "./node_modules/@babel/runtime/helpers/setPrototypeOf.js");

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) setPrototypeOf(subClass, superClass);
}

module.exports = _inherits;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/objectWithoutProperties.js":
/*!************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/objectWithoutProperties.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var objectWithoutPropertiesLoose = __webpack_require__(/*! ./objectWithoutPropertiesLoose.js */ "./node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose.js");

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = objectWithoutPropertiesLoose(source, excluded);
  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

module.exports = _objectWithoutProperties;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

module.exports = _objectWithoutPropertiesLoose;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = __webpack_require__(/*! @babel/runtime/helpers/typeof */ "./node_modules/@babel/runtime/helpers/typeof.js")["default"];

var assertThisInitialized = __webpack_require__(/*! ./assertThisInitialized.js */ "./node_modules/@babel/runtime/helpers/assertThisInitialized.js");

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return assertThisInitialized(self);
}

module.exports = _possibleConstructorReturn;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/setPrototypeOf.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/setPrototypeOf.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _setPrototypeOf(o, p) {
  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  module.exports["default"] = module.exports, module.exports.__esModule = true;
  return _setPrototypeOf(o, p);
}

module.exports = _setPrototypeOf;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/superPropBase.js":
/*!**************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/superPropBase.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getPrototypeOf = __webpack_require__(/*! ./getPrototypeOf.js */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js");

function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = getPrototypeOf(object);
    if (object === null) break;
  }

  return object;
}

module.exports = _superPropBase;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/taggedTemplateLiteral.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/taggedTemplateLiteral.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _taggedTemplateLiteral(strings, raw) {
  if (!raw) {
    raw = strings.slice(0);
  }

  return Object.freeze(Object.defineProperties(strings, {
    raw: {
      value: Object.freeze(raw)
    }
  }));
}

module.exports = _taggedTemplateLiteral;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/typeof.js":
/*!*******************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/typeof.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    module.exports = _typeof = function _typeof(obj) {
      return typeof obj;
    };

    module.exports["default"] = module.exports, module.exports.__esModule = true;
  } else {
    module.exports = _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };

    module.exports["default"] = module.exports, module.exports.__esModule = true;
  }

  return _typeof(obj);
}

module.exports = _typeof;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@babel/runtime/regenerator/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@babel/runtime/regenerator/index.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! regenerator-runtime */ "./node_modules/regenerator-runtime/runtime.js");

/***/ }),

/***/ "./node_modules/@polymer/polymer/lib/elements/dom-if.js":
/*!**************************************************************!*\
  !*** ./node_modules/@polymer/polymer/lib/elements/dom-if.js ***!
  \**************************************************************/
/*! exports provided: DomIf */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DomIf", function() { return DomIf; });
/* harmony import */ var _polymer_element_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../polymer-element.js */ "./node_modules/@polymer/polymer/polymer-element.js");
/* harmony import */ var _utils_debounce_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/debounce.js */ "./node_modules/@polymer/polymer/lib/utils/debounce.js");
/* harmony import */ var _utils_flush_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/flush.js */ "./node_modules/@polymer/polymer/lib/utils/flush.js");
/* harmony import */ var _utils_async_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/async.js */ "./node_modules/@polymer/polymer/lib/utils/async.js");
/* harmony import */ var _utils_path_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/path.js */ "./node_modules/@polymer/polymer/lib/utils/path.js");
/* harmony import */ var _utils_wrap_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/wrap.js */ "./node_modules/@polymer/polymer/lib/utils/wrap.js");
/* harmony import */ var _utils_hide_template_controls_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/hide-template-controls.js */ "./node_modules/@polymer/polymer/lib/utils/hide-template-controls.js");
/* harmony import */ var _utils_settings_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils/settings.js */ "./node_modules/@polymer/polymer/lib/utils/settings.js");
/* harmony import */ var _utils_templatize_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../utils/templatize.js */ "./node_modules/@polymer/polymer/lib/utils/templatize.js");
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/









/**
 * @customElement
 * @polymer
 * @extends PolymerElement
 * @summary Base class for dom-if element; subclassed into concrete
 *   implementation.
 */

class DomIfBase extends _polymer_element_js__WEBPACK_IMPORTED_MODULE_0__["PolymerElement"] {
  // Not needed to find template; can be removed once the analyzer
  // can find the tag name from customElements.define call
  static get is() {
    return 'dom-if';
  }

  static get template() {
    return null;
  }

  static get properties() {
    return {
      /**
       * Fired whenever DOM is added or removed/hidden by this template (by
       * default, rendering occurs lazily).  To force immediate rendering, call
       * `render`.
       *
       * @event dom-change
       */

      /**
       * A boolean indicating whether this template should stamp.
       */
      if: {
        type: Boolean,
        observer: '__debounceRender'
      },

      /**
       * When true, elements will be removed from DOM and discarded when `if`
       * becomes false and re-created and added back to the DOM when `if`
       * becomes true.  By default, stamped elements will be hidden but left
       * in the DOM when `if` becomes false, which is generally results
       * in better performance.
       */
      restamp: {
        type: Boolean,
        observer: '__debounceRender'
      },

      /**
       * When the global `suppressTemplateNotifications` setting is used, setting
       * `notifyDomChange: true` will enable firing `dom-change` events on this
       * element.
       */
      notifyDomChange: {
        type: Boolean
      }
    };
  }

  constructor() {
    super();
    this.__renderDebouncer = null;
    this._lastIf = false;
    this.__hideTemplateChildren__ = false;
    /** @type {!HTMLTemplateElement|undefined} */

    this.__template;
    /** @type {!TemplateInfo|undefined} */

    this._templateInfo;
  }

  __debounceRender() {
    // Render is async for 2 reasons:
    // 1. To eliminate dom creation trashing if user code thrashes `if` in the
    //    same turn. This was more common in 1.x where a compound computed
    //    property could result in the result changing multiple times, but is
    //    mitigated to a large extent by batched property processing in 2.x.
    // 2. To avoid double object propagation when a bag including values bound
    //    to the `if` property as well as one or more hostProps could enqueue
    //    the <dom-if> to flush before the <template>'s host property
    //    forwarding. In that scenario creating an instance would result in
    //    the host props being set once, and then the enqueued changes on the
    //    template would set properties a second time, potentially causing an
    //    object to be set to an instance more than once.  Creating the
    //    instance async from flushing data ensures this doesn't happen. If
    //    we wanted a sync option in the future, simply having <dom-if> flush
    //    (or clear) its template's pending host properties before creating
    //    the instance would also avoid the problem.
    this.__renderDebouncer = _utils_debounce_js__WEBPACK_IMPORTED_MODULE_1__["Debouncer"].debounce(this.__renderDebouncer, _utils_async_js__WEBPACK_IMPORTED_MODULE_3__["microTask"], () => this.__render());
    Object(_utils_flush_js__WEBPACK_IMPORTED_MODULE_2__["enqueueDebouncer"])(this.__renderDebouncer);
  }
  /**
   * @override
   * @return {void}
   */


  disconnectedCallback() {
    super.disconnectedCallback();
    const parent = Object(_utils_wrap_js__WEBPACK_IMPORTED_MODULE_5__["wrap"])(this).parentNode;

    if (!parent || parent.nodeType == Node.DOCUMENT_FRAGMENT_NODE && !Object(_utils_wrap_js__WEBPACK_IMPORTED_MODULE_5__["wrap"])(parent).host) {
      this.__teardownInstance();
    }
  }
  /**
   * @override
   * @return {void}
   */


  connectedCallback() {
    super.connectedCallback();

    if (!Object(_utils_hide_template_controls_js__WEBPACK_IMPORTED_MODULE_6__["hideElementsGlobally"])()) {
      this.style.display = 'none';
    }

    if (this.if) {
      this.__debounceRender();
    }
  }
  /**
   * Ensures a template has been assigned to `this.__template`.  If it has not
   * yet been, it querySelectors for it in its children and if it does not yet
   * exist (e.g. in parser-generated case), opens a mutation observer and
   * waits for it to appear (returns false if it has not yet been found,
   * otherwise true).  In the `removeNestedTemplates` case, the "template" will
   * be the `dom-if` element itself.
   *
   * @return {boolean} True when a template has been found, false otherwise
   */


  __ensureTemplate() {
    if (!this.__template) {
      // When `removeNestedTemplates` is true, the "template" is the element
      // itself, which has been given a `_templateInfo` property
      const thisAsTemplate =
      /** @type {!HTMLTemplateElement} */

      /** @type {!HTMLElement} */
      this;
      let template = thisAsTemplate._templateInfo ? thisAsTemplate :
      /** @type {!HTMLTemplateElement} */
      Object(_utils_wrap_js__WEBPACK_IMPORTED_MODULE_5__["wrap"])(thisAsTemplate).querySelector('template');

      if (!template) {
        // Wait until childList changes and template should be there by then
        let observer = new MutationObserver(() => {
          if (Object(_utils_wrap_js__WEBPACK_IMPORTED_MODULE_5__["wrap"])(this).querySelector('template')) {
            observer.disconnect();

            this.__render();
          } else {
            throw new Error('dom-if requires a <template> child');
          }
        });
        observer.observe(this, {
          childList: true
        });
        return false;
      }

      this.__template = template;
    }

    return true;
  }
  /**
   * Ensures a an instance of the template has been created and inserted. This
   * method may return false if the template has not yet been found or if
   * there is no `parentNode` to insert the template into (in either case,
   * connection or the template-finding mutation observer firing will queue
   * another render, causing this method to be called again at a more
   * appropriate time).
   *
   * Subclasses should implement the following methods called here:
   * - `__hasInstance`
   * - `__createAndInsertInstance`
   * - `__getInstanceNodes`
   *
   * @return {boolean} True if the instance was created, false otherwise.
   */


  __ensureInstance() {
    let parentNode = Object(_utils_wrap_js__WEBPACK_IMPORTED_MODULE_5__["wrap"])(this).parentNode;

    if (!this.__hasInstance()) {
      // Guard against element being detached while render was queued
      if (!parentNode) {
        return false;
      } // Find the template (when false, there was no template yet)


      if (!this.__ensureTemplate()) {
        return false;
      }

      this.__createAndInsertInstance(parentNode);
    } else {
      // Move instance children if necessary
      let children = this.__getInstanceNodes();

      if (children && children.length) {
        // Detect case where dom-if was re-attached in new position
        let lastChild = Object(_utils_wrap_js__WEBPACK_IMPORTED_MODULE_5__["wrap"])(this).previousSibling;

        if (lastChild !== children[children.length - 1]) {
          for (let i = 0, n; i < children.length && (n = children[i]); i++) {
            Object(_utils_wrap_js__WEBPACK_IMPORTED_MODULE_5__["wrap"])(parentNode).insertBefore(n, this);
          }
        }
      }
    }

    return true;
  }
  /**
   * Forces the element to render its content. Normally rendering is
   * asynchronous to a provoking change. This is done for efficiency so
   * that multiple changes trigger only a single render. The render method
   * should be called if, for example, template rendering is required to
   * validate application state.
   *
   * @return {void}
   */


  render() {
    Object(_utils_flush_js__WEBPACK_IMPORTED_MODULE_2__["flush"])();
  }
  /**
   * Performs the key rendering steps:
   * 1. Ensure a template instance has been stamped (when true)
   * 2. Remove the template instance (when false and restamp:true)
   * 3. Sync the hidden state of the instance nodes with the if/restamp state
   * 4. Fires the `dom-change` event when necessary
   *
   * @return {void}
   */


  __render() {
    if (this.if) {
      if (!this.__ensureInstance()) {
        // No template found yet
        return;
      }
    } else if (this.restamp) {
      this.__teardownInstance();
    }

    this._showHideChildren();

    if ((!_utils_settings_js__WEBPACK_IMPORTED_MODULE_7__["suppressTemplateNotifications"] || this.notifyDomChange) && this.if != this._lastIf) {
      this.dispatchEvent(new CustomEvent('dom-change', {
        bubbles: true,
        composed: true
      }));
      this._lastIf = this.if;
    }
  } // Ideally these would be annotated as abstract methods in an abstract class,
  // but closure compiler is finnicky

  /* eslint-disable valid-jsdoc */

  /**
   * Abstract API to be implemented by subclass: Returns true if a template
   * instance has been created and inserted.
   *
   * @protected
   * @return {boolean} True when an instance has been created.
   */


  __hasInstance() {}
  /**
   * Abstract API to be implemented by subclass: Returns the child nodes stamped
   * from a template instance.
   *
   * @protected
   * @return {Array<Node>} Array of child nodes stamped from the template
   * instance.
   */


  __getInstanceNodes() {}
  /**
   * Abstract API to be implemented by subclass: Creates an instance of the
   * template and inserts it into the given parent node.
   *
   * @protected
   * @param {Node} parentNode The parent node to insert the instance into
   * @return {void}
   */


  __createAndInsertInstance(parentNode) {} // eslint-disable-line no-unused-vars

  /**
   * Abstract API to be implemented by subclass: Removes nodes created by an
   * instance of a template and any associated cleanup.
   *
   * @protected
   * @return {void}
   */


  __teardownInstance() {}
  /**
   * Abstract API to be implemented by subclass: Shows or hides any template
   * instance childNodes based on the `if` state of the element and its
   * `__hideTemplateChildren__` property.
   *
   * @protected
   * @return {void}
   */


  _showHideChildren() {}
  /* eslint-enable valid-jsdoc */


}
/**
 * The version of DomIf used when `fastDomIf` setting is in use, which is
 * optimized for first-render (but adds a tax to all subsequent property updates
 * on the host, whether they were used in a given `dom-if` or not).
 *
 * This implementation avoids use of `Templatizer`, which introduces a new scope
 * (a non-element PropertyEffects instance), which is not strictly necessary
 * since `dom-if` never introduces new properties to its scope (unlike
 * `dom-repeat`). Taking advantage of this fact, the `dom-if` reaches up to its
 * `__dataHost` and stamps the template directly from the host using the host's
 * runtime `_stampTemplate` API, which binds the property effects of the
 * template directly to the host. This both avoids the intermediary
 * `Templatizer` instance, but also avoids the need to bind host properties to
 * the `<template>` element and forward those into the template instance.
 *
 * In this version of `dom-if`, the `this.__instance` method is the
 * `DocumentFragment` returned from `_stampTemplate`, which also serves as the
 * handle for later removing it using the `_removeBoundDom` method.
 */


class DomIfFast extends DomIfBase {
  constructor() {
    super();
    this.__instance = null;
    this.__syncInfo = null;
  }
  /**
   * Implementation of abstract API needed by DomIfBase.
   *
   * @override
   * @return {boolean} True when an instance has been created.
   */


  __hasInstance() {
    return Boolean(this.__instance);
  }
  /**
   * Implementation of abstract API needed by DomIfBase.
   *
   * @override
   * @return {Array<Node>} Array of child nodes stamped from the template
   * instance.
   */


  __getInstanceNodes() {
    return this.__instance.templateInfo.childNodes;
  }
  /**
   * Implementation of abstract API needed by DomIfBase.
   *
   * Stamps the template by calling `_stampTemplate` on the `__dataHost` of this
   * element and then inserts the resulting nodes into the given `parentNode`.
   *
   * @override
   * @param {Node} parentNode The parent node to insert the instance into
   * @return {void}
   */


  __createAndInsertInstance(parentNode) {
    const host = this.__dataHost || this;

    if (_utils_settings_js__WEBPACK_IMPORTED_MODULE_7__["strictTemplatePolicy"]) {
      if (!this.__dataHost) {
        throw new Error('strictTemplatePolicy: template owner not trusted');
      }
    } // Pre-bind and link the template into the effects system


    const templateInfo = host._bindTemplate(
    /** @type {!HTMLTemplateElement} */
    this.__template, true); // Install runEffects hook that prevents running property effects
    // (and any nested template effects) when the `if` is false


    templateInfo.runEffects = (runEffects, changedProps, hasPaths) => {
      let syncInfo = this.__syncInfo;

      if (this.if) {
        // Mix any props that changed while the `if` was false into `changedProps`
        if (syncInfo) {
          // If there were properties received while the `if` was false, it is
          // important to sync the hidden state with the element _first_, so that
          // new bindings to e.g. `textContent` do not get stomped on by
          // pre-hidden values if `_showHideChildren` were to be called later at
          // the next render. Clearing `__invalidProps` here ensures
          // `_showHideChildren`'s call to `__syncHostProperties` no-ops, so
          // that we don't call `runEffects` more often than necessary.
          this.__syncInfo = null;

          this._showHideChildren();

          changedProps = Object.assign(syncInfo.changedProps, changedProps);
        }

        runEffects(changedProps, hasPaths);
      } else {
        // Accumulate any values changed while `if` was false, along with the
        // runEffects method to sync them, so that we can replay them once `if`
        // becomes true
        if (this.__instance) {
          if (!syncInfo) {
            syncInfo = this.__syncInfo = {
              runEffects,
              changedProps: {}
            };
          }

          if (hasPaths) {
            // Store root object of any paths; this will ensure direct bindings
            // like [[obj.foo]] bindings run after a `set('obj.foo', v)`, but
            // note that path notifications like `set('obj.foo.bar', v)` will
            // not propagate. Since batched path notifications are not
            // supported, we cannot simply accumulate path notifications. This
            // is equivalent to the non-fastDomIf case, which stores root(p) in
            // __invalidProps.
            for (const p in changedProps) {
              const rootProp = Object(_utils_path_js__WEBPACK_IMPORTED_MODULE_4__["root"])(p);
              syncInfo.changedProps[rootProp] = this.__dataHost[rootProp];
            }
          } else {
            Object.assign(syncInfo.changedProps, changedProps);
          }
        }
      }
    }; // Stamp the template, and set its DocumentFragment to the "instance"


    this.__instance = host._stampTemplate(
    /** @type {!HTMLTemplateElement} */
    this.__template, templateInfo);
    Object(_utils_wrap_js__WEBPACK_IMPORTED_MODULE_5__["wrap"])(parentNode).insertBefore(this.__instance, this);
  }
  /**
   * Run effects for any properties that changed while the `if` was false.
   *
   * @return {void}
   */


  __syncHostProperties() {
    const syncInfo = this.__syncInfo;

    if (syncInfo) {
      this.__syncInfo = null;
      syncInfo.runEffects(syncInfo.changedProps, false);
    }
  }
  /**
   * Implementation of abstract API needed by DomIfBase.
   *
   * Remove the instance and any nodes it created.  Uses the `__dataHost`'s
   * runtime `_removeBoundDom` method.
   *
   * @override
   * @return {void}
   */


  __teardownInstance() {
    const host = this.__dataHost || this;

    if (this.__instance) {
      host._removeBoundDom(this.__instance);

      this.__instance = null;
      this.__syncInfo = null;
    }
  }
  /**
   * Implementation of abstract API needed by DomIfBase.
   *
   * Shows or hides the template instance top level child nodes. For
   * text nodes, `textContent` is removed while "hidden" and replaced when
   * "shown."
   *
   * @override
   * @return {void}
   * @protected
   * @suppress {visibility}
   */


  _showHideChildren() {
    const hidden = this.__hideTemplateChildren__ || !this.if;

    if (this.__instance && Boolean(this.__instance.__hidden) !== hidden) {
      this.__instance.__hidden = hidden;
      Object(_utils_templatize_js__WEBPACK_IMPORTED_MODULE_8__["showHideChildren"])(hidden, this.__instance.templateInfo.childNodes);
    }

    if (!hidden) {
      this.__syncHostProperties();
    }
  }

}
/**
 * The "legacy" implementation of `dom-if`, implemented using `Templatizer`.
 *
 * In this version, `this.__instance` is the `TemplateInstance` returned
 * from the templatized constructor.
 */


class DomIfLegacy extends DomIfBase {
  constructor() {
    super();
    this.__ctor = null;
    this.__instance = null;
    this.__invalidProps = null;
  }
  /**
   * Implementation of abstract API needed by DomIfBase.
   *
   * @override
   * @return {boolean} True when an instance has been created.
   */


  __hasInstance() {
    return Boolean(this.__instance);
  }
  /**
   * Implementation of abstract API needed by DomIfBase.
   *
   * @override
   * @return {Array<Node>} Array of child nodes stamped from the template
   * instance.
   */


  __getInstanceNodes() {
    return this.__instance.children;
  }
  /**
   * Implementation of abstract API needed by DomIfBase.
   *
   * Stamps the template by creating a new instance of the templatized
   * constructor (which is created lazily if it does not yet exist), and then
   * inserts its resulting `root` doc fragment into the given `parentNode`.
   *
   * @override
   * @param {Node} parentNode The parent node to insert the instance into
   * @return {void}
   */


  __createAndInsertInstance(parentNode) {
    // Ensure we have an instance constructor
    if (!this.__ctor) {
      this.__ctor = Object(_utils_templatize_js__WEBPACK_IMPORTED_MODULE_8__["templatize"])(
      /** @type {!HTMLTemplateElement} */
      this.__template, this, {
        // dom-if templatizer instances require `mutable: true`, as
        // `__syncHostProperties` relies on that behavior to sync objects
        mutableData: true,

        /**
         * @param {string} prop Property to forward
         * @param {*} value Value of property
         * @this {DomIfLegacy}
         */
        forwardHostProp: function (prop, value) {
          if (this.__instance) {
            if (this.if) {
              this.__instance.forwardHostProp(prop, value);
            } else {
              // If we have an instance but are squelching host property
              // forwarding due to if being false, note the invalidated
              // properties so `__syncHostProperties` can sync them the next
              // time `if` becomes true
              this.__invalidProps = this.__invalidProps || Object.create(null);
              this.__invalidProps[Object(_utils_path_js__WEBPACK_IMPORTED_MODULE_4__["root"])(prop)] = true;
            }
          }
        }
      });
    } // Create and insert the instance


    this.__instance = new this.__ctor();
    Object(_utils_wrap_js__WEBPACK_IMPORTED_MODULE_5__["wrap"])(parentNode).insertBefore(this.__instance.root, this);
  }
  /**
   * Implementation of abstract API needed by DomIfBase.
   *
   * Removes the instance and any nodes it created.
   *
   * @override
   * @return {void}
   */


  __teardownInstance() {
    if (this.__instance) {
      let c$ = this.__instance.children;

      if (c$ && c$.length) {
        // use first child parent, for case when dom-if may have been detached
        let parent = Object(_utils_wrap_js__WEBPACK_IMPORTED_MODULE_5__["wrap"])(c$[0]).parentNode; // Instance children may be disconnected from parents when dom-if
        // detaches if a tree was innerHTML'ed

        if (parent) {
          parent = Object(_utils_wrap_js__WEBPACK_IMPORTED_MODULE_5__["wrap"])(parent);

          for (let i = 0, n; i < c$.length && (n = c$[i]); i++) {
            parent.removeChild(n);
          }
        }
      }

      this.__invalidProps = null;
      this.__instance = null;
    }
  }
  /**
   * Forwards any properties that changed while the `if` was false into the
   * template instance and flushes it.
   *
   * @return {void}
   */


  __syncHostProperties() {
    let props = this.__invalidProps;

    if (props) {
      this.__invalidProps = null;

      for (let prop in props) {
        this.__instance._setPendingProperty(prop, this.__dataHost[prop]);
      }

      this.__instance._flushProperties();
    }
  }
  /**
   * Implementation of abstract API needed by DomIfBase.
   *
   * Shows or hides the template instance top level child elements. For
   * text nodes, `textContent` is removed while "hidden" and replaced when
   * "shown."
   *
   * @override
   * @protected
   * @return {void}
   * @suppress {visibility}
   */


  _showHideChildren() {
    const hidden = this.__hideTemplateChildren__ || !this.if;

    if (this.__instance && Boolean(this.__instance.__hidden) !== hidden) {
      this.__instance.__hidden = hidden;

      this.__instance._showHideChildren(hidden);
    }

    if (!hidden) {
      this.__syncHostProperties();
    }
  }

}
/**
 * The `<dom-if>` element will stamp a light-dom `<template>` child when
 * the `if` property becomes truthy, and the template can use Polymer
 * data-binding and declarative event features when used in the context of
 * a Polymer element's template.
 *
 * When `if` becomes falsy, the stamped content is hidden but not
 * removed from dom. When `if` subsequently becomes truthy again, the content
 * is simply re-shown. This approach is used due to its favorable performance
 * characteristics: the expense of creating template content is paid only
 * once and lazily.
 *
 * Set the `restamp` property to true to force the stamped content to be
 * created / destroyed when the `if` condition changes.
 *
 * @customElement
 * @polymer
 * @extends DomIfBase
 * @constructor
 * @summary Custom element that conditionally stamps and hides or removes
 *   template content based on a boolean flag.
 */


const DomIf = _utils_settings_js__WEBPACK_IMPORTED_MODULE_7__["fastDomIf"] ? DomIfFast : DomIfLegacy;
customElements.define(DomIf.is, DomIf);

/***/ }),

/***/ "./node_modules/@polymer/polymer/lib/elements/dom-module.js":
/*!******************************************************************!*\
  !*** ./node_modules/@polymer/polymer/lib/elements/dom-module.js ***!
  \******************************************************************/
/*! exports provided: DomModule */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DomModule", function() { return DomModule; });
/* harmony import */ var _utils_boot_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/boot.js */ "./node_modules/@polymer/polymer/lib/utils/boot.js");
/* harmony import */ var _utils_resolve_url_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/resolve-url.js */ "./node_modules/@polymer/polymer/lib/utils/resolve-url.js");
/* harmony import */ var _utils_settings_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/settings.js */ "./node_modules/@polymer/polymer/lib/utils/settings.js");
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/



let modules = {};
let lcModules = {};
/**
 * Sets a dom-module into the global registry by id.
 *
 * @param {string} id dom-module id
 * @param {DomModule} module dom-module instance
 * @return {void}
 */

function setModule(id, module) {
  // store id separate from lowercased id so that
  // in all cases mixedCase id will stored distinctly
  // and lowercase version is a fallback
  modules[id] = lcModules[id.toLowerCase()] = module;
}
/**
 * Retrieves a dom-module from the global registry by id.
 *
 * @param {string} id dom-module id
 * @return {DomModule!} dom-module instance
 */


function findModule(id) {
  return modules[id] || lcModules[id.toLowerCase()];
}

function styleOutsideTemplateCheck(inst) {
  if (inst.querySelector('style')) {
    console.warn('dom-module %s has style outside template', inst.id);
  }
}
/**
 * The `dom-module` element registers the dom it contains to the name given
 * by the module's id attribute. It provides a unified database of dom
 * accessible via its static `import` API.
 *
 * A key use case of `dom-module` is for providing custom element `<template>`s
 * via HTML imports that are parsed by the native HTML parser, that can be
 * relocated during a bundling pass and still looked up by `id`.
 *
 * Example:
 *
 *     <dom-module id="foo">
 *       <img src="stuff.png">
 *     </dom-module>
 *
 * Then in code in some other location that cannot access the dom-module above
 *
 *     let img = customElements.get('dom-module').import('foo', 'img');
 *
 * @customElement
 * @extends HTMLElement
 * @summary Custom element that provides a registry of relocatable DOM content
 *   by `id` that is agnostic to bundling.
 * @unrestricted
 */


class DomModule extends HTMLElement {
  /** @override */
  static get observedAttributes() {
    return ['id'];
  }
  /**
   * Retrieves the element specified by the css `selector` in the module
   * registered by `id`. For example, this.import('foo', 'img');
   * @param {string} id The id of the dom-module in which to search.
   * @param {string=} selector The css selector by which to find the element.
   * @return {Element} Returns the element which matches `selector` in the
   * module registered at the specified `id`.
   *
   * @export
   * @nocollapse Referred to indirectly in style-gather.js
   */


  static import(id, selector) {
    if (id) {
      let m = findModule(id);

      if (m && selector) {
        return m.querySelector(selector);
      }

      return m;
    }

    return null;
  }
  /* eslint-disable no-unused-vars */

  /**
   * @param {string} name Name of attribute.
   * @param {?string} old Old value of attribute.
   * @param {?string} value Current value of attribute.
   * @param {?string} namespace Attribute namespace.
   * @return {void}
   * @override
   */


  attributeChangedCallback(name, old, value, namespace) {
    if (old !== value) {
      this.register();
    }
  }
  /* eslint-enable no-unused-args */

  /**
   * The absolute URL of the original location of this `dom-module`.
   *
   * This value will differ from this element's `ownerDocument` in the
   * following ways:
   * - Takes into account any `assetpath` attribute added during bundling
   *   to indicate the original location relative to the bundled location
   * - Uses the HTMLImports polyfill's `importForElement` API to ensure
   *   the path is relative to the import document's location since
   *   `ownerDocument` is not currently polyfilled
   */


  get assetpath() {
    // Don't override existing assetpath.
    if (!this.__assetpath) {
      // note: assetpath set via an attribute must be relative to this
      // element's location; accomodate polyfilled HTMLImports
      const owner = window.HTMLImports && HTMLImports.importForElement ? HTMLImports.importForElement(this) || document : this.ownerDocument;
      const url = Object(_utils_resolve_url_js__WEBPACK_IMPORTED_MODULE_1__["resolveUrl"])(this.getAttribute('assetpath') || '', owner.baseURI);
      this.__assetpath = Object(_utils_resolve_url_js__WEBPACK_IMPORTED_MODULE_1__["pathFromUrl"])(url);
    }

    return this.__assetpath;
  }
  /**
   * Registers the dom-module at a given id. This method should only be called
   * when a dom-module is imperatively created. For
   * example, `document.createElement('dom-module').register('foo')`.
   * @param {string=} id The id at which to register the dom-module.
   * @return {void}
   */


  register(id) {
    id = id || this.id;

    if (id) {
      // Under strictTemplatePolicy, reject and null out any re-registered
      // dom-module since it is ambiguous whether first-in or last-in is trusted
      if (_utils_settings_js__WEBPACK_IMPORTED_MODULE_2__["strictTemplatePolicy"] && findModule(id) !== undefined) {
        setModule(id, null);
        throw new Error(`strictTemplatePolicy: dom-module ${id} re-registered`);
      }

      this.id = id;
      setModule(id, this);
      styleOutsideTemplateCheck(this);
    }
  }

}
DomModule.prototype['modules'] = modules;
customElements.define('dom-module', DomModule);

/***/ }),

/***/ "./node_modules/@polymer/polymer/lib/elements/dom-repeat.js":
/*!******************************************************************!*\
  !*** ./node_modules/@polymer/polymer/lib/elements/dom-repeat.js ***!
  \******************************************************************/
/*! exports provided: DomRepeat */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DomRepeat", function() { return DomRepeat; });
/* harmony import */ var _polymer_element_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../polymer-element.js */ "./node_modules/@polymer/polymer/polymer-element.js");
/* harmony import */ var _utils_templatize_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/templatize.js */ "./node_modules/@polymer/polymer/lib/utils/templatize.js");
/* harmony import */ var _utils_debounce_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/debounce.js */ "./node_modules/@polymer/polymer/lib/utils/debounce.js");
/* harmony import */ var _utils_flush_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/flush.js */ "./node_modules/@polymer/polymer/lib/utils/flush.js");
/* harmony import */ var _mixins_mutable_data_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../mixins/mutable-data.js */ "./node_modules/@polymer/polymer/lib/mixins/mutable-data.js");
/* harmony import */ var _utils_path_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/path.js */ "./node_modules/@polymer/polymer/lib/utils/path.js");
/* harmony import */ var _utils_async_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/async.js */ "./node_modules/@polymer/polymer/lib/utils/async.js");
/* harmony import */ var _utils_wrap_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils/wrap.js */ "./node_modules/@polymer/polymer/lib/utils/wrap.js");
/* harmony import */ var _utils_hide_template_controls_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../utils/hide-template-controls.js */ "./node_modules/@polymer/polymer/lib/utils/hide-template-controls.js");
/* harmony import */ var _utils_settings_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../utils/settings.js */ "./node_modules/@polymer/polymer/lib/utils/settings.js");
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

 // eslint-disable-line no-unused-vars









/**
 * @constructor
 * @implements {Polymer_OptionalMutableData}
 * @extends {PolymerElement}
 * @private
 */

const domRepeatBase = Object(_mixins_mutable_data_js__WEBPACK_IMPORTED_MODULE_4__["OptionalMutableData"])(_polymer_element_js__WEBPACK_IMPORTED_MODULE_0__["PolymerElement"]);
/**
 * The `<dom-repeat>` element will automatically stamp and binds one instance
 * of template content to each object in a user-provided array.
 * `dom-repeat` accepts an `items` property, and one instance of the template
 * is stamped for each item into the DOM at the location of the `dom-repeat`
 * element.  The `item` property will be set on each instance's binding
 * scope, thus templates should bind to sub-properties of `item`.
 *
 * Example:
 *
 * ```html
 * <dom-module id="employee-list">
 *
 *   <template>
 *
 *     <div> Employee list: </div>
 *     <dom-repeat items="{{employees}}">
 *       <template>
 *         <div>First name: <span>{{item.first}}</span></div>
 *         <div>Last name: <span>{{item.last}}</span></div>
 *       </template>
 *     </dom-repeat>
 *
 *   </template>
 *
 * </dom-module>
 * ```
 *
 * With the following custom element definition:
 *
 * ```js
 * class EmployeeList extends PolymerElement {
 *   static get is() { return 'employee-list'; }
 *   static get properties() {
 *     return {
 *       employees: {
 *         value() {
 *           return [
 *             {first: 'Bob', last: 'Smith'},
 *             {first: 'Sally', last: 'Johnson'},
 *             ...
 *           ];
 *         }
 *       }
 *     };
 *   }
 * }
 * ```
 *
 * Notifications for changes to items sub-properties will be forwarded to template
 * instances, which will update via the normal structured data notification system.
 *
 * Mutations to the `items` array itself should be made using the Array
 * mutation API's on the PropertyEffects mixin (`push`, `pop`, `splice`,
 * `shift`, `unshift`), and template instances will be kept in sync with the
 * data in the array.
 *
 * Events caught by event handlers within the `dom-repeat` template will be
 * decorated with a `model` property, which represents the binding scope for
 * each template instance.  The model should be used to manipulate data on the
 * instance, for example `event.model.set('item.checked', true);`.
 *
 * Alternatively, the model for a template instance for an element stamped by
 * a `dom-repeat` can be obtained using the `modelForElement` API on the
 * `dom-repeat` that stamped it, for example
 * `this.$.domRepeat.modelForElement(event.target).set('item.checked', true);`.
 * This may be useful for manipulating instance data of event targets obtained
 * by event handlers on parents of the `dom-repeat` (event delegation).
 *
 * A view-specific filter/sort may be applied to each `dom-repeat` by supplying a
 * `filter` and/or `sort` property.  This may be a string that names a function on
 * the host, or a function may be assigned to the property directly.  The functions
 * should implemented following the standard `Array` filter/sort API.
 *
 * In order to re-run the filter or sort functions based on changes to sub-fields
 * of `items`, the `observe` property may be set as a space-separated list of
 * `item` sub-fields that should cause a re-filter/sort when modified.  If
 * the filter or sort function depends on properties not contained in `items`,
 * the user should observe changes to those properties and call `render` to update
 * the view based on the dependency change.
 *
 * For example, for an `dom-repeat` with a filter of the following:
 *
 * ```js
 * isEngineer(item) {
 *   return item.type == 'engineer' || item.manager.type == 'engineer';
 * }
 * ```
 *
 * Then the `observe` property should be configured as follows:
 *
 * ```html
 * <dom-repeat items="{{employees}}" filter="isEngineer" observe="type manager.type">
 * ```
 *
 * @customElement
 * @polymer
 * @extends {domRepeatBase}
 * @appliesMixin OptionalMutableData
 * @summary Custom element for stamping instance of a template bound to
 *   items in an array.
 */

class DomRepeat extends domRepeatBase {
  // Not needed to find template; can be removed once the analyzer
  // can find the tag name from customElements.define call
  static get is() {
    return 'dom-repeat';
  }

  static get template() {
    return null;
  }

  static get properties() {
    /**
     * Fired whenever DOM is added or removed by this template (by
     * default, rendering occurs lazily).  To force immediate rendering, call
     * `render`.
     *
     * @event dom-change
     */
    return {
      /**
       * An array containing items determining how many instances of the template
       * to stamp and that that each template instance should bind to.
       */
      items: {
        type: Array
      },

      /**
       * The name of the variable to add to the binding scope for the array
       * element associated with a given template instance.
       */
      as: {
        type: String,
        value: 'item'
      },

      /**
       * The name of the variable to add to the binding scope with the index
       * of the instance in the sorted and filtered list of rendered items.
       * Note, for the index in the `this.items` array, use the value of the
       * `itemsIndexAs` property.
       */
      indexAs: {
        type: String,
        value: 'index'
      },

      /**
       * The name of the variable to add to the binding scope with the index
       * of the instance in the `this.items` array. Note, for the index of
       * this instance in the sorted and filtered list of rendered items,
       * use the value of the `indexAs` property.
       */
      itemsIndexAs: {
        type: String,
        value: 'itemsIndex'
      },

      /**
       * A function that should determine the sort order of the items.  This
       * property should either be provided as a string, indicating a method
       * name on the element's host, or else be an actual function.  The
       * function should match the sort function passed to `Array.sort`.
       * Using a sort function has no effect on the underlying `items` array.
       */
      sort: {
        type: Function,
        observer: '__sortChanged'
      },

      /**
       * A function that can be used to filter items out of the view.  This
       * property should either be provided as a string, indicating a method
       * name on the element's host, or else be an actual function.  The
       * function should match the sort function passed to `Array.filter`.
       * Using a filter function has no effect on the underlying `items` array.
       */
      filter: {
        type: Function,
        observer: '__filterChanged'
      },

      /**
       * When using a `filter` or `sort` function, the `observe` property
       * should be set to a space-separated list of the names of item
       * sub-fields that should trigger a re-sort or re-filter when changed.
       * These should generally be fields of `item` that the sort or filter
       * function depends on.
       */
      observe: {
        type: String,
        observer: '__observeChanged'
      },

      /**
       * When using a `filter` or `sort` function, the `delay` property
       * determines a debounce time in ms after a change to observed item
       * properties that must pass before the filter or sort is re-run.
       * This is useful in rate-limiting shuffling of the view when
       * item changes may be frequent.
       */
      delay: Number,

      /**
       * Count of currently rendered items after `filter` (if any) has been applied.
       * If "chunking mode" is enabled, `renderedItemCount` is updated each time a
       * set of template instances is rendered.
       *
       */
      renderedItemCount: {
        type: Number,
        notify: !_utils_settings_js__WEBPACK_IMPORTED_MODULE_9__["suppressTemplateNotifications"],
        readOnly: true
      },

      /**
       * When greater than zero, defines an initial count of template instances
       * to render after setting the `items` array, before the next paint, and
       * puts the `dom-repeat` into "chunking mode".  The remaining items (and
       * any future items as a result of pushing onto the array) will be created
       * and rendered incrementally at each animation frame thereof until all
       * instances have been rendered.
       */
      initialCount: {
        type: Number
      },

      /**
       * When `initialCount` is used, this property defines a frame rate (in
       * fps) to target by throttling the number of instances rendered each
       * frame to not exceed the budget for the target frame rate.  The
       * framerate is effectively the number of `requestAnimationFrame`s that
       * it tries to allow to actually fire in a given second. It does this
       * by measuring the time between `rAF`s and continuously adjusting the
       * number of items created each `rAF` to maintain the target framerate.
       * Setting this to a higher number allows lower latency and higher
       * throughput for event handlers and other tasks, but results in a
       * longer time for the remaining items to complete rendering.
       */
      targetFramerate: {
        type: Number,
        value: 20
      },
      _targetFrameTime: {
        type: Number,
        computed: '__computeFrameTime(targetFramerate)'
      },

      /**
       * When the global `suppressTemplateNotifications` setting is used, setting
       * `notifyDomChange: true` will enable firing `dom-change` events on this
       * element.
       */
      notifyDomChange: {
        type: Boolean
      },

      /**
       * When chunking is enabled via `initialCount` and the `items` array is
       * set to a new array, this flag controls whether the previously rendered
       * instances are reused or not.
       *
       * When `true`, any previously rendered template instances are updated in
       * place to their new item values synchronously in one shot, and then any
       * further items (if any) are chunked out.  When `false`, the list is
       * returned back to its `initialCount` (any instances over the initial
       * count are discarded) and the remainder of the list is chunked back in.
       * Set this to `true` to avoid re-creating the list and losing scroll
       * position, although note that when changing the list to completely
       * different data the render thread will be blocked until all existing
       * instances are updated to their new data.
       */
      reuseChunkedInstances: {
        type: Boolean
      }
    };
  }

  static get observers() {
    return ['__itemsChanged(items.*)'];
  }

  constructor() {
    super();
    this.__instances = [];
    this.__renderDebouncer = null;
    this.__itemsIdxToInstIdx = {};
    this.__chunkCount = null;
    this.__renderStartTime = null;
    this.__itemsArrayChanged = false;
    this.__shouldMeasureChunk = false;
    this.__shouldContinueChunking = false;
    this.__chunkingId = 0;
    this.__sortFn = null;
    this.__filterFn = null;
    this.__observePaths = null;
    /** @type {?function(new:TemplateInstanceBase, Object=)} */

    this.__ctor = null;
    this.__isDetached = true;
    this.template = null;
    /** @type {TemplateInfo} */

    this._templateInfo;
  }
  /**
   * @override
   * @return {void}
   */


  disconnectedCallback() {
    super.disconnectedCallback();
    this.__isDetached = true;

    for (let i = 0; i < this.__instances.length; i++) {
      this.__detachInstance(i);
    }
  }
  /**
   * @override
   * @return {void}
   */


  connectedCallback() {
    super.connectedCallback();

    if (!Object(_utils_hide_template_controls_js__WEBPACK_IMPORTED_MODULE_8__["hideElementsGlobally"])()) {
      this.style.display = 'none';
    } // only perform attachment if the element was previously detached.


    if (this.__isDetached) {
      this.__isDetached = false;
      let wrappedParent = Object(_utils_wrap_js__WEBPACK_IMPORTED_MODULE_7__["wrap"])(Object(_utils_wrap_js__WEBPACK_IMPORTED_MODULE_7__["wrap"])(this).parentNode);

      for (let i = 0; i < this.__instances.length; i++) {
        this.__attachInstance(i, wrappedParent);
      }
    }
  }

  __ensureTemplatized() {
    // Templatizing (generating the instance constructor) needs to wait
    // until ready, since won't have its template content handed back to
    // it until then
    if (!this.__ctor) {
      // When `removeNestedTemplates` is true, the "template" is the element
      // itself, which has been given a `_templateInfo` property
      const thisAsTemplate =
      /** @type {!HTMLTemplateElement} */

      /** @type {!HTMLElement} */
      this;
      let template = this.template = thisAsTemplate._templateInfo ? thisAsTemplate :
      /** @type {!HTMLTemplateElement} */
      this.querySelector('template');

      if (!template) {
        // Wait until childList changes and template should be there by then
        let observer = new MutationObserver(() => {
          if (this.querySelector('template')) {
            observer.disconnect();

            this.__render();
          } else {
            throw new Error('dom-repeat requires a <template> child');
          }
        });
        observer.observe(this, {
          childList: true
        });
        return false;
      } // Template instance props that should be excluded from forwarding


      let instanceProps = {};
      instanceProps[this.as] = true;
      instanceProps[this.indexAs] = true;
      instanceProps[this.itemsIndexAs] = true;
      this.__ctor = Object(_utils_templatize_js__WEBPACK_IMPORTED_MODULE_1__["templatize"])(template, this, {
        mutableData: this.mutableData,
        parentModel: true,
        instanceProps: instanceProps,

        /**
         * @this {DomRepeat}
         * @param {string} prop Property to set
         * @param {*} value Value to set property to
         */
        forwardHostProp: function (prop, value) {
          let i$ = this.__instances;

          for (let i = 0, inst; i < i$.length && (inst = i$[i]); i++) {
            inst.forwardHostProp(prop, value);
          }
        },

        /**
         * @this {DomRepeat}
         * @param {Object} inst Instance to notify
         * @param {string} prop Property to notify
         * @param {*} value Value to notify
         */
        notifyInstanceProp: function (inst, prop, value) {
          if (Object(_utils_path_js__WEBPACK_IMPORTED_MODULE_5__["matches"])(this.as, prop)) {
            let idx = inst[this.itemsIndexAs];

            if (prop == this.as) {
              this.items[idx] = value;
            }

            let path = Object(_utils_path_js__WEBPACK_IMPORTED_MODULE_5__["translate"])(this.as, `${JSCompiler_renameProperty('items', this)}.${idx}`, prop);
            this.notifyPath(path, value);
          }
        }
      });
    }

    return true;
  }

  __getMethodHost() {
    // Technically this should be the owner of the outermost template.
    // In shadow dom, this is always getRootNode().host, but we can
    // approximate this via cooperation with our dataHost always setting
    // `_methodHost` as long as there were bindings (or id's) on this
    // instance causing it to get a dataHost.
    return this.__dataHost._methodHost || this.__dataHost;
  }

  __functionFromPropertyValue(functionOrMethodName) {
    if (typeof functionOrMethodName === 'string') {
      let methodName = functionOrMethodName;

      let obj = this.__getMethodHost();

      return function () {
        return obj[methodName].apply(obj, arguments);
      };
    }

    return functionOrMethodName;
  }

  __sortChanged(sort) {
    this.__sortFn = this.__functionFromPropertyValue(sort);

    if (this.items) {
      this.__debounceRender(this.__render);
    }
  }

  __filterChanged(filter) {
    this.__filterFn = this.__functionFromPropertyValue(filter);

    if (this.items) {
      this.__debounceRender(this.__render);
    }
  }

  __computeFrameTime(rate) {
    return Math.ceil(1000 / rate);
  }

  __observeChanged() {
    this.__observePaths = this.observe && this.observe.replace('.*', '.').split(' ');
  }

  __handleObservedPaths(path) {
    // Handle cases where path changes should cause a re-sort/filter
    if (this.__sortFn || this.__filterFn) {
      if (!path) {
        // Always re-render if the item itself changed
        this.__debounceRender(this.__render, this.delay);
      } else if (this.__observePaths) {
        // Otherwise, re-render if the path changed matches an observed path
        let paths = this.__observePaths;

        for (let i = 0; i < paths.length; i++) {
          if (path.indexOf(paths[i]) === 0) {
            this.__debounceRender(this.__render, this.delay);
          }
        }
      }
    }
  }

  __itemsChanged(change) {
    if (this.items && !Array.isArray(this.items)) {
      console.warn('dom-repeat expected array for `items`, found', this.items);
    } // If path was to an item (e.g. 'items.3' or 'items.3.foo'), forward the
    // path to that instance synchronously (returns false for non-item paths)


    if (!this.__handleItemPath(change.path, change.value)) {
      // Otherwise, the array was reset ('items') or spliced ('items.splices'),
      // so queue a render.  Restart chunking when the items changed (for
      // backward compatibility), unless `reuseChunkedInstances` option is set
      if (change.path === 'items') {
        this.__itemsArrayChanged = true;
      }

      this.__debounceRender(this.__render);
    }
  }
  /**
   * @param {function(this:DomRepeat)} fn Function to debounce.
   * @param {number=} delay Delay in ms to debounce by.
   */


  __debounceRender(fn, delay = 0) {
    this.__renderDebouncer = _utils_debounce_js__WEBPACK_IMPORTED_MODULE_2__["Debouncer"].debounce(this.__renderDebouncer, delay > 0 ? _utils_async_js__WEBPACK_IMPORTED_MODULE_6__["timeOut"].after(delay) : _utils_async_js__WEBPACK_IMPORTED_MODULE_6__["microTask"], fn.bind(this));
    Object(_utils_flush_js__WEBPACK_IMPORTED_MODULE_3__["enqueueDebouncer"])(this.__renderDebouncer);
  }
  /**
   * Forces the element to render its content. Normally rendering is
   * asynchronous to a provoking change. This is done for efficiency so
   * that multiple changes trigger only a single render. The render method
   * should be called if, for example, template rendering is required to
   * validate application state.
   * @return {void}
   */


  render() {
    // Queue this repeater, then flush all in order
    this.__debounceRender(this.__render);

    Object(_utils_flush_js__WEBPACK_IMPORTED_MODULE_3__["flush"])();
  }

  __render() {
    if (!this.__ensureTemplatized()) {
      // No template found yet
      return;
    }

    let items = this.items || []; // Sort and filter the items into a mapping array from instance->item

    const isntIdxToItemsIdx = this.__sortAndFilterItems(items); // If we're chunking, increase the limit if there are new instances to
    // create and schedule the next chunk


    const limit = this.__calculateLimit(isntIdxToItemsIdx.length); // Create, update, and/or remove instances


    this.__updateInstances(items, limit, isntIdxToItemsIdx); // If we're chunking, schedule a rAF task to measure/continue chunking.     
    // Do this before any notifying events (renderedItemCount & dom-change)
    // since those could modify items and enqueue a new full render which will
    // pre-empt this measurement.


    if (this.initialCount && (this.__shouldMeasureChunk || this.__shouldContinueChunking)) {
      cancelAnimationFrame(this.__chunkingId);
      this.__chunkingId = requestAnimationFrame(() => this.__continueChunking());
    } // Set rendered item count


    this._setRenderedItemCount(this.__instances.length); // Notify users


    if (!_utils_settings_js__WEBPACK_IMPORTED_MODULE_9__["suppressTemplateNotifications"] || this.notifyDomChange) {
      this.dispatchEvent(new CustomEvent('dom-change', {
        bubbles: true,
        composed: true
      }));
    }
  }

  __sortAndFilterItems(items) {
    // Generate array maping the instance index to the items array index
    let isntIdxToItemsIdx = new Array(items.length);

    for (let i = 0; i < items.length; i++) {
      isntIdxToItemsIdx[i] = i;
    } // Apply user filter


    if (this.__filterFn) {
      isntIdxToItemsIdx = isntIdxToItemsIdx.filter((i, idx, array) => this.__filterFn(items[i], idx, array));
    } // Apply user sort


    if (this.__sortFn) {
      isntIdxToItemsIdx.sort((a, b) => this.__sortFn(items[a], items[b]));
    }

    return isntIdxToItemsIdx;
  }

  __calculateLimit(filteredItemCount) {
    let limit = filteredItemCount;
    const currentCount = this.__instances.length; // When chunking, we increase the limit from the currently rendered count
    // by the chunk count that is re-calculated after each rAF (with special
    // cases for reseting the limit to initialCount after changing items)

    if (this.initialCount) {
      let newCount;

      if (!this.__chunkCount || this.__itemsArrayChanged && !this.reuseChunkedInstances) {
        // Limit next render to the initial count
        limit = Math.min(filteredItemCount, this.initialCount); // Subtract off any existing instances to determine the number of
        // instances that will be created

        newCount = Math.max(limit - currentCount, 0); // Initialize the chunk size with how many items we're creating

        this.__chunkCount = newCount || 1;
      } else {
        // The number of new instances that will be created is based on the
        // existing instances, the new list size, and the chunk size
        newCount = Math.min(Math.max(filteredItemCount - currentCount, 0), this.__chunkCount); // Update the limit based on how many new items we're making, limited
        // buy the total size of the list

        limit = Math.min(currentCount + newCount, filteredItemCount);
      } // Record some state about chunking for use in `__continueChunking`


      this.__shouldMeasureChunk = newCount === this.__chunkCount;
      this.__shouldContinueChunking = limit < filteredItemCount;
      this.__renderStartTime = performance.now();
    }

    this.__itemsArrayChanged = false;
    return limit;
  }

  __continueChunking() {
    // Simple auto chunkSize throttling algorithm based on feedback loop:
    // measure actual time between frames and scale chunk count by ratio of
    // target/actual frame time.  Only modify chunk size if our measurement
    // reflects the cost of a creating a full chunk's worth of instances; this
    // avoids scaling up the chunk size if we e.g. quickly re-rendered instances
    // in place
    if (this.__shouldMeasureChunk) {
      const renderTime = performance.now() - this.__renderStartTime;

      const ratio = this._targetFrameTime / renderTime;
      this.__chunkCount = Math.round(this.__chunkCount * ratio) || 1;
    } // Enqueue a new render if we haven't reached the full size of the list


    if (this.__shouldContinueChunking) {
      this.__debounceRender(this.__render);
    }
  }

  __updateInstances(items, limit, isntIdxToItemsIdx) {
    // items->inst map kept for item path forwarding
    const itemsIdxToInstIdx = this.__itemsIdxToInstIdx = {};
    let instIdx; // Generate instances and assign items

    for (instIdx = 0; instIdx < limit; instIdx++) {
      let inst = this.__instances[instIdx];
      let itemIdx = isntIdxToItemsIdx[instIdx];
      let item = items[itemIdx];
      itemsIdxToInstIdx[itemIdx] = instIdx;

      if (inst) {
        inst._setPendingProperty(this.as, item);

        inst._setPendingProperty(this.indexAs, instIdx);

        inst._setPendingProperty(this.itemsIndexAs, itemIdx);

        inst._flushProperties();
      } else {
        this.__insertInstance(item, instIdx, itemIdx);
      }
    } // Remove any extra instances from previous state


    for (let i = this.__instances.length - 1; i >= instIdx; i--) {
      this.__detachAndRemoveInstance(i);
    }
  }

  __detachInstance(idx) {
    let inst = this.__instances[idx];
    const wrappedRoot = Object(_utils_wrap_js__WEBPACK_IMPORTED_MODULE_7__["wrap"])(inst.root);

    for (let i = 0; i < inst.children.length; i++) {
      let el = inst.children[i];
      wrappedRoot.appendChild(el);
    }

    return inst;
  }

  __attachInstance(idx, parent) {
    let inst = this.__instances[idx]; // Note, this is pre-wrapped as an optimization

    parent.insertBefore(inst.root, this);
  }

  __detachAndRemoveInstance(idx) {
    this.__detachInstance(idx);

    this.__instances.splice(idx, 1);
  }

  __stampInstance(item, instIdx, itemIdx) {
    let model = {};
    model[this.as] = item;
    model[this.indexAs] = instIdx;
    model[this.itemsIndexAs] = itemIdx;
    return new this.__ctor(model);
  }

  __insertInstance(item, instIdx, itemIdx) {
    const inst = this.__stampInstance(item, instIdx, itemIdx);

    let beforeRow = this.__instances[instIdx + 1];
    let beforeNode = beforeRow ? beforeRow.children[0] : this;
    Object(_utils_wrap_js__WEBPACK_IMPORTED_MODULE_7__["wrap"])(Object(_utils_wrap_js__WEBPACK_IMPORTED_MODULE_7__["wrap"])(this).parentNode).insertBefore(inst.root, beforeNode);
    this.__instances[instIdx] = inst;
    return inst;
  } // Implements extension point from Templatize mixin

  /**
   * Shows or hides the template instance top level child elements. For
   * text nodes, `textContent` is removed while "hidden" and replaced when
   * "shown."
   * @param {boolean} hidden Set to true to hide the children;
   * set to false to show them.
   * @return {void}
   * @protected
   */


  _showHideChildren(hidden) {
    for (let i = 0; i < this.__instances.length; i++) {
      this.__instances[i]._showHideChildren(hidden);
    }
  } // Called as a side effect of a host items.<key>.<path> path change,
  // responsible for notifying item.<path> changes to inst for key


  __handleItemPath(path, value) {
    let itemsPath = path.slice(6); // 'items.'.length == 6

    let dot = itemsPath.indexOf('.');
    let itemsIdx = dot < 0 ? itemsPath : itemsPath.substring(0, dot); // If path was index into array...

    if (itemsIdx == parseInt(itemsIdx, 10)) {
      let itemSubPath = dot < 0 ? '' : itemsPath.substring(dot + 1); // If the path is observed, it will trigger a full refresh

      this.__handleObservedPaths(itemSubPath); // Note, even if a rull refresh is triggered, always do the path
      // notification because unless mutableData is used for dom-repeat
      // and all elements in the instance subtree, a full refresh may
      // not trigger the proper update.


      let instIdx = this.__itemsIdxToInstIdx[itemsIdx];
      let inst = this.__instances[instIdx];

      if (inst) {
        let itemPath = this.as + (itemSubPath ? '.' + itemSubPath : ''); // This is effectively `notifyPath`, but avoids some of the overhead
        // of the public API

        inst._setPendingPropertyOrPath(itemPath, value, false, true);

        inst._flushProperties();
      }

      return true;
    }
  }
  /**
   * Returns the item associated with a given element stamped by
   * this `dom-repeat`.
   *
   * Note, to modify sub-properties of the item,
   * `modelForElement(el).set('item.<sub-prop>', value)`
   * should be used.
   *
   * @param {!HTMLElement} el Element for which to return the item.
   * @return {*} Item associated with the element.
   */


  itemForElement(el) {
    let instance = this.modelForElement(el);
    return instance && instance[this.as];
  }
  /**
   * Returns the inst index for a given element stamped by this `dom-repeat`.
   * If `sort` is provided, the index will reflect the sorted order (rather
   * than the original array order).
   *
   * @param {!HTMLElement} el Element for which to return the index.
   * @return {?number} Row index associated with the element (note this may
   *   not correspond to the array index if a user `sort` is applied).
   */


  indexForElement(el) {
    let instance = this.modelForElement(el);
    return instance && instance[this.indexAs];
  }
  /**
   * Returns the template "model" associated with a given element, which
   * serves as the binding scope for the template instance the element is
   * contained in. A template model
   * should be used to manipulate data associated with this template instance.
   *
   * Example:
   *
   *   let model = modelForElement(el);
   *   if (model.index < 10) {
   *     model.set('item.checked', true);
   *   }
   *
   * @param {!HTMLElement} el Element for which to return a template model.
   * @return {TemplateInstanceBase} Model representing the binding scope for
   *   the element.
   */


  modelForElement(el) {
    return Object(_utils_templatize_js__WEBPACK_IMPORTED_MODULE_1__["modelForElement"])(this.template, el);
  }

}
customElements.define(DomRepeat.is, DomRepeat);

/***/ }),

/***/ "./node_modules/@polymer/polymer/lib/mixins/element-mixin.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@polymer/polymer/lib/mixins/element-mixin.js ***!
  \*******************************************************************/
/*! exports provided: version, builtCSS, ElementMixin, updateStyles */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "version", function() { return version; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "builtCSS", function() { return builtCSS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ElementMixin", function() { return ElementMixin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "updateStyles", function() { return updateStyles; });
/* harmony import */ var _utils_boot_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/boot.js */ "./node_modules/@polymer/polymer/lib/utils/boot.js");
/* harmony import */ var _utils_settings_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/settings.js */ "./node_modules/@polymer/polymer/lib/utils/settings.js");
/* harmony import */ var _utils_mixin_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/mixin.js */ "./node_modules/@polymer/polymer/lib/utils/mixin.js");
/* harmony import */ var _utils_style_gather_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/style-gather.js */ "./node_modules/@polymer/polymer/lib/utils/style-gather.js");
/* harmony import */ var _utils_resolve_url_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/resolve-url.js */ "./node_modules/@polymer/polymer/lib/utils/resolve-url.js");
/* harmony import */ var _elements_dom_module_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../elements/dom-module.js */ "./node_modules/@polymer/polymer/lib/elements/dom-module.js");
/* harmony import */ var _property_effects_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./property-effects.js */ "./node_modules/@polymer/polymer/lib/mixins/property-effects.js");
/* harmony import */ var _properties_mixin_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./properties-mixin.js */ "./node_modules/@polymer/polymer/lib/mixins/properties-mixin.js");
/* harmony import */ var _utils_wrap_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../utils/wrap.js */ "./node_modules/@polymer/polymer/lib/utils/wrap.js");
/**
 * @fileoverview
 * @suppress {checkPrototypalTypes}
 * @license Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt The complete set of authors may be found
 * at http://polymer.github.io/AUTHORS.txt The complete set of contributors may
 * be found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by
 * Google as part of the polymer project is also subject to an additional IP
 * rights grant found at http://polymer.github.io/PATENTS.txt
 */









/**
 * Current Polymer version in Semver notation.
 * @type {string} Semver notation of the current version of Polymer.
 */

const version = '3.4.1';
const builtCSS = window.ShadyCSS && window.ShadyCSS['cssBuild'];
/**
 * Element class mixin that provides the core API for Polymer's meta-programming
 * features including template stamping, data-binding, attribute deserialization,
 * and property change observation.
 *
 * Subclassers may provide the following static getters to return metadata
 * used to configure Polymer's features for the class:
 *
 * - `static get is()`: When the template is provided via a `dom-module`,
 *   users should return the `dom-module` id from a static `is` getter.  If
 *   no template is needed or the template is provided directly via the
 *   `template` getter, there is no need to define `is` for the element.
 *
 * - `static get template()`: Users may provide the template directly (as
 *   opposed to via `dom-module`) by implementing a static `template` getter.
 *   The getter must return an `HTMLTemplateElement`.
 *
 * - `static get properties()`: Should return an object describing
 *   property-related metadata used by Polymer features (key: property name
 *   value: object containing property metadata). Valid keys in per-property
 *   metadata include:
 *   - `type` (String|Number|Object|Array|...): Used by
 *     `attributeChangedCallback` to determine how string-based attributes
 *     are deserialized to JavaScript property values.
 *   - `notify` (boolean): Causes a change in the property to fire a
 *     non-bubbling event called `<property>-changed`. Elements that have
 *     enabled two-way binding to the property use this event to observe changes.
 *   - `readOnly` (boolean): Creates a getter for the property, but no setter.
 *     To set a read-only property, use the private setter method
 *     `_setProperty(property, value)`.
 *   - `observer` (string): Observer method name that will be called when
 *     the property changes. The arguments of the method are
 *     `(value, previousValue)`.
 *   - `computed` (string): String describing method and dependent properties
 *     for computing the value of this property (e.g. `'computeFoo(bar, zot)'`).
 *     Computed properties are read-only by default and can only be changed
 *     via the return value of the computing method.
 *
 * - `static get observers()`: Array of strings describing multi-property
 *   observer methods and their dependent properties (e.g.
 *   `'observeABC(a, b, c)'`).
 *
 * The base class provides default implementations for the following standard
 * custom element lifecycle callbacks; users may override these, but should
 * call the super method to ensure
 * - `constructor`: Run when the element is created or upgraded
 * - `connectedCallback`: Run each time the element is connected to the
 *   document
 * - `disconnectedCallback`: Run each time the element is disconnected from
 *   the document
 * - `attributeChangedCallback`: Run each time an attribute in
 *   `observedAttributes` is set or removed (note: this element's default
 *   `observedAttributes` implementation will automatically return an array
 *   of dash-cased attributes based on `properties`)
 *
 * @mixinFunction
 * @polymer
 * @appliesMixin PropertyEffects
 * @appliesMixin PropertiesMixin
 * @property rootPath {string} Set to the value of `rootPath`,
 *   which defaults to the main document path
 * @property importPath {string} Set to the value of the class's static
 *   `importPath` property, which defaults to the path of this element's
 *   `dom-module` (when `is` is used), but can be overridden for other
 *   import strategies.
 * @summary Element class mixin that provides the core API for Polymer's
 * meta-programming features.
 * @template T
 * @param {function(new:T)} superClass Class to apply mixin to.
 * @return {function(new:T)} superClass with mixin applied.
 */

const ElementMixin = Object(_utils_mixin_js__WEBPACK_IMPORTED_MODULE_2__["dedupingMixin"])(base => {
  /**
   * @constructor
   * @implements {Polymer_PropertyEffects}
   * @implements {Polymer_PropertiesMixin}
   * @extends {HTMLElement}
   * @private
   */
  const polymerElementBase = Object(_properties_mixin_js__WEBPACK_IMPORTED_MODULE_7__["PropertiesMixin"])(Object(_property_effects_js__WEBPACK_IMPORTED_MODULE_6__["PropertyEffects"])(base));
  /**
   * Returns a list of properties with default values.
   * This list is created as an optimization since it is a subset of
   * the list returned from `_properties`.
   * This list is used in `_initializeProperties` to set property defaults.
   *
   * @param {PolymerElementConstructor} constructor Element class
   * @return {PolymerElementProperties} Flattened properties for this class
   *   that have default values
   * @private
   */

  function propertyDefaults(constructor) {
    if (!constructor.hasOwnProperty(JSCompiler_renameProperty('__propertyDefaults', constructor))) {
      constructor.__propertyDefaults = null;
      let props = constructor._properties;

      for (let p in props) {
        let info = props[p];

        if ('value' in info) {
          constructor.__propertyDefaults = constructor.__propertyDefaults || {};
          constructor.__propertyDefaults[p] = info;
        }
      }
    }

    return constructor.__propertyDefaults;
  }
  /**
   * Returns a memoized version of the `observers` array.
   * @param {PolymerElementConstructor} constructor Element class
   * @return {Array} Array containing own observers for the given class
   * @protected
   */


  function ownObservers(constructor) {
    if (!constructor.hasOwnProperty(JSCompiler_renameProperty('__ownObservers', constructor))) {
      constructor.__ownObservers = constructor.hasOwnProperty(JSCompiler_renameProperty('observers', constructor)) ?
      /** @type {PolymerElementConstructor} */
      constructor.observers : null;
    }

    return constructor.__ownObservers;
  }
  /**
   * Creates effects for a property.
   *
   * Note, once a property has been set to
   * `readOnly`, `computed`, `reflectToAttribute`, or `notify`
   * these values may not be changed. For example, a subclass cannot
   * alter these settings. However, additional `observers` may be added
   * by subclasses.
   *
   * The info object should contain property metadata as follows:
   *
   * * `type`: {function} type to which an attribute matching the property
   * is deserialized. Note the property is camel-cased from a dash-cased
   * attribute. For example, 'foo-bar' attribute is deserialized to a
   * property named 'fooBar'.
   *
   * * `readOnly`: {boolean} creates a readOnly property and
   * makes a private setter for the private of the form '_setFoo' for a
   * property 'foo',
   *
   * * `computed`: {string} creates a computed property. A computed property
   * is also automatically set to `readOnly: true`. The value is calculated
   * by running a method and arguments parsed from the given string. For
   * example 'compute(foo)' will compute a given property when the
   * 'foo' property changes by executing the 'compute' method. This method
   * must return the computed value.
   *
   * * `reflectToAttribute`: {boolean} If true, the property value is reflected
   * to an attribute of the same name. Note, the attribute is dash-cased
   * so a property named 'fooBar' is reflected as 'foo-bar'.
   *
   * * `notify`: {boolean} sends a non-bubbling notification event when
   * the property changes. For example, a property named 'foo' sends an
   * event named 'foo-changed' with `event.detail` set to the value of
   * the property.
   *
   * * observer: {string} name of a method that runs when the property
   * changes. The arguments of the method are (value, previousValue).
   *
   * Note: Users may want control over modifying property
   * effects via subclassing. For example, a user might want to make a
   * reflectToAttribute property not do so in a subclass. We've chosen to
   * disable this because it leads to additional complication.
   * For example, a readOnly effect generates a special setter. If a subclass
   * disables the effect, the setter would fail unexpectedly.
   * Based on feedback, we may want to try to make effects more malleable
   * and/or provide an advanced api for manipulating them.
   *
   * @param {!PolymerElement} proto Element class prototype to add accessors
   *   and effects to
   * @param {string} name Name of the property.
   * @param {Object} info Info object from which to create property effects.
   * Supported keys:
   * @param {Object} allProps Flattened map of all properties defined in this
   *   element (including inherited properties)
   * @return {void}
   * @private
   */


  function createPropertyFromConfig(proto, name, info, allProps) {
    // computed forces readOnly...
    if (info.computed) {
      info.readOnly = true;
    } // Note, since all computed properties are readOnly, this prevents
    // adding additional computed property effects (which leads to a confusing
    // setup where multiple triggers for setting a property)
    // While we do have `hasComputedEffect` this is set on the property's
    // dependencies rather than itself.


    if (info.computed) {
      if (proto._hasReadOnlyEffect(name)) {
        console.warn(`Cannot redefine computed property '${name}'.`);
      } else {
        proto._createComputedProperty(name, info.computed, allProps);
      }
    }

    if (info.readOnly && !proto._hasReadOnlyEffect(name)) {
      proto._createReadOnlyProperty(name, !info.computed);
    } else if (info.readOnly === false && proto._hasReadOnlyEffect(name)) {
      console.warn(`Cannot make readOnly property '${name}' non-readOnly.`);
    }

    if (info.reflectToAttribute && !proto._hasReflectEffect(name)) {
      proto._createReflectedProperty(name);
    } else if (info.reflectToAttribute === false && proto._hasReflectEffect(name)) {
      console.warn(`Cannot make reflected property '${name}' non-reflected.`);
    }

    if (info.notify && !proto._hasNotifyEffect(name)) {
      proto._createNotifyingProperty(name);
    } else if (info.notify === false && proto._hasNotifyEffect(name)) {
      console.warn(`Cannot make notify property '${name}' non-notify.`);
    } // always add observer


    if (info.observer) {
      proto._createPropertyObserver(name, info.observer, allProps[info.observer]);
    } // always create the mapping from attribute back to property for deserialization.


    proto._addPropertyToAttributeMap(name);
  }
  /**
   * Process all style elements in the element template. Styles with the
   * `include` attribute are processed such that any styles in
   * the associated "style modules" are included in the element template.
   * @param {PolymerElementConstructor} klass Element class
   * @param {!HTMLTemplateElement} template Template to process
   * @param {string} is Name of element
   * @param {string} baseURI Base URI for element
   * @private
   */


  function processElementStyles(klass, template, is, baseURI) {
    if (!builtCSS) {
      const templateStyles = template.content.querySelectorAll('style');
      const stylesWithImports = Object(_utils_style_gather_js__WEBPACK_IMPORTED_MODULE_3__["stylesFromTemplate"])(template); // insert styles from <link rel="import" type="css"> at the top of the template

      const linkedStyles = Object(_utils_style_gather_js__WEBPACK_IMPORTED_MODULE_3__["stylesFromModuleImports"])(is);
      const firstTemplateChild = template.content.firstElementChild;

      for (let idx = 0; idx < linkedStyles.length; idx++) {
        let s = linkedStyles[idx];
        s.textContent = klass._processStyleText(s.textContent, baseURI);
        template.content.insertBefore(s, firstTemplateChild);
      } // keep track of the last "concrete" style in the template we have encountered


      let templateStyleIndex = 0; // ensure all gathered styles are actually in this template.

      for (let i = 0; i < stylesWithImports.length; i++) {
        let s = stylesWithImports[i];
        let templateStyle = templateStyles[templateStyleIndex]; // if the style is not in this template, it's been "included" and
        // we put a clone of it in the template before the style that included it

        if (templateStyle !== s) {
          s = s.cloneNode(true);
          templateStyle.parentNode.insertBefore(s, templateStyle);
        } else {
          templateStyleIndex++;
        }

        s.textContent = klass._processStyleText(s.textContent, baseURI);
      }
    }

    if (window.ShadyCSS) {
      window.ShadyCSS.prepareTemplate(template, is);
    } // Support for `adoptedStylesheets` relies on using native Shadow DOM
    // and built CSS. Built CSS is required because runtime transformation of
    // `@apply` is not supported. This is because ShadyCSS relies on being able
    // to update a `style` element in the element template and this is
    // removed when using `adoptedStyleSheets`.
    // Note, it would be more efficient to allow style includes to become
    // separate stylesheets; however, because of `@apply` these are
    // potentially not shareable and sharing the ones that could be shared
    // would require some coordination. To keep it simple, all the includes
    // and styles are collapsed into a single shareable stylesheet.


    if (_utils_settings_js__WEBPACK_IMPORTED_MODULE_1__["useAdoptedStyleSheetsWithBuiltCSS"] && builtCSS && _utils_settings_js__WEBPACK_IMPORTED_MODULE_1__["supportsAdoptingStyleSheets"]) {
      // Remove styles in template and make a shareable stylesheet
      const styles = template.content.querySelectorAll('style');

      if (styles) {
        let css = '';
        Array.from(styles).forEach(s => {
          css += s.textContent;
          s.parentNode.removeChild(s);
        });
        klass._styleSheet = new CSSStyleSheet();

        klass._styleSheet.replaceSync(css);
      }
    }
  }
  /**
   * Look up template from dom-module for element
   *
   * @param {string} is Element name to look up
   * @return {?HTMLTemplateElement|undefined} Template found in dom module, or
   *   undefined if not found
   * @protected
   */


  function getTemplateFromDomModule(is) {
    let template = null; // Under strictTemplatePolicy in 3.x+, dom-module lookup is only allowed
    // when opted-in via allowTemplateFromDomModule

    if (is && (!_utils_settings_js__WEBPACK_IMPORTED_MODULE_1__["strictTemplatePolicy"] || _utils_settings_js__WEBPACK_IMPORTED_MODULE_1__["allowTemplateFromDomModule"])) {
      template =
      /** @type {?HTMLTemplateElement} */
      _elements_dom_module_js__WEBPACK_IMPORTED_MODULE_5__["DomModule"].import(is, 'template'); // Under strictTemplatePolicy, require any element with an `is`
      // specified to have a dom-module

      if (_utils_settings_js__WEBPACK_IMPORTED_MODULE_1__["strictTemplatePolicy"] && !template) {
        throw new Error(`strictTemplatePolicy: expecting dom-module or null template for ${is}`);
      }
    }

    return template;
  }
  /**
   * @polymer
   * @mixinClass
   * @unrestricted
   * @implements {Polymer_ElementMixin}
   * @extends {polymerElementBase}
   */


  class PolymerElement extends polymerElementBase {
    /**
     * Current Polymer version in Semver notation.
     * @type {string} Semver notation of the current version of Polymer.
     * @nocollapse
     */
    static get polymerElementVersion() {
      return version;
    }
    /**
     * Override of PropertiesMixin _finalizeClass to create observers and
     * find the template.
     * @return {void}
     * @protected
     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
     * @nocollapse
     */


    static _finalizeClass() {
      // TODO(https://github.com/google/closure-compiler/issues/3240):
      //     Change back to just super.methodCall()
      polymerElementBase._finalizeClass.call(this);

      const observers = ownObservers(this);

      if (observers) {
        this.createObservers(observers, this._properties);
      }

      this._prepareTemplate();
    }
    /** @nocollapse */


    static _prepareTemplate() {
      // note: create "working" template that is finalized at instance time
      let template =
      /** @type {PolymerElementConstructor} */
      this.template;

      if (template) {
        if (typeof template === 'string') {
          console.error('template getter must return HTMLTemplateElement');
          template = null;
        } else if (!_utils_settings_js__WEBPACK_IMPORTED_MODULE_1__["legacyOptimizations"]) {
          template = template.cloneNode(true);
        }
      }
      /** @override */


      this.prototype._template = template;
    }
    /**
     * Override of PropertiesChanged createProperties to create accessors
     * and property effects for all of the properties.
     * @param {!Object} props .
     * @return {void}
     * @protected
     * @nocollapse
     */


    static createProperties(props) {
      for (let p in props) {
        createPropertyFromConfig(
        /** @type {?} */
        this.prototype, p, props[p], props);
      }
    }
    /**
     * Creates observers for the given `observers` array.
     * Leverages `PropertyEffects` to create observers.
     * @param {Object} observers Array of observer descriptors for
     *   this class
     * @param {Object} dynamicFns Object containing keys for any properties
     *   that are functions and should trigger the effect when the function
     *   reference is changed
     * @return {void}
     * @protected
     * @nocollapse
     */


    static createObservers(observers, dynamicFns) {
      const proto = this.prototype;

      for (let i = 0; i < observers.length; i++) {
        proto._createMethodObserver(observers[i], dynamicFns);
      }
    }
    /**
     * Returns the template that will be stamped into this element's shadow root.
     *
     * If a `static get is()` getter is defined, the default implementation will
     * return the first `<template>` in a `dom-module` whose `id` matches this
     * element's `is` (note that a `_template` property on the class prototype
     * takes precedence over the `dom-module` template, to maintain legacy
     * element semantics; a subclass will subsequently fall back to its super
     * class template if neither a `prototype._template` or a `dom-module` for
     * the class's `is` was found).
     *
     * Users may override this getter to return an arbitrary template
     * (in which case the `is` getter is unnecessary). The template returned
     * must be an `HTMLTemplateElement`.
     *
     * Note that when subclassing, if the super class overrode the default
     * implementation and the subclass would like to provide an alternate
     * template via a `dom-module`, it should override this getter and
     * return `DomModule.import(this.is, 'template')`.
     *
     * If a subclass would like to modify the super class template, it should
     * clone it rather than modify it in place.  If the getter does expensive
     * work such as cloning/modifying a template, it should memoize the
     * template for maximum performance:
     *
     *   let memoizedTemplate;
     *   class MySubClass extends MySuperClass {
     *     static get template() {
     *       if (!memoizedTemplate) {
     *         memoizedTemplate = super.template.cloneNode(true);
     *         let subContent = document.createElement('div');
     *         subContent.textContent = 'This came from MySubClass';
     *         memoizedTemplate.content.appendChild(subContent);
     *       }
     *       return memoizedTemplate;
     *     }
     *   }
     *
     * @return {!HTMLTemplateElement|string} Template to be stamped
     * @nocollapse
     */


    static get template() {
      // Explanation of template-related properties:
      // - constructor.template (this getter): the template for the class.
      //     This can come from the prototype (for legacy elements), from a
      //     dom-module, or from the super class's template (or can be overridden
      //     altogether by the user)
      // - constructor._template: memoized version of constructor.template
      // - prototype._template: working template for the element, which will be
      //     parsed and modified in place. It is a cloned version of
      //     constructor.template, saved in _finalizeClass(). Note that before
      //     this getter is called, for legacy elements this could be from a
      //     _template field on the info object passed to Polymer(), a behavior,
      //     or set in registered(); once the static getter runs, a clone of it
      //     will overwrite it on the prototype as the working template.
      if (!this.hasOwnProperty(JSCompiler_renameProperty('_template', this))) {
        const protoTemplate = this.prototype.hasOwnProperty(JSCompiler_renameProperty('_template', this.prototype)) ? this.prototype._template : undefined;
        this._template = // If user has put template on prototype (e.g. in legacy via registered
        // callback or info object), prefer that first. Note that `null` is
        // used as a sentinel to indicate "no template" and can be used to
        // override a super template, whereas `undefined` is used as a
        // sentinel to mean "fall-back to default template lookup" via
        // dom-module and/or super.template.
        protoTemplate !== undefined ? protoTemplate : // Look in dom-module associated with this element's is
        this.hasOwnProperty(JSCompiler_renameProperty('is', this)) && getTemplateFromDomModule(
        /** @type {PolymerElementConstructor}*/
        this.is) || // Next look for superclass template (call the super impl this
        // way so that `this` points to the superclass)
        Object.getPrototypeOf(
        /** @type {PolymerElementConstructor}*/
        this.prototype).constructor.template;
      }

      return this._template;
    }
    /**
     * Set the template.
     *
     * @param {!HTMLTemplateElement|string} value Template to set.
     * @nocollapse
     */


    static set template(value) {
      this._template = value;
    }
    /**
     * Path matching the url from which the element was imported.
     *
     * This path is used to resolve url's in template style cssText.
     * The `importPath` property is also set on element instances and can be
     * used to create bindings relative to the import path.
     *
     * For elements defined in ES modules, users should implement
     * `static get importMeta() { return import.meta; }`, and the default
     * implementation of `importPath` will  return `import.meta.url`'s path.
     * For elements defined in HTML imports, this getter will return the path
     * to the document containing a `dom-module` element matching this
     * element's static `is` property.
     *
     * Note, this path should contain a trailing `/`.
     *
     * @return {string} The import path for this element class
     * @suppress {missingProperties}
     * @nocollapse
     */


    static get importPath() {
      if (!this.hasOwnProperty(JSCompiler_renameProperty('_importPath', this))) {
        const meta = this.importMeta;

        if (meta) {
          this._importPath = Object(_utils_resolve_url_js__WEBPACK_IMPORTED_MODULE_4__["pathFromUrl"])(meta.url);
        } else {
          const module = _elements_dom_module_js__WEBPACK_IMPORTED_MODULE_5__["DomModule"].import(
          /** @type {PolymerElementConstructor} */
          this.is);
          this._importPath = module && module.assetpath || Object.getPrototypeOf(
          /** @type {PolymerElementConstructor}*/
          this.prototype).constructor.importPath;
        }
      }

      return this._importPath;
    }

    constructor() {
      super();
      /** @type {HTMLTemplateElement} */

      this._template;
      /** @type {string} */

      this._importPath;
      /** @type {string} */

      this.rootPath;
      /** @type {string} */

      this.importPath;
      /** @type {StampedTemplate | HTMLElement | ShadowRoot} */

      this.root;
      /** @type {!Object<string, !Element>} */

      this.$;
    }
    /**
     * Overrides the default `PropertyAccessors` to ensure class
     * metaprogramming related to property accessors and effects has
     * completed (calls `finalize`).
     *
     * It also initializes any property defaults provided via `value` in
     * `properties` metadata.
     *
     * @return {void}
     * @override
     * @suppress {invalidCasts,missingProperties} go/missingfnprops
     */


    _initializeProperties() {
      this.constructor.finalize(); // note: finalize template when we have access to `localName` to
      // avoid dependence on `is` for polyfilling styling.

      this.constructor._finalizeTemplate(
      /** @type {!HTMLElement} */
      this.localName);

      super._initializeProperties(); // set path defaults


      this.rootPath = _utils_settings_js__WEBPACK_IMPORTED_MODULE_1__["rootPath"];
      this.importPath = this.constructor.importPath; // apply property defaults...

      let p$ = propertyDefaults(this.constructor);

      if (!p$) {
        return;
      }

      for (let p in p$) {
        let info = p$[p];

        if (this._canApplyPropertyDefault(p)) {
          let value = typeof info.value == 'function' ? info.value.call(this) : info.value; // Set via `_setProperty` if there is an accessor, to enable
          // initializing readOnly property defaults

          if (this._hasAccessor(p)) {
            this._setPendingProperty(p, value, true);
          } else {
            this[p] = value;
          }
        }
      }
    }
    /**
     * Determines if a property dfeault can be applied. For example, this
     * prevents a default from being applied when a property that has no
     * accessor is overridden by its host before upgrade (e.g. via a binding).
     * @override
     * @param {string} property Name of the property
     * @return {boolean} Returns true if the property default can be applied.
     */


    _canApplyPropertyDefault(property) {
      return !this.hasOwnProperty(property);
    }
    /**
     * Gather style text for a style element in the template.
     *
     * @param {string} cssText Text containing styling to process
     * @param {string} baseURI Base URI to rebase CSS paths against
     * @return {string} The processed CSS text
     * @protected
     * @nocollapse
     */


    static _processStyleText(cssText, baseURI) {
      return Object(_utils_resolve_url_js__WEBPACK_IMPORTED_MODULE_4__["resolveCss"])(cssText, baseURI);
    }
    /**
    * Configures an element `proto` to function with a given `template`.
    * The element name `is` and extends `ext` must be specified for ShadyCSS
    * style scoping.
    *
    * @param {string} is Tag name (or type extension name) for this element
    * @return {void}
    * @protected
    * @nocollapse
    */


    static _finalizeTemplate(is) {
      /** @const {HTMLTemplateElement} */
      const template = this.prototype._template;

      if (template && !template.__polymerFinalized) {
        template.__polymerFinalized = true;
        const importPath = this.importPath;
        const baseURI = importPath ? Object(_utils_resolve_url_js__WEBPACK_IMPORTED_MODULE_4__["resolveUrl"])(importPath) : ''; // e.g. support `include="module-name"`, and ShadyCSS

        processElementStyles(this, template, is, baseURI);

        this.prototype._bindTemplate(template);
      }
    }
    /**
     * Provides a default implementation of the standard Custom Elements
     * `connectedCallback`.
     *
     * The default implementation enables the property effects system and
     * flushes any pending properties, and updates shimmed CSS properties
     * when using the ShadyCSS scoping/custom properties polyfill.
     *
     * @override
     * @suppress {missingProperties, invalidCasts} Super may or may not
     *     implement the callback
     * @return {void}
     */


    connectedCallback() {
      if (window.ShadyCSS && this._template) {
        window.ShadyCSS.styleElement(
        /** @type {!HTMLElement} */
        this);
      }

      super.connectedCallback();
    }
    /**
     * Stamps the element template.
     *
     * @return {void}
     * @override
     */


    ready() {
      if (this._template) {
        this.root = this._stampTemplate(this._template);
        this.$ = this.root.$;
      }

      super.ready();
    }
    /**
     * Implements `PropertyEffects`'s `_readyClients` call. Attaches
     * element dom by calling `_attachDom` with the dom stamped from the
     * element's template via `_stampTemplate`. Note that this allows
     * client dom to be attached to the element prior to any observers
     * running.
     *
     * @return {void}
     * @override
     */


    _readyClients() {
      if (this._template) {
        this.root = this._attachDom(
        /** @type {StampedTemplate} */
        this.root);
      } // The super._readyClients here sets the clients initialized flag.
      // We must wait to do this until after client dom is created/attached
      // so that this flag can be checked to prevent notifications fired
      // during this process from being handled before clients are ready.


      super._readyClients();
    }
    /**
     * Attaches an element's stamped dom to itself. By default,
     * this method creates a `shadowRoot` and adds the dom to it.
     * However, this method may be overridden to allow an element
     * to put its dom in another location.
     *
     * @override
     * @throws {Error}
     * @suppress {missingReturn}
     * @param {StampedTemplate} dom to attach to the element.
     * @return {ShadowRoot} node to which the dom has been attached.
     */


    _attachDom(dom) {
      const n = Object(_utils_wrap_js__WEBPACK_IMPORTED_MODULE_8__["wrap"])(this);

      if (n.attachShadow) {
        if (dom) {
          if (!n.shadowRoot) {
            n.attachShadow({
              mode: 'open',
              shadyUpgradeFragment: dom
            });
            n.shadowRoot.appendChild(dom); // When `adoptedStyleSheets` is supported a stylesheet is made
            // available on the element constructor.

            if (this.constructor._styleSheet) {
              n.shadowRoot.adoptedStyleSheets = [this.constructor._styleSheet];
            }
          }

          if (_utils_settings_js__WEBPACK_IMPORTED_MODULE_1__["syncInitialRender"] && window.ShadyDOM) {
            window.ShadyDOM.flushInitial(n.shadowRoot);
          }

          return n.shadowRoot;
        }

        return null;
      } else {
        throw new Error('ShadowDOM not available. ' + // TODO(sorvell): move to compile-time conditional when supported
        'PolymerElement can create dom as children instead of in ' + 'ShadowDOM by setting `this.root = this;\` before \`ready\`.');
      }
    }
    /**
     * When using the ShadyCSS scoping and custom property shim, causes all
     * shimmed styles in this element (and its subtree) to be updated
     * based on current custom property values.
     *
     * The optional parameter overrides inline custom property styles with an
     * object of properties where the keys are CSS properties, and the values
     * are strings.
     *
     * Example: `this.updateStyles({'--color': 'blue'})`
     *
     * These properties are retained unless a value of `null` is set.
     *
     * Note: This function does not support updating CSS mixins.
     * You can not dynamically change the value of an `@apply`.
     *
     * @override
     * @param {Object=} properties Bag of custom property key/values to
     *   apply to this element.
     * @return {void}
     * @suppress {invalidCasts}
     */


    updateStyles(properties) {
      if (window.ShadyCSS) {
        window.ShadyCSS.styleSubtree(
        /** @type {!HTMLElement} */
        this, properties);
      }
    }
    /**
     * Rewrites a given URL relative to a base URL. The base URL defaults to
     * the original location of the document containing the `dom-module` for
     * this element. This method will return the same URL before and after
     * bundling.
     *
     * Note that this function performs no resolution for URLs that start
     * with `/` (absolute URLs) or `#` (hash identifiers).  For general purpose
     * URL resolution, use `window.URL`.
     *
     * @override
     * @param {string} url URL to resolve.
     * @param {string=} base Optional base URL to resolve against, defaults
     * to the element's `importPath`
     * @return {string} Rewritten URL relative to base
     */


    resolveUrl(url, base) {
      if (!base && this.importPath) {
        base = Object(_utils_resolve_url_js__WEBPACK_IMPORTED_MODULE_4__["resolveUrl"])(this.importPath);
      }

      return Object(_utils_resolve_url_js__WEBPACK_IMPORTED_MODULE_4__["resolveUrl"])(url, base);
    }
    /**
     * Overrides `PropertyEffects` to add map of dynamic functions on
     * template info, for consumption by `PropertyEffects` template binding
     * code. This map determines which method templates should have accessors
     * created for them.
     *
     * @param {!HTMLTemplateElement} template Template
     * @param {!TemplateInfo} templateInfo Template metadata for current template
     * @param {!NodeInfo} nodeInfo Node metadata for current template.
     * @return {boolean} .
     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
     * @nocollapse
     */


    static _parseTemplateContent(template, templateInfo, nodeInfo) {
      templateInfo.dynamicFns = templateInfo.dynamicFns || this._properties; // TODO(https://github.com/google/closure-compiler/issues/3240):
      //     Change back to just super.methodCall()

      return polymerElementBase._parseTemplateContent.call(this, template, templateInfo, nodeInfo);
    }
    /**
     * Overrides `PropertyEffects` to warn on use of undeclared properties in
     * template.
     *
     * @param {Object} templateInfo Template metadata to add effect to
     * @param {string} prop Property that should trigger the effect
     * @param {Object=} effect Effect metadata object
     * @return {void}
     * @protected
     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
     * @nocollapse
     */


    static _addTemplatePropertyEffect(templateInfo, prop, effect) {
      // Warn if properties are used in template without being declared.
      // Properties must be listed in `properties` to be included in
      // `observedAttributes` since CE V1 reads that at registration time, and
      // since we want to keep template parsing lazy, we can't automatically
      // add undeclared properties used in templates to `observedAttributes`.
      // The warning is only enabled in `legacyOptimizations` mode, since
      // we don't want to spam existing users who might have adopted the
      // shorthand when attribute deserialization is not important.
      if (_utils_settings_js__WEBPACK_IMPORTED_MODULE_1__["legacyWarnings"] && !(prop in this._properties) && // Methods used in templates with no dependencies (or only literal
      // dependencies) become accessors with template effects; ignore these
      !(effect.info.part.signature && effect.info.part.signature.static) && // Warnings for bindings added to nested templates are handled by
      // templatizer so ignore both the host-to-template bindings
      // (`hostProp`) and TemplateInstance-to-child bindings
      // (`nestedTemplate`)
      !effect.info.part.hostProp && !templateInfo.nestedTemplate) {
        console.warn(`Property '${prop}' used in template but not declared in 'properties'; ` + `attribute will not be observed.`);
      } // TODO(https://github.com/google/closure-compiler/issues/3240):
      //     Change back to just super.methodCall()


      return polymerElementBase._addTemplatePropertyEffect.call(this, templateInfo, prop, effect);
    }

  }

  return PolymerElement;
});
/**
 * When using the ShadyCSS scoping and custom property shim, causes all
 * shimmed `styles` (via `custom-style`) in the document (and its subtree)
 * to be updated based on current custom property values.
 *
 * The optional parameter overrides inline custom property styles with an
 * object of properties where the keys are CSS properties, and the values
 * are strings.
 *
 * Example: `updateStyles({'--color': 'blue'})`
 *
 * These properties are retained unless a value of `null` is set.
 *
 * @param {Object=} props Bag of custom property key/values to
 *   apply to the document.
 * @return {void}
 */

const updateStyles = function (props) {
  if (window.ShadyCSS) {
    window.ShadyCSS.styleDocument(props);
  }
};

/***/ }),

/***/ "./node_modules/@polymer/polymer/lib/mixins/gesture-event-listeners.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@polymer/polymer/lib/mixins/gesture-event-listeners.js ***!
  \*****************************************************************************/
/*! exports provided: GestureEventListeners */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GestureEventListeners", function() { return GestureEventListeners; });
/* harmony import */ var _utils_boot_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/boot.js */ "./node_modules/@polymer/polymer/lib/utils/boot.js");
/* harmony import */ var _utils_mixin_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/mixin.js */ "./node_modules/@polymer/polymer/lib/utils/mixin.js");
/* harmony import */ var _utils_gestures_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/gestures.js */ "./node_modules/@polymer/polymer/lib/utils/gestures.js");
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/



/**
 * Element class mixin that provides API for adding Polymer's cross-platform
 * gesture events to nodes.
 *
 * The API is designed to be compatible with override points implemented
 * in `TemplateStamp` such that declarative event listeners in
 * templates will support gesture events when this mixin is applied along with
 * `TemplateStamp`.
 *
 * @mixinFunction
 * @polymer
 * @summary Element class mixin that provides API for adding Polymer's
 *   cross-platform gesture events to nodes
 * @template T
 * @param {function(new:T)} superClass Class to apply mixin to.
 * @return {function(new:T)} superClass with mixin applied.
 */

const GestureEventListeners = Object(_utils_mixin_js__WEBPACK_IMPORTED_MODULE_1__["dedupingMixin"])(superClass => {
  /**
   * @polymer
   * @mixinClass
   * @implements {Polymer_GestureEventListeners}
   */
  class GestureEventListeners extends superClass {
    /**
     * Add the event listener to the node if it is a gestures event.
     *
     * @param {!EventTarget} node Node to add event listener to
     * @param {string} eventName Name of event
     * @param {function(!Event):void} handler Listener function to add
     * @return {void}
     * @override
     */
    _addEventListenerToNode(node, eventName, handler) {
      if (!Object(_utils_gestures_js__WEBPACK_IMPORTED_MODULE_2__["addListener"])(node, eventName, handler)) {
        super._addEventListenerToNode(node, eventName, handler);
      }
    }
    /**
     * Remove the event listener to the node if it is a gestures event.
     *
     * @param {!EventTarget} node Node to remove event listener from
     * @param {string} eventName Name of event
     * @param {function(!Event):void} handler Listener function to remove
     * @return {void}
     * @override
     */


    _removeEventListenerFromNode(node, eventName, handler) {
      if (!Object(_utils_gestures_js__WEBPACK_IMPORTED_MODULE_2__["removeListener"])(node, eventName, handler)) {
        super._removeEventListenerFromNode(node, eventName, handler);
      }
    }

  }

  return GestureEventListeners;
});

/***/ }),

/***/ "./node_modules/@polymer/polymer/lib/mixins/mutable-data.js":
/*!******************************************************************!*\
  !*** ./node_modules/@polymer/polymer/lib/mixins/mutable-data.js ***!
  \******************************************************************/
/*! exports provided: MutableData, OptionalMutableData */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MutableData", function() { return MutableData; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OptionalMutableData", function() { return OptionalMutableData; });
/* harmony import */ var _utils_mixin_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/mixin.js */ "./node_modules/@polymer/polymer/lib/utils/mixin.js");
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
 // Common implementation for mixin & behavior

function mutablePropertyChange(inst, property, value, old, mutableData) {
  let isObject;

  if (mutableData) {
    isObject = typeof value === 'object' && value !== null; // Pull `old` for Objects from temp cache, but treat `null` as a primitive

    if (isObject) {
      old = inst.__dataTemp[property];
    }
  } // Strict equality check, but return false for NaN===NaN


  let shouldChange = old !== value && (old === old || value === value); // Objects are stored in temporary cache (cleared at end of
  // turn), which is used for dirty-checking

  if (isObject && shouldChange) {
    inst.__dataTemp[property] = value;
  }

  return shouldChange;
}
/**
 * Element class mixin to skip strict dirty-checking for objects and arrays
 * (always consider them to be "dirty"), for use on elements utilizing
 * `PropertyEffects`
 *
 * By default, `PropertyEffects` performs strict dirty checking on
 * objects, which means that any deep modifications to an object or array will
 * not be propagated unless "immutable" data patterns are used (i.e. all object
 * references from the root to the mutation were changed).
 *
 * Polymer also provides a proprietary data mutation and path notification API
 * (e.g. `notifyPath`, `set`, and array mutation API's) that allow efficient
 * mutation and notification of deep changes in an object graph to all elements
 * bound to the same object graph.
 *
 * In cases where neither immutable patterns nor the data mutation API can be
 * used, applying this mixin will cause Polymer to skip dirty checking for
 * objects and arrays (always consider them to be "dirty").  This allows a
 * user to make a deep modification to a bound object graph, and then either
 * simply re-set the object (e.g. `this.items = this.items`) or call `notifyPath`
 * (e.g. `this.notifyPath('items')`) to update the tree.  Note that all
 * elements that wish to be updated based on deep mutations must apply this
 * mixin or otherwise skip strict dirty checking for objects/arrays.
 * Specifically, any elements in the binding tree between the source of a
 * mutation and the consumption of it must apply this mixin or enable the
 * `OptionalMutableData` mixin.
 *
 * In order to make the dirty check strategy configurable, see
 * `OptionalMutableData`.
 *
 * Note, the performance characteristics of propagating large object graphs
 * will be worse as opposed to using strict dirty checking with immutable
 * patterns or Polymer's path notification API.
 *
 * @mixinFunction
 * @polymer
 * @summary Element class mixin to skip strict dirty-checking for objects
 *   and arrays
 * @template T
 * @param {function(new:T)} superClass Class to apply mixin to.
 * @return {function(new:T)} superClass with mixin applied.
 */


const MutableData = Object(_utils_mixin_js__WEBPACK_IMPORTED_MODULE_0__["dedupingMixin"])(superClass => {
  /**
   * @polymer
   * @mixinClass
   * @implements {Polymer_MutableData}
   */
  class MutableData extends superClass {
    /**
     * Overrides `PropertyEffects` to provide option for skipping
     * strict equality checking for Objects and Arrays.
     *
     * This method pulls the value to dirty check against from the `__dataTemp`
     * cache (rather than the normal `__data` cache) for Objects.  Since the temp
     * cache is cleared at the end of a turn, this implementation allows
     * side-effects of deep object changes to be processed by re-setting the
     * same object (using the temp cache as an in-turn backstop to prevent
     * cycles due to 2-way notification).
     *
     * @param {string} property Property name
     * @param {*} value New property value
     * @param {*} old Previous property value
     * @return {boolean} Whether the property should be considered a change
     * @protected
     */
    _shouldPropertyChange(property, value, old) {
      return mutablePropertyChange(this, property, value, old, true);
    }

  }

  return MutableData;
});
/**
 * Element class mixin to add the optional ability to skip strict
 * dirty-checking for objects and arrays (always consider them to be
 * "dirty") by setting a `mutable-data` attribute on an element instance.
 *
 * By default, `PropertyEffects` performs strict dirty checking on
 * objects, which means that any deep modifications to an object or array will
 * not be propagated unless "immutable" data patterns are used (i.e. all object
 * references from the root to the mutation were changed).
 *
 * Polymer also provides a proprietary data mutation and path notification API
 * (e.g. `notifyPath`, `set`, and array mutation API's) that allow efficient
 * mutation and notification of deep changes in an object graph to all elements
 * bound to the same object graph.
 *
 * In cases where neither immutable patterns nor the data mutation API can be
 * used, applying this mixin will allow Polymer to skip dirty checking for
 * objects and arrays (always consider them to be "dirty").  This allows a
 * user to make a deep modification to a bound object graph, and then either
 * simply re-set the object (e.g. `this.items = this.items`) or call `notifyPath`
 * (e.g. `this.notifyPath('items')`) to update the tree.  Note that all
 * elements that wish to be updated based on deep mutations must apply this
 * mixin or otherwise skip strict dirty checking for objects/arrays.
 * Specifically, any elements in the binding tree between the source of a
 * mutation and the consumption of it must enable this mixin or apply the
 * `MutableData` mixin.
 *
 * While this mixin adds the ability to forgo Object/Array dirty checking,
 * the `mutableData` flag defaults to false and must be set on the instance.
 *
 * Note, the performance characteristics of propagating large object graphs
 * will be worse by relying on `mutableData: true` as opposed to using
 * strict dirty checking with immutable patterns or Polymer's path notification
 * API.
 *
 * @mixinFunction
 * @polymer
 * @summary Element class mixin to optionally skip strict dirty-checking
 *   for objects and arrays
 */

const OptionalMutableData = Object(_utils_mixin_js__WEBPACK_IMPORTED_MODULE_0__["dedupingMixin"])(superClass => {
  /**
   * @mixinClass
   * @polymer
   * @implements {Polymer_OptionalMutableData}
   */
  class OptionalMutableData extends superClass {
    /** @nocollapse */
    static get properties() {
      return {
        /**
         * Instance-level flag for configuring the dirty-checking strategy
         * for this element.  When true, Objects and Arrays will skip dirty
         * checking, otherwise strict equality checking will be used.
         */
        mutableData: Boolean
      };
    }
    /**
     * Overrides `PropertyEffects` to provide option for skipping
     * strict equality checking for Objects and Arrays.
     *
     * When `this.mutableData` is true on this instance, this method
     * pulls the value to dirty check against from the `__dataTemp` cache
     * (rather than the normal `__data` cache) for Objects.  Since the temp
     * cache is cleared at the end of a turn, this implementation allows
     * side-effects of deep object changes to be processed by re-setting the
     * same object (using the temp cache as an in-turn backstop to prevent
     * cycles due to 2-way notification).
     *
     * @param {string} property Property name
     * @param {*} value New property value
     * @param {*} old Previous property value
     * @return {boolean} Whether the property should be considered a change
     * @protected
     */


    _shouldPropertyChange(property, value, old) {
      return mutablePropertyChange(this, property, value, old, this.mutableData);
    }

  }

  return OptionalMutableData;
}); // Export for use by legacy behavior

MutableData._mutablePropertyChange = mutablePropertyChange;

/***/ }),

/***/ "./node_modules/@polymer/polymer/lib/mixins/properties-changed.js":
/*!************************************************************************!*\
  !*** ./node_modules/@polymer/polymer/lib/mixins/properties-changed.js ***!
  \************************************************************************/
/*! exports provided: PropertiesChanged */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PropertiesChanged", function() { return PropertiesChanged; });
/* harmony import */ var _utils_boot_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/boot.js */ "./node_modules/@polymer/polymer/lib/utils/boot.js");
/* harmony import */ var _utils_mixin_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/mixin.js */ "./node_modules/@polymer/polymer/lib/utils/mixin.js");
/* harmony import */ var _utils_async_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/async.js */ "./node_modules/@polymer/polymer/lib/utils/async.js");
/* harmony import */ var _utils_wrap_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/wrap.js */ "./node_modules/@polymer/polymer/lib/utils/wrap.js");
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/




/** @const {!AsyncInterface} */

const microtask = _utils_async_js__WEBPACK_IMPORTED_MODULE_2__["microTask"];
/**
 * Element class mixin that provides basic meta-programming for creating one
 * or more property accessors (getter/setter pair) that enqueue an async
 * (batched) `_propertiesChanged` callback.
 *
 * For basic usage of this mixin, call `MyClass.createProperties(props)`
 * once at class definition time to create property accessors for properties
 * named in props, implement `_propertiesChanged` to react as desired to
 * property changes, and implement `static get observedAttributes()` and
 * include lowercase versions of any property names that should be set from
 * attributes. Last, call `this._enableProperties()` in the element's
 * `connectedCallback` to enable the accessors.
 *
 * @mixinFunction
 * @polymer
 * @summary Element class mixin for reacting to property changes from
 *   generated property accessors.
 * @template T
 * @param {function(new:T)} superClass Class to apply mixin to.
 * @return {function(new:T)} superClass with mixin applied.
 */

const PropertiesChanged = Object(_utils_mixin_js__WEBPACK_IMPORTED_MODULE_1__["dedupingMixin"])(
/**
 * @template T
 * @param {function(new:T)} superClass Class to apply mixin to.
 * @return {function(new:T)} superClass with mixin applied.
 */
superClass => {
  /**
   * @polymer
   * @mixinClass
   * @implements {Polymer_PropertiesChanged}
   * @unrestricted
   */
  class PropertiesChanged extends superClass {
    /**
     * Creates property accessors for the given property names.
     * @param {!Object} props Object whose keys are names of accessors.
     * @return {void}
     * @protected
     * @nocollapse
     */
    static createProperties(props) {
      const proto = this.prototype;

      for (let prop in props) {
        // don't stomp an existing accessor
        if (!(prop in proto)) {
          proto._createPropertyAccessor(prop);
        }
      }
    }
    /**
     * Returns an attribute name that corresponds to the given property.
     * The attribute name is the lowercased property name. Override to
     * customize this mapping.
     * @param {string} property Property to convert
     * @return {string} Attribute name corresponding to the given property.
     *
     * @protected
     * @nocollapse
     */


    static attributeNameForProperty(property) {
      return property.toLowerCase();
    }
    /**
     * Override point to provide a type to which to deserialize a value to
     * a given property.
     * @param {string} name Name of property
     *
     * @protected
     * @nocollapse
     */


    static typeForProperty(name) {} //eslint-disable-line no-unused-vars

    /**
     * Creates a setter/getter pair for the named property with its own
     * local storage.  The getter returns the value in the local storage,
     * and the setter calls `_setProperty`, which updates the local storage
     * for the property and enqueues a `_propertiesChanged` callback.
     *
     * This method may be called on a prototype or an instance.  Calling
     * this method may overwrite a property value that already exists on
     * the prototype/instance by creating the accessor.
     *
     * @param {string} property Name of the property
     * @param {boolean=} readOnly When true, no setter is created; the
     *   protected `_setProperty` function must be used to set the property
     * @return {void}
     * @protected
     * @override
     */


    _createPropertyAccessor(property, readOnly) {
      this._addPropertyToAttributeMap(property);

      if (!this.hasOwnProperty(JSCompiler_renameProperty('__dataHasAccessor', this))) {
        this.__dataHasAccessor = Object.assign({}, this.__dataHasAccessor);
      }

      if (!this.__dataHasAccessor[property]) {
        this.__dataHasAccessor[property] = true;

        this._definePropertyAccessor(property, readOnly);
      }
    }
    /**
     * Adds the given `property` to a map matching attribute names
     * to property names, using `attributeNameForProperty`. This map is
     * used when deserializing attribute values to properties.
     *
     * @param {string} property Name of the property
     * @override
     */


    _addPropertyToAttributeMap(property) {
      if (!this.hasOwnProperty(JSCompiler_renameProperty('__dataAttributes', this))) {
        this.__dataAttributes = Object.assign({}, this.__dataAttributes);
      } // This check is technically not correct; it's an optimization that
      // assumes that if a _property_ name is already in the map (note this is
      // an attr->property map), the property mapped directly to the attribute
      // and it has already been mapped.  This would fail if
      // `attributeNameForProperty` were overridden such that this was not the
      // case.


      let attr = this.__dataAttributes[property];

      if (!attr) {
        attr = this.constructor.attributeNameForProperty(property);
        this.__dataAttributes[attr] = property;
      }

      return attr;
    }
    /**
     * Defines a property accessor for the given property.
     * @param {string} property Name of the property
     * @param {boolean=} readOnly When true, no setter is created
     * @return {void}
     * @override
     */


    _definePropertyAccessor(property, readOnly) {
      Object.defineProperty(this, property, {
        /* eslint-disable valid-jsdoc */

        /** @this {PropertiesChanged} */
        get() {
          // Inline for perf instead of using `_getProperty`
          return this.__data[property];
        },

        /** @this {PropertiesChanged} */
        set: readOnly ? function () {} : function (value) {
          // Inline for perf instead of using `_setProperty`
          if (this._setPendingProperty(property, value, true)) {
            this._invalidateProperties();
          }
        }
        /* eslint-enable */

      });
    }

    constructor() {
      super();
      /** @type {boolean} */

      this.__dataEnabled = false;
      this.__dataReady = false;
      this.__dataInvalid = false;
      this.__data = {};
      this.__dataPending = null;
      this.__dataOld = null;
      this.__dataInstanceProps = null;
      /** @type {number} */
      // NOTE: used to track re-entrant calls to `_flushProperties`

      this.__dataCounter = 0;
      this.__serializing = false;

      this._initializeProperties();
    }
    /**
     * Lifecycle callback called when properties are enabled via
     * `_enableProperties`.
     *
     * Users may override this function to implement behavior that is
     * dependent on the element having its property data initialized, e.g.
     * from defaults (initialized from `constructor`, `_initializeProperties`),
     * `attributeChangedCallback`, or values propagated from host e.g. via
     * bindings.  `super.ready()` must be called to ensure the data system
     * becomes enabled.
     *
     * @return {void}
     * @public
     * @override
     */


    ready() {
      this.__dataReady = true;

      this._flushProperties();
    }
    /**
     * Initializes the local storage for property accessors.
     *
     * Provided as an override point for performing any setup work prior
     * to initializing the property accessor system.
     *
     * @return {void}
     * @protected
     * @override
     */


    _initializeProperties() {
      // Capture instance properties; these will be set into accessors
      // during first flush. Don't set them here, since we want
      // these to overwrite defaults/constructor assignments
      for (let p in this.__dataHasAccessor) {
        if (this.hasOwnProperty(p)) {
          this.__dataInstanceProps = this.__dataInstanceProps || {};
          this.__dataInstanceProps[p] = this[p];
          delete this[p];
        }
      }
    }
    /**
     * Called at ready time with bag of instance properties that overwrote
     * accessors when the element upgraded.
     *
     * The default implementation sets these properties back into the
     * setter at ready time.  This method is provided as an override
     * point for customizing or providing more efficient initialization.
     *
     * @param {Object} props Bag of property values that were overwritten
     *   when creating property accessors.
     * @return {void}
     * @protected
     * @override
     */


    _initializeInstanceProperties(props) {
      Object.assign(this, props);
    }
    /**
     * Updates the local storage for a property (via `_setPendingProperty`)
     * and enqueues a `_proeprtiesChanged` callback.
     *
     * @param {string} property Name of the property
     * @param {*} value Value to set
     * @return {void}
     * @protected
     * @override
     */


    _setProperty(property, value) {
      if (this._setPendingProperty(property, value)) {
        this._invalidateProperties();
      }
    }
    /**
     * Returns the value for the given property.
     * @param {string} property Name of property
     * @return {*} Value for the given property
     * @protected
     * @override
     */


    _getProperty(property) {
      return this.__data[property];
    }
    /* eslint-disable no-unused-vars */

    /**
     * Updates the local storage for a property, records the previous value,
     * and adds it to the set of "pending changes" that will be passed to the
     * `_propertiesChanged` callback.  This method does not enqueue the
     * `_propertiesChanged` callback.
     *
     * @param {string} property Name of the property
     * @param {*} value Value to set
     * @param {boolean=} ext Not used here; affordance for closure
     * @return {boolean} Returns true if the property changed
     * @protected
     * @override
     */


    _setPendingProperty(property, value, ext) {
      let old = this.__data[property];

      let changed = this._shouldPropertyChange(property, value, old);

      if (changed) {
        if (!this.__dataPending) {
          this.__dataPending = {};
          this.__dataOld = {};
        } // Ensure old is captured from the last turn


        if (this.__dataOld && !(property in this.__dataOld)) {
          this.__dataOld[property] = old;
        }

        this.__data[property] = value;
        this.__dataPending[property] = value;
      }

      return changed;
    }
    /* eslint-enable */

    /**
     * @param {string} property Name of the property
     * @return {boolean} Returns true if the property is pending.
     */


    _isPropertyPending(property) {
      return !!(this.__dataPending && this.__dataPending.hasOwnProperty(property));
    }
    /**
     * Marks the properties as invalid, and enqueues an async
     * `_propertiesChanged` callback.
     *
     * @return {void}
     * @protected
     * @override
     */


    _invalidateProperties() {
      if (!this.__dataInvalid && this.__dataReady) {
        this.__dataInvalid = true;
        microtask.run(() => {
          if (this.__dataInvalid) {
            this.__dataInvalid = false;

            this._flushProperties();
          }
        });
      }
    }
    /**
     * Call to enable property accessor processing. Before this method is
     * called accessor values will be set but side effects are
     * queued. When called, any pending side effects occur immediately.
     * For elements, generally `connectedCallback` is a normal spot to do so.
     * It is safe to call this method multiple times as it only turns on
     * property accessors once.
     *
     * @return {void}
     * @protected
     * @override
     */


    _enableProperties() {
      if (!this.__dataEnabled) {
        this.__dataEnabled = true;

        if (this.__dataInstanceProps) {
          this._initializeInstanceProperties(this.__dataInstanceProps);

          this.__dataInstanceProps = null;
        }

        this.ready();
      }
    }
    /**
     * Calls the `_propertiesChanged` callback with the current set of
     * pending changes (and old values recorded when pending changes were
     * set), and resets the pending set of changes. Generally, this method
     * should not be called in user code.
     *
     * @return {void}
     * @protected
     * @override
     */


    _flushProperties() {
      this.__dataCounter++;
      const props = this.__data;
      const changedProps = this.__dataPending;
      const old = this.__dataOld;

      if (this._shouldPropertiesChange(props, changedProps, old)) {
        this.__dataPending = null;
        this.__dataOld = null;

        this._propertiesChanged(props, changedProps, old);
      }

      this.__dataCounter--;
    }
    /**
     * Called in `_flushProperties` to determine if `_propertiesChanged`
     * should be called. The default implementation returns true if
     * properties are pending. Override to customize when
     * `_propertiesChanged` is called.
     * @param {!Object} currentProps Bag of all current accessor values
     * @param {?Object} changedProps Bag of properties changed since the last
     *   call to `_propertiesChanged`
     * @param {?Object} oldProps Bag of previous values for each property
     *   in `changedProps`
     * @return {boolean} true if changedProps is truthy
     * @override
     */


    _shouldPropertiesChange(currentProps, changedProps, oldProps) {
      // eslint-disable-line no-unused-vars
      return Boolean(changedProps);
    }
    /**
     * Callback called when any properties with accessors created via
     * `_createPropertyAccessor` have been set.
     *
     * @param {!Object} currentProps Bag of all current accessor values
     * @param {?Object} changedProps Bag of properties changed since the last
     *   call to `_propertiesChanged`
     * @param {?Object} oldProps Bag of previous values for each property
     *   in `changedProps`
     * @return {void}
     * @protected
     * @override
     */


    _propertiesChanged(currentProps, changedProps, oldProps) {// eslint-disable-line no-unused-vars
    }
    /**
     * Method called to determine whether a property value should be
     * considered as a change and cause the `_propertiesChanged` callback
     * to be enqueued.
     *
     * The default implementation returns `true` if a strict equality
     * check fails. The method always returns false for `NaN`.
     *
     * Override this method to e.g. provide stricter checking for
     * Objects/Arrays when using immutable patterns.
     *
     * @param {string} property Property name
     * @param {*} value New property value
     * @param {*} old Previous property value
     * @return {boolean} Whether the property should be considered a change
     *   and enqueue a `_proeprtiesChanged` callback
     * @protected
     * @override
     */


    _shouldPropertyChange(property, value, old) {
      return (// Strict equality check
        old !== value && ( // This ensures (old==NaN, value==NaN) always returns false
        old === old || value === value)
      );
    }
    /**
     * Implements native Custom Elements `attributeChangedCallback` to
     * set an attribute value to a property via `_attributeToProperty`.
     *
     * @param {string} name Name of attribute that changed
     * @param {?string} old Old attribute value
     * @param {?string} value New attribute value
     * @param {?string} namespace Attribute namespace.
     * @return {void}
     * @suppress {missingProperties} Super may or may not implement the callback
     * @override
     */


    attributeChangedCallback(name, old, value, namespace) {
      // console.log('attributeChangedCallback', name, value, old);
      if (old !== value) {
        this._attributeToProperty(name, value);
      }

      if (super.attributeChangedCallback) {
        super.attributeChangedCallback(name, old, value, namespace);
      }
    }
    /**
     * Deserializes an attribute to its associated property.
     *
     * This method calls the `_deserializeValue` method to convert the string to
     * a typed value.
     *
     * @param {string} attribute Name of attribute to deserialize.
     * @param {?string} value of the attribute.
     * @param {*=} type type to deserialize to, defaults to the value
     * returned from `typeForProperty`
     * @return {void}
     * @override
     */


    _attributeToProperty(attribute, value, type) {
      if (!this.__serializing) {
        const map = this.__dataAttributes;
        const property = map && map[attribute] || attribute; // console.log(property, value, type, this.constructor.typeForProperty(property));

        this[property] = this._deserializeValue(value, type || this.constructor.typeForProperty(property));
      }
    }
    /**
     * Serializes a property to its associated attribute.
     *
     * @suppress {invalidCasts} Closure can't figure out `this` is an element.
     *
     * @param {string} property Property name to reflect.
     * @param {string=} attribute Attribute name to reflect to.
     * @param {*=} value Property value to refect.
     * @return {void}
     * @override
     */


    _propertyToAttribute(property, attribute, value) {
      this.__serializing = true;
      value = arguments.length < 3 ? this[property] : value;

      this._valueToNodeAttribute(
      /** @type {!HTMLElement} */
      this, value, attribute || this.constructor.attributeNameForProperty(property));

      this.__serializing = false;
    }
    /**
     * Sets a typed value to an HTML attribute on a node.
     *
     * This method calls the `_serializeValue` method to convert the typed
     * value to a string.  If the `_serializeValue` method returns `undefined`,
     * the attribute will be removed (this is the default for boolean
     * type `false`).
     *
     * @param {Element} node Element to set attribute to.
     * @param {*} value Value to serialize.
     * @param {string} attribute Attribute name to serialize to.
     * @return {void}
     * @override
     */


    _valueToNodeAttribute(node, value, attribute) {
      const str = this._serializeValue(value);

      if (attribute === 'class' || attribute === 'name' || attribute === 'slot') {
        node =
        /** @type {?Element} */
        Object(_utils_wrap_js__WEBPACK_IMPORTED_MODULE_3__["wrap"])(node);
      }

      if (str === undefined) {
        node.removeAttribute(attribute);
      } else {
        node.setAttribute(attribute, str);
      }
    }
    /**
     * Converts a typed JavaScript value to a string.
     *
     * This method is called when setting JS property values to
     * HTML attributes.  Users may override this method to provide
     * serialization for custom types.
     *
     * @param {*} value Property value to serialize.
     * @return {string | undefined} String serialized from the provided
     * property  value.
     * @override
     */


    _serializeValue(value) {
      switch (typeof value) {
        case 'boolean':
          return value ? '' : undefined;

        default:
          return value != null ? value.toString() : undefined;
      }
    }
    /**
     * Converts a string to a typed JavaScript value.
     *
     * This method is called when reading HTML attribute values to
     * JS properties.  Users may override this method to provide
     * deserialization for custom `type`s. Types for `Boolean`, `String`,
     * and `Number` convert attributes to the expected types.
     *
     * @param {?string} value Value to deserialize.
     * @param {*=} type Type to deserialize the string to.
     * @return {*} Typed value deserialized from the provided string.
     * @override
     */


    _deserializeValue(value, type) {
      switch (type) {
        case Boolean:
          return value !== null;

        case Number:
          return Number(value);

        default:
          return value;
      }
    }

  }

  return PropertiesChanged;
});

/***/ }),

/***/ "./node_modules/@polymer/polymer/lib/mixins/properties-mixin.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@polymer/polymer/lib/mixins/properties-mixin.js ***!
  \**********************************************************************/
/*! exports provided: PropertiesMixin */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PropertiesMixin", function() { return PropertiesMixin; });
/* harmony import */ var _utils_boot_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/boot.js */ "./node_modules/@polymer/polymer/lib/utils/boot.js");
/* harmony import */ var _utils_mixin_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/mixin.js */ "./node_modules/@polymer/polymer/lib/utils/mixin.js");
/* harmony import */ var _utils_telemetry_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/telemetry.js */ "./node_modules/@polymer/polymer/lib/utils/telemetry.js");
/* harmony import */ var _properties_changed_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./properties-changed.js */ "./node_modules/@polymer/polymer/lib/mixins/properties-changed.js");
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/




/**
 * Creates a copy of `props` with each property normalized such that
 * upgraded it is an object with at least a type property { type: Type}.
 *
 * @param {!Object} props Properties to normalize
 * @return {!Object} Copy of input `props` with normalized properties that
 * are in the form {type: Type}
 * @private
 */

function normalizeProperties(props) {
  const output = {};

  for (let p in props) {
    const o = props[p];
    output[p] = typeof o === 'function' ? {
      type: o
    } : o;
  }

  return output;
}
/**
 * Mixin that provides a minimal starting point to using the PropertiesChanged
 * mixin by providing a mechanism to declare properties in a static
 * getter (e.g. static get properties() { return { foo: String } }). Changes
 * are reported via the `_propertiesChanged` method.
 *
 * This mixin provides no specific support for rendering. Users are expected
 * to create a ShadowRoot and put content into it and update it in whatever
 * way makes sense. This can be done in reaction to properties changing by
 * implementing `_propertiesChanged`.
 *
 * @mixinFunction
 * @polymer
 * @appliesMixin PropertiesChanged
 * @summary Mixin that provides a minimal starting point for using
 * the PropertiesChanged mixin by providing a declarative `properties` object.
 * @template T
 * @param {function(new:T)} superClass Class to apply mixin to.
 * @return {function(new:T)} superClass with mixin applied.
 */


const PropertiesMixin = Object(_utils_mixin_js__WEBPACK_IMPORTED_MODULE_1__["dedupingMixin"])(superClass => {
  /**
   * @constructor
   * @implements {Polymer_PropertiesChanged}
   * @private
   */
  const base = Object(_properties_changed_js__WEBPACK_IMPORTED_MODULE_3__["PropertiesChanged"])(superClass);
  /**
   * Returns the super class constructor for the given class, if it is an
   * instance of the PropertiesMixin.
   *
   * @param {!PropertiesMixinConstructor} constructor PropertiesMixin constructor
   * @return {?PropertiesMixinConstructor} Super class constructor
   */

  function superPropertiesClass(constructor) {
    const superCtor = Object.getPrototypeOf(constructor); // Note, the `PropertiesMixin` class below only refers to the class
    // generated by this call to the mixin; the instanceof test only works
    // because the mixin is deduped and guaranteed only to apply once, hence
    // all constructors in a proto chain will see the same `PropertiesMixin`

    return superCtor.prototype instanceof PropertiesMixin ?
    /** @type {!PropertiesMixinConstructor} */
    superCtor : null;
  }
  /**
   * Returns a memoized version of the `properties` object for the
   * given class. Properties not in object format are converted to at
   * least {type}.
   *
   * @param {PropertiesMixinConstructor} constructor PropertiesMixin constructor
   * @return {Object} Memoized properties object
   */


  function ownProperties(constructor) {
    if (!constructor.hasOwnProperty(JSCompiler_renameProperty('__ownProperties', constructor))) {
      let props = null;

      if (constructor.hasOwnProperty(JSCompiler_renameProperty('properties', constructor))) {
        const properties = constructor.properties;

        if (properties) {
          props = normalizeProperties(properties);
        }
      }

      constructor.__ownProperties = props;
    }

    return constructor.__ownProperties;
  }
  /**
   * @polymer
   * @mixinClass
   * @extends {base}
   * @implements {Polymer_PropertiesMixin}
   * @unrestricted
   */


  class PropertiesMixin extends base {
    /**
     * Implements standard custom elements getter to observes the attributes
     * listed in `properties`.
     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
     * @nocollapse
     */
    static get observedAttributes() {
      if (!this.hasOwnProperty(JSCompiler_renameProperty('__observedAttributes', this))) {
        Object(_utils_telemetry_js__WEBPACK_IMPORTED_MODULE_2__["register"])(this.prototype);
        const props = this._properties;
        this.__observedAttributes = props ? Object.keys(props).map(p => this.prototype._addPropertyToAttributeMap(p)) : [];
      }

      return this.__observedAttributes;
    }
    /**
     * Finalizes an element definition, including ensuring any super classes
     * are also finalized. This includes ensuring property
     * accessors exist on the element prototype. This method calls
     * `_finalizeClass` to finalize each constructor in the prototype chain.
     * @return {void}
     * @nocollapse
     */


    static finalize() {
      if (!this.hasOwnProperty(JSCompiler_renameProperty('__finalized', this))) {
        const superCtor = superPropertiesClass(
        /** @type {!PropertiesMixinConstructor} */
        this);

        if (superCtor) {
          superCtor.finalize();
        }

        this.__finalized = true;

        this._finalizeClass();
      }
    }
    /**
     * Finalize an element class. This includes ensuring property
     * accessors exist on the element prototype. This method is called by
     * `finalize` and finalizes the class constructor.
     *
     * @protected
     * @nocollapse
     */


    static _finalizeClass() {
      const props = ownProperties(
      /** @type {!PropertiesMixinConstructor} */
      this);

      if (props) {
        /** @type {?} */
        this.createProperties(props);
      }
    }
    /**
     * Returns a memoized version of all properties, including those inherited
     * from super classes. Properties not in object format are converted to
     * at least {type}.
     *
     * @return {Object} Object containing properties for this class
     * @protected
     * @nocollapse
     */


    static get _properties() {
      if (!this.hasOwnProperty(JSCompiler_renameProperty('__properties', this))) {
        const superCtor = superPropertiesClass(
        /** @type {!PropertiesMixinConstructor} */
        this);
        this.__properties = Object.assign({}, superCtor && superCtor._properties, ownProperties(
        /** @type {PropertiesMixinConstructor} */
        this));
      }

      return this.__properties;
    }
    /**
     * Overrides `PropertiesChanged` method to return type specified in the
     * static `properties` object for the given property.
     * @param {string} name Name of property
     * @return {*} Type to which to deserialize attribute
     *
     * @protected
     * @nocollapse
     */


    static typeForProperty(name) {
      const info = this._properties[name];
      return info && info.type;
    }
    /**
     * Overrides `PropertiesChanged` method and adds a call to
     * `finalize` which lazily configures the element's property accessors.
     * @override
     * @return {void}
     */


    _initializeProperties() {
      Object(_utils_telemetry_js__WEBPACK_IMPORTED_MODULE_2__["incrementInstanceCount"])();
      this.constructor.finalize();

      super._initializeProperties();
    }
    /**
     * Called when the element is added to a document.
     * Calls `_enableProperties` to turn on property system from
     * `PropertiesChanged`.
     * @suppress {missingProperties} Super may or may not implement the callback
     * @return {void}
     * @override
     */


    connectedCallback() {
      if (super.connectedCallback) {
        super.connectedCallback();
      }

      this._enableProperties();
    }
    /**
     * Called when the element is removed from a document
     * @suppress {missingProperties} Super may or may not implement the callback
     * @return {void}
     * @override
     */


    disconnectedCallback() {
      if (super.disconnectedCallback) {
        super.disconnectedCallback();
      }
    }

  }

  return PropertiesMixin;
});

/***/ }),

/***/ "./node_modules/@polymer/polymer/lib/mixins/property-accessors.js":
/*!************************************************************************!*\
  !*** ./node_modules/@polymer/polymer/lib/mixins/property-accessors.js ***!
  \************************************************************************/
/*! exports provided: PropertyAccessors */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PropertyAccessors", function() { return PropertyAccessors; });
/* harmony import */ var _utils_boot_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/boot.js */ "./node_modules/@polymer/polymer/lib/utils/boot.js");
/* harmony import */ var _utils_mixin_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/mixin.js */ "./node_modules/@polymer/polymer/lib/utils/mixin.js");
/* harmony import */ var _utils_case_map_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/case-map.js */ "./node_modules/@polymer/polymer/lib/utils/case-map.js");
/* harmony import */ var _properties_changed_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./properties-changed.js */ "./node_modules/@polymer/polymer/lib/mixins/properties-changed.js");
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/



 // Save map of native properties; this forms a blacklist or properties
// that won't have their values "saved" by `saveAccessorValue`, since
// reading from an HTMLElement accessor from the context of a prototype throws

const nativeProperties = {};
let proto = HTMLElement.prototype;

while (proto) {
  let props = Object.getOwnPropertyNames(proto);

  for (let i = 0; i < props.length; i++) {
    nativeProperties[props[i]] = true;
  }

  proto = Object.getPrototypeOf(proto);
}
/**
 * Used to save the value of a property that will be overridden with
 * an accessor. If the `model` is a prototype, the values will be saved
 * in `__dataProto`, and it's up to the user (or downstream mixin) to
 * decide how/when to set these values back into the accessors.
 * If `model` is already an instance (it has a `__data` property), then
 * the value will be set as a pending property, meaning the user should
 * call `_invalidateProperties` or `_flushProperties` to take effect
 *
 * @param {Object} model Prototype or instance
 * @param {string} property Name of property
 * @return {void}
 * @private
 */


function saveAccessorValue(model, property) {
  // Don't read/store value for any native properties since they could throw
  if (!nativeProperties[property]) {
    let value = model[property];

    if (value !== undefined) {
      if (model.__data) {
        // Adding accessor to instance; update the property
        // It is the user's responsibility to call _flushProperties
        model._setPendingProperty(property, value);
      } else {
        // Adding accessor to proto; save proto's value for instance-time use
        if (!model.__dataProto) {
          model.__dataProto = {};
        } else if (!model.hasOwnProperty(JSCompiler_renameProperty('__dataProto', model))) {
          model.__dataProto = Object.create(model.__dataProto);
        }

        model.__dataProto[property] = value;
      }
    }
  }
}
/**
 * Element class mixin that provides basic meta-programming for creating one
 * or more property accessors (getter/setter pair) that enqueue an async
 * (batched) `_propertiesChanged` callback.
 *
 * For basic usage of this mixin:
 *
 * -   Declare attributes to observe via the standard `static get
 *     observedAttributes()`. Use `dash-case` attribute names to represent
 *     `camelCase` property names.
 * -   Implement the `_propertiesChanged` callback on the class.
 * -   Call `MyClass.createPropertiesForAttributes()` **once** on the class to
 *     generate property accessors for each observed attribute. This must be
 *     called before the first instance is created, for example, by calling it
 *     before calling `customElements.define`. It can also be called lazily from
 *     the element's `constructor`, as long as it's guarded so that the call is
 *     only made once, when the first instance is created.
 * -   Call `this._enableProperties()` in the element's `connectedCallback` to
 *     enable the accessors.
 *
 * Any `observedAttributes` will automatically be
 * deserialized via `attributeChangedCallback` and set to the associated
 * property using `dash-case`-to-`camelCase` convention.
 *
 * @mixinFunction
 * @polymer
 * @appliesMixin PropertiesChanged
 * @summary Element class mixin for reacting to property changes from
 *   generated property accessors.
 * @template T
 * @param {function(new:T)} superClass Class to apply mixin to.
 * @return {function(new:T)} superClass with mixin applied.
 */


const PropertyAccessors = Object(_utils_mixin_js__WEBPACK_IMPORTED_MODULE_1__["dedupingMixin"])(superClass => {
  /**
   * @constructor
   * @implements {Polymer_PropertiesChanged}
   * @unrestricted
   * @private
   */
  const base = Object(_properties_changed_js__WEBPACK_IMPORTED_MODULE_3__["PropertiesChanged"])(superClass);
  /**
   * @polymer
   * @mixinClass
   * @implements {Polymer_PropertyAccessors}
   * @extends {base}
   * @unrestricted
   */

  class PropertyAccessors extends base {
    /**
     * Generates property accessors for all attributes in the standard
     * static `observedAttributes` array.
     *
     * Attribute names are mapped to property names using the `dash-case` to
     * `camelCase` convention
     *
     * @return {void}
     * @nocollapse
     */
    static createPropertiesForAttributes() {
      let a$ =
      /** @type {?} */
      this.observedAttributes;

      for (let i = 0; i < a$.length; i++) {
        this.prototype._createPropertyAccessor(Object(_utils_case_map_js__WEBPACK_IMPORTED_MODULE_2__["dashToCamelCase"])(a$[i]));
      }
    }
    /**
     * Returns an attribute name that corresponds to the given property.
     * By default, converts camel to dash case, e.g. `fooBar` to `foo-bar`.
     * @param {string} property Property to convert
     * @return {string} Attribute name corresponding to the given property.
     *
     * @protected
     * @nocollapse
     */


    static attributeNameForProperty(property) {
      return Object(_utils_case_map_js__WEBPACK_IMPORTED_MODULE_2__["camelToDashCase"])(property);
    }
    /**
     * Overrides PropertiesChanged implementation to initialize values for
     * accessors created for values that already existed on the element
     * prototype.
     *
     * @return {void}
     * @protected
     * @override
     */


    _initializeProperties() {
      if (this.__dataProto) {
        this._initializeProtoProperties(this.__dataProto);

        this.__dataProto = null;
      }

      super._initializeProperties();
    }
    /**
     * Called at instance time with bag of properties that were overwritten
     * by accessors on the prototype when accessors were created.
     *
     * The default implementation sets these properties back into the
     * setter at instance time.  This method is provided as an override
     * point for customizing or providing more efficient initialization.
     *
     * @param {Object} props Bag of property values that were overwritten
     *   when creating property accessors.
     * @return {void}
     * @protected
     * @override
     */


    _initializeProtoProperties(props) {
      for (let p in props) {
        this._setProperty(p, props[p]);
      }
    }
    /**
     * Ensures the element has the given attribute. If it does not,
     * assigns the given value to the attribute.
     *
     * @suppress {invalidCasts} Closure can't figure out `this` is infact an
     *     element
     *
     * @param {string} attribute Name of attribute to ensure is set.
     * @param {string} value of the attribute.
     * @return {void}
     * @override
     */


    _ensureAttribute(attribute, value) {
      const el =
      /** @type {!HTMLElement} */
      this;

      if (!el.hasAttribute(attribute)) {
        this._valueToNodeAttribute(el, value, attribute);
      }
    }
    /**
     * Overrides PropertiesChanged implemention to serialize objects as JSON.
     *
     * @param {*} value Property value to serialize.
     * @return {string | undefined} String serialized from the provided property
     *     value.
     * @override
     */


    _serializeValue(value) {
      /* eslint-disable no-fallthrough */
      switch (typeof value) {
        case 'object':
          if (value instanceof Date) {
            return value.toString();
          } else if (value) {
            try {
              return JSON.stringify(value);
            } catch (x) {
              return '';
            }
          }

        default:
          return super._serializeValue(value);
      }
    }
    /**
     * Converts a string to a typed JavaScript value.
     *
     * This method is called by Polymer when reading HTML attribute values to
     * JS properties.  Users may override this method on Polymer element
     * prototypes to provide deserialization for custom `type`s.  Note,
     * the `type` argument is the value of the `type` field provided in the
     * `properties` configuration object for a given property, and is
     * by convention the constructor for the type to deserialize.
     *
     *
     * @param {?string} value Attribute value to deserialize.
     * @param {*=} type Type to deserialize the string to.
     * @return {*} Typed value deserialized from the provided string.
     * @override
     */


    _deserializeValue(value, type) {
      /**
       * @type {*}
       */
      let outValue;

      switch (type) {
        case Object:
          try {
            outValue = JSON.parse(
            /** @type {string} */
            value);
          } catch (x) {
            // allow non-JSON literals like Strings and Numbers
            outValue = value;
          }

          break;

        case Array:
          try {
            outValue = JSON.parse(
            /** @type {string} */
            value);
          } catch (x) {
            outValue = null;
            console.warn(`Polymer::Attributes: couldn't decode Array as JSON: ${value}`);
          }

          break;

        case Date:
          outValue = isNaN(value) ? String(value) : Number(value);
          outValue = new Date(outValue);
          break;

        default:
          outValue = super._deserializeValue(value, type);
          break;
      }

      return outValue;
    }
    /* eslint-enable no-fallthrough */

    /**
     * Overrides PropertiesChanged implementation to save existing prototype
     * property value so that it can be reset.
     * @param {string} property Name of the property
     * @param {boolean=} readOnly When true, no setter is created
     *
     * When calling on a prototype, any overwritten values are saved in
     * `__dataProto`, and it is up to the subclasser to decide how/when
     * to set those properties back into the accessor.  When calling on an
     * instance, the overwritten value is set via `_setPendingProperty`,
     * and the user should call `_invalidateProperties` or `_flushProperties`
     * for the values to take effect.
     * @protected
     * @return {void}
     * @override
     */


    _definePropertyAccessor(property, readOnly) {
      saveAccessorValue(this, property);

      super._definePropertyAccessor(property, readOnly);
    }
    /**
     * Returns true if this library created an accessor for the given property.
     *
     * @param {string} property Property name
     * @return {boolean} True if an accessor was created
     * @override
     */


    _hasAccessor(property) {
      return this.__dataHasAccessor && this.__dataHasAccessor[property];
    }
    /**
     * Returns true if the specified property has a pending change.
     *
     * @param {string} prop Property name
     * @return {boolean} True if property has a pending change
     * @protected
     * @override
     */


    _isPropertyPending(prop) {
      return Boolean(this.__dataPending && prop in this.__dataPending);
    }

  }

  return PropertyAccessors;
});

/***/ }),

/***/ "./node_modules/@polymer/polymer/lib/mixins/property-effects.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@polymer/polymer/lib/mixins/property-effects.js ***!
  \**********************************************************************/
/*! exports provided: PropertyEffects */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PropertyEffects", function() { return PropertyEffects; });
/* harmony import */ var _utils_boot_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/boot.js */ "./node_modules/@polymer/polymer/lib/utils/boot.js");
/* harmony import */ var _utils_wrap_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/wrap.js */ "./node_modules/@polymer/polymer/lib/utils/wrap.js");
/* harmony import */ var _utils_mixin_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/mixin.js */ "./node_modules/@polymer/polymer/lib/utils/mixin.js");
/* harmony import */ var _utils_path_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/path.js */ "./node_modules/@polymer/polymer/lib/utils/path.js");
/* harmony import */ var _utils_case_map_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/case-map.js */ "./node_modules/@polymer/polymer/lib/utils/case-map.js");
/* harmony import */ var _property_accessors_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./property-accessors.js */ "./node_modules/@polymer/polymer/lib/mixins/property-accessors.js");
/* harmony import */ var _template_stamp_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./template-stamp.js */ "./node_modules/@polymer/polymer/lib/mixins/template-stamp.js");
/* harmony import */ var _utils_settings_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils/settings.js */ "./node_modules/@polymer/polymer/lib/utils/settings.js");
/**
 * @fileoverview
 * @suppress {checkPrototypalTypes}
 * @license Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt The complete set of authors may be found
 * at http://polymer.github.io/AUTHORS.txt The complete set of contributors may
 * be found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by
 * Google as part of the polymer project is also subject to an additional IP
 * rights grant found at http://polymer.github.io/PATENTS.txt
 */




/* for notify, reflect */



/* for annotated effects */


 // Monotonically increasing unique ID used for de-duping effects triggered
// from multiple properties in the same turn

let dedupeId = 0;
const NOOP = [];
/**
 * Property effect types; effects are stored on the prototype using these keys
 * @enum {string}
 */

const TYPES = {
  COMPUTE: '__computeEffects',
  REFLECT: '__reflectEffects',
  NOTIFY: '__notifyEffects',
  PROPAGATE: '__propagateEffects',
  OBSERVE: '__observeEffects',
  READ_ONLY: '__readOnly'
};
const COMPUTE_INFO = '__computeInfo';
/** @const {!RegExp} */

const capitalAttributeRegex = /[A-Z]/;
/**
 * @typedef {{
 * name: (string | undefined),
 * structured: (boolean | undefined),
 * wildcard: (boolean | undefined)
 * }}
 */

let DataTrigger; //eslint-disable-line no-unused-vars

/**
 * @typedef {{
 * info: ?,
 * trigger: (!DataTrigger | undefined),
 * fn: (!Function | undefined)
 * }}
 */

let DataEffect; //eslint-disable-line no-unused-vars

/**
 * Ensures that the model has an own-property map of effects for the given type.
 * The model may be a prototype or an instance.
 *
 * Property effects are stored as arrays of effects by property in a map,
 * by named type on the model. e.g.
 *
 *   __computeEffects: {
 *     foo: [ ... ],
 *     bar: [ ... ]
 *   }
 *
 * If the model does not yet have an effect map for the type, one is created
 * and returned.  If it does, but it is not an own property (i.e. the
 * prototype had effects), the the map is deeply cloned and the copy is
 * set on the model and returned, ready for new effects to be added.
 *
 * @param {Object} model Prototype or instance
 * @param {string} type Property effect type
 * @param {boolean=} cloneArrays Clone any arrays assigned to the map when
 *   extending a superclass map onto this subclass
 * @return {Object} The own-property map of effects for the given type
 * @private
 */

function ensureOwnEffectMap(model, type, cloneArrays) {
  let effects = model[type];

  if (!effects) {
    effects = model[type] = {};
  } else if (!model.hasOwnProperty(type)) {
    effects = model[type] = Object.create(model[type]);

    if (cloneArrays) {
      for (let p in effects) {
        let protoFx = effects[p]; // Perf optimization over Array.slice

        let instFx = effects[p] = Array(protoFx.length);

        for (let i = 0; i < protoFx.length; i++) {
          instFx[i] = protoFx[i];
        }
      }
    }
  }

  return effects;
} // -- effects ----------------------------------------------

/**
 * Runs all effects of a given type for the given set of property changes
 * on an instance.
 *
 * @param {!Polymer_PropertyEffects} inst The instance with effects to run
 * @param {?Object} effects Object map of property-to-Array of effects
 * @param {?Object} props Bag of current property changes
 * @param {?Object=} oldProps Bag of previous values for changed properties
 * @param {boolean=} hasPaths True with `props` contains one or more paths
 * @param {*=} extraArgs Additional metadata to pass to effect function
 * @return {boolean} True if an effect ran for this property
 * @private
 */


function runEffects(inst, effects, props, oldProps, hasPaths, extraArgs) {
  if (effects) {
    let ran = false;
    const id = dedupeId++;

    for (let prop in props) {
      // Inline `runEffectsForProperty` for perf.
      let rootProperty = hasPaths ? Object(_utils_path_js__WEBPACK_IMPORTED_MODULE_3__["root"])(prop) : prop;
      let fxs = effects[rootProperty];

      if (fxs) {
        for (let i = 0, l = fxs.length, fx; i < l && (fx = fxs[i]); i++) {
          if ((!fx.info || fx.info.lastRun !== id) && (!hasPaths || pathMatchesTrigger(prop, fx.trigger))) {
            if (fx.info) {
              fx.info.lastRun = id;
            }

            fx.fn(inst, prop, props, oldProps, fx.info, hasPaths, extraArgs);
            ran = true;
          }
        }
      }
    }

    return ran;
  }

  return false;
}
/**
 * Runs a list of effects for a given property.
 *
 * @param {!Polymer_PropertyEffects} inst The instance with effects to run
 * @param {!Object} effects Object map of property-to-Array of effects
 * @param {number} dedupeId Counter used for de-duping effects
 * @param {string} prop Name of changed property
 * @param {*} props Changed properties
 * @param {*} oldProps Old properties
 * @param {boolean=} hasPaths True with `props` contains one or more paths
 * @param {*=} extraArgs Additional metadata to pass to effect function
 * @return {boolean} True if an effect ran for this property
 * @private
 */


function runEffectsForProperty(inst, effects, dedupeId, prop, props, oldProps, hasPaths, extraArgs) {
  let ran = false;
  let rootProperty = hasPaths ? Object(_utils_path_js__WEBPACK_IMPORTED_MODULE_3__["root"])(prop) : prop;
  let fxs = effects[rootProperty];

  if (fxs) {
    for (let i = 0, l = fxs.length, fx; i < l && (fx = fxs[i]); i++) {
      if ((!fx.info || fx.info.lastRun !== dedupeId) && (!hasPaths || pathMatchesTrigger(prop, fx.trigger))) {
        if (fx.info) {
          fx.info.lastRun = dedupeId;
        }

        fx.fn(inst, prop, props, oldProps, fx.info, hasPaths, extraArgs);
        ran = true;
      }
    }
  }

  return ran;
}
/**
 * Determines whether a property/path that has changed matches the trigger
 * criteria for an effect.  A trigger is a descriptor with the following
 * structure, which matches the descriptors returned from `parseArg`.
 * e.g. for `foo.bar.*`:
 * ```
 * trigger: {
 *   name: 'a.b',
 *   structured: true,
 *   wildcard: true
 * }
 * ```
 * If no trigger is given, the path is deemed to match.
 *
 * @param {string} path Path or property that changed
 * @param {?DataTrigger} trigger Descriptor
 * @return {boolean} Whether the path matched the trigger
 */


function pathMatchesTrigger(path, trigger) {
  if (trigger) {
    let triggerPath =
    /** @type {string} */
    trigger.name;
    return triggerPath == path || !!(trigger.structured && Object(_utils_path_js__WEBPACK_IMPORTED_MODULE_3__["isAncestor"])(triggerPath, path)) || !!(trigger.wildcard && Object(_utils_path_js__WEBPACK_IMPORTED_MODULE_3__["isDescendant"])(triggerPath, path));
  } else {
    return true;
  }
}
/**
 * Implements the "observer" effect.
 *
 * Calls the method with `info.methodName` on the instance, passing the
 * new and old values.
 *
 * @param {!Polymer_PropertyEffects} inst The instance the effect will be run on
 * @param {string} property Name of property
 * @param {Object} props Bag of current property changes
 * @param {Object} oldProps Bag of previous values for changed properties
 * @param {?} info Effect metadata
 * @return {void}
 * @private
 */


function runObserverEffect(inst, property, props, oldProps, info) {
  let fn = typeof info.method === "string" ? inst[info.method] : info.method;
  let changedProp = info.property;

  if (fn) {
    fn.call(inst, inst.__data[changedProp], oldProps[changedProp]);
  } else if (!info.dynamicFn) {
    console.warn('observer method `' + info.method + '` not defined');
  }
}
/**
 * Runs "notify" effects for a set of changed properties.
 *
 * This method differs from the generic `runEffects` method in that it
 * will dispatch path notification events in the case that the property
 * changed was a path and the root property for that path didn't have a
 * "notify" effect.  This is to maintain 1.0 behavior that did not require
 * `notify: true` to ensure object sub-property notifications were
 * sent.
 *
 * @param {!Polymer_PropertyEffects} inst The instance with effects to run
 * @param {Object} notifyProps Bag of properties to notify
 * @param {Object} props Bag of current property changes
 * @param {Object} oldProps Bag of previous values for changed properties
 * @param {boolean} hasPaths True with `props` contains one or more paths
 * @return {void}
 * @private
 */


function runNotifyEffects(inst, notifyProps, props, oldProps, hasPaths) {
  // Notify
  let fxs = inst[TYPES.NOTIFY];
  let notified;
  let id = dedupeId++; // Try normal notify effects; if none, fall back to try path notification

  for (let prop in notifyProps) {
    if (notifyProps[prop]) {
      if (fxs && runEffectsForProperty(inst, fxs, id, prop, props, oldProps, hasPaths)) {
        notified = true;
      } else if (hasPaths && notifyPath(inst, prop, props)) {
        notified = true;
      }
    }
  } // Flush host if we actually notified and host was batching
  // And the host has already initialized clients; this prevents
  // an issue with a host observing data changes before clients are ready.


  let host;

  if (notified && (host = inst.__dataHost) && host._invalidateProperties) {
    host._invalidateProperties();
  }
}
/**
 * Dispatches {property}-changed events with path information in the detail
 * object to indicate a sub-path of the property was changed.
 *
 * @param {!Polymer_PropertyEffects} inst The element from which to fire the
 *     event
 * @param {string} path The path that was changed
 * @param {Object} props Bag of current property changes
 * @return {boolean} Returns true if the path was notified
 * @private
 */


function notifyPath(inst, path, props) {
  let rootProperty = Object(_utils_path_js__WEBPACK_IMPORTED_MODULE_3__["root"])(path);

  if (rootProperty !== path) {
    let eventName = Object(_utils_case_map_js__WEBPACK_IMPORTED_MODULE_4__["camelToDashCase"])(rootProperty) + '-changed';
    dispatchNotifyEvent(inst, eventName, props[path], path);
    return true;
  }

  return false;
}
/**
 * Dispatches {property}-changed events to indicate a property (or path)
 * changed.
 *
 * @param {!Polymer_PropertyEffects} inst The element from which to fire the
 *     event
 * @param {string} eventName The name of the event to send
 *     ('{property}-changed')
 * @param {*} value The value of the changed property
 * @param {string | null | undefined} path If a sub-path of this property
 *     changed, the path that changed (optional).
 * @return {void}
 * @private
 * @suppress {invalidCasts}
 */


function dispatchNotifyEvent(inst, eventName, value, path) {
  let detail = {
    value: value,
    queueProperty: true
  };

  if (path) {
    detail.path = path;
  } // As a performance optimization, we could elide the wrap here since notifying
  // events are non-bubbling and shouldn't need retargeting. However, a very
  // small number of internal tests failed in obscure ways, which may indicate
  // user code relied on timing differences resulting from ShadyDOM flushing
  // as a result of the wrapped `dispatchEvent`.


  Object(_utils_wrap_js__WEBPACK_IMPORTED_MODULE_1__["wrap"])(
  /** @type {!HTMLElement} */
  inst).dispatchEvent(new CustomEvent(eventName, {
    detail
  }));
}
/**
 * Implements the "notify" effect.
 *
 * Dispatches a non-bubbling event named `info.eventName` on the instance
 * with a detail object containing the new `value`.
 *
 * @param {!Polymer_PropertyEffects} inst The instance the effect will be run on
 * @param {string} property Name of property
 * @param {Object} props Bag of current property changes
 * @param {Object} oldProps Bag of previous values for changed properties
 * @param {?} info Effect metadata
 * @param {boolean} hasPaths True with `props` contains one or more paths
 * @return {void}
 * @private
 */


function runNotifyEffect(inst, property, props, oldProps, info, hasPaths) {
  let rootProperty = hasPaths ? Object(_utils_path_js__WEBPACK_IMPORTED_MODULE_3__["root"])(property) : property;
  let path = rootProperty != property ? property : null;
  let value = path ? Object(_utils_path_js__WEBPACK_IMPORTED_MODULE_3__["get"])(inst, path) : inst.__data[property];

  if (path && value === undefined) {
    value = props[property]; // specifically for .splices
  }

  dispatchNotifyEvent(inst, info.eventName, value, path);
}
/**
 * Handler function for 2-way notification events. Receives context
 * information captured in the `addNotifyListener` closure from the
 * `__notifyListeners` metadata.
 *
 * Sets the value of the notified property to the host property or path.  If
 * the event contained path information, translate that path to the host
 * scope's name for that path first.
 *
 * @param {CustomEvent} event Notification event (e.g. '<property>-changed')
 * @param {!Polymer_PropertyEffects} inst Host element instance handling the
 *     notification event
 * @param {string} fromProp Child element property that was bound
 * @param {string} toPath Host property/path that was bound
 * @param {boolean} negate Whether the binding was negated
 * @return {void}
 * @private
 */


function handleNotification(event, inst, fromProp, toPath, negate) {
  let value;
  let detail =
  /** @type {Object} */
  event.detail;
  let fromPath = detail && detail.path;

  if (fromPath) {
    toPath = Object(_utils_path_js__WEBPACK_IMPORTED_MODULE_3__["translate"])(fromProp, toPath, fromPath);
    value = detail && detail.value;
  } else {
    value = event.currentTarget[fromProp];
  }

  value = negate ? !value : value;

  if (!inst[TYPES.READ_ONLY] || !inst[TYPES.READ_ONLY][toPath]) {
    if (inst._setPendingPropertyOrPath(toPath, value, true, Boolean(fromPath)) && (!detail || !detail.queueProperty)) {
      inst._invalidateProperties();
    }
  }
}
/**
 * Implements the "reflect" effect.
 *
 * Sets the attribute named `info.attrName` to the given property value.
 *
 * @param {!Polymer_PropertyEffects} inst The instance the effect will be run on
 * @param {string} property Name of property
 * @param {Object} props Bag of current property changes
 * @param {Object} oldProps Bag of previous values for changed properties
 * @param {?} info Effect metadata
 * @return {void}
 * @private
 */


function runReflectEffect(inst, property, props, oldProps, info) {
  let value = inst.__data[property];

  if (_utils_settings_js__WEBPACK_IMPORTED_MODULE_7__["sanitizeDOMValue"]) {
    value = Object(_utils_settings_js__WEBPACK_IMPORTED_MODULE_7__["sanitizeDOMValue"])(value, info.attrName, 'attribute',
    /** @type {Node} */
    inst);
  }

  inst._propertyToAttribute(property, info.attrName, value);
}
/**
 * Runs "computed" effects for a set of changed properties.
 *
 * This method differs from the generic `runEffects` method in that it
 * continues to run computed effects based on the output of each pass until
 * there are no more newly computed properties.  This ensures that all
 * properties that will be computed by the initial set of changes are
 * computed before other effects (binding propagation, observers, and notify)
 * run.
 *
 * @param {!Polymer_PropertyEffects} inst The instance the effect will be run on
 * @param {?Object} changedProps Bag of changed properties
 * @param {?Object} oldProps Bag of previous values for changed properties
 * @param {boolean} hasPaths True with `props` contains one or more paths
 * @return {void}
 * @private
 */


function runComputedEffects(inst, changedProps, oldProps, hasPaths) {
  let computeEffects = inst[TYPES.COMPUTE];

  if (computeEffects) {
    if (_utils_settings_js__WEBPACK_IMPORTED_MODULE_7__["orderedComputed"]) {
      // Runs computed effects in efficient order by keeping a topologically-
      // sorted queue of compute effects to run, and inserting subsequently
      // invalidated effects as they are run
      dedupeId++;
      const order = getComputedOrder(inst);
      const queue = [];

      for (let p in changedProps) {
        enqueueEffectsFor(p, computeEffects, queue, order, hasPaths);
      }

      let info;

      while (info = queue.shift()) {
        if (runComputedEffect(inst, '', changedProps, oldProps, info)) {
          enqueueEffectsFor(info.methodInfo, computeEffects, queue, order, hasPaths);
        }
      }

      Object.assign(
      /** @type {!Object} */
      oldProps, inst.__dataOld);
      Object.assign(
      /** @type {!Object} */
      changedProps, inst.__dataPending);
      inst.__dataPending = null;
    } else {
      // Original Polymer 2.x computed effects order, which continues running
      // effects until no further computed properties have been invalidated
      let inputProps = changedProps;

      while (runEffects(inst, computeEffects, inputProps, oldProps, hasPaths)) {
        Object.assign(
        /** @type {!Object} */
        oldProps, inst.__dataOld);
        Object.assign(
        /** @type {!Object} */
        changedProps, inst.__dataPending);
        inputProps = inst.__dataPending;
        inst.__dataPending = null;
      }
    }
  }
}
/**
 * Inserts a computed effect into a queue, given the specified order. Performs
 * the insert using a binary search.
 *
 * Used by `orderedComputed: true` computed property algorithm.
 *
 * @param {Object} info Property effects metadata
 * @param {Array<Object>} queue Ordered queue of effects
 * @param {Map<string,number>} order Map of computed property name->topological
 *   sort order
 */


const insertEffect = (info, queue, order) => {
  let start = 0;
  let end = queue.length - 1;
  let idx = -1;

  while (start <= end) {
    const mid = start + end >> 1; // Note `methodInfo` is where the computed property name is stored in
    // the effect metadata

    const cmp = order.get(queue[mid].methodInfo) - order.get(info.methodInfo);

    if (cmp < 0) {
      start = mid + 1;
    } else if (cmp > 0) {
      end = mid - 1;
    } else {
      idx = mid;
      break;
    }
  }

  if (idx < 0) {
    idx = end + 1;
  }

  queue.splice(idx, 0, info);
};
/**
 * Inserts all downstream computed effects invalidated by the specified property
 * into the topologically-sorted queue of effects to be run.
 *
 * Used by `orderedComputed: true` computed property algorithm.
 *
 * @param {string} prop Property name
 * @param {Object} computeEffects Computed effects for this element
 * @param {Array<Object>} queue Topologically-sorted queue of computed effects
 *   to be run
 * @param {Map<string,number>} order Map of computed property name->topological
 *   sort order
 * @param {boolean} hasPaths True with `changedProps` contains one or more paths
 */


const enqueueEffectsFor = (prop, computeEffects, queue, order, hasPaths) => {
  const rootProperty = hasPaths ? Object(_utils_path_js__WEBPACK_IMPORTED_MODULE_3__["root"])(prop) : prop;
  const fxs = computeEffects[rootProperty];

  if (fxs) {
    for (let i = 0; i < fxs.length; i++) {
      const fx = fxs[i];

      if (fx.info.lastRun !== dedupeId && (!hasPaths || pathMatchesTrigger(prop, fx.trigger))) {
        fx.info.lastRun = dedupeId;
        insertEffect(fx.info, queue, order);
      }
    }
  }
};
/**
 * Generates and retrieves a memoized map of computed property name to its
 * topologically-sorted order.
 *
 * The map is generated by first assigning a "dependency count" to each property
 * (defined as number properties it depends on, including its method for
 * "dynamic functions"). Any properties that have no dependencies are added to
 * the `ready` queue, which are properties whose order can be added to the final
 * order map. Properties are popped off the `ready` queue one by one and a.) added as
 * the next property in the order map, and b.) each property that it is a
 * dependency for has its dep count decremented (and if that property's dep
 * count goes to zero, it is added to the `ready` queue), until all properties
 * have been visited and ordered.
 *
 * Used by `orderedComputed: true` computed property algorithm.
 *
 * @param {!Polymer_PropertyEffects} inst The instance to retrieve the computed
 *   effect order for.
 * @return {Map<string,number>} Map of computed property name->topological sort
 *   order
 */


function getComputedOrder(inst) {
  let ordered = inst.constructor.__orderedComputedDeps;

  if (!ordered) {
    ordered = new Map();
    const effects = inst[TYPES.COMPUTE];
    let {
      counts,
      ready,
      total
    } = dependencyCounts(inst);
    let curr;

    while (curr = ready.shift()) {
      ordered.set(curr, ordered.size);
      const computedByCurr = effects[curr];

      if (computedByCurr) {
        computedByCurr.forEach(fx => {
          // Note `methodInfo` is where the computed property name is stored
          const computedProp = fx.info.methodInfo;
          --total;

          if (--counts[computedProp] === 0) {
            ready.push(computedProp);
          }
        });
      }
    }

    if (total !== 0) {
      const el =
      /** @type {HTMLElement} */
      inst;
      console.warn(`Computed graph for ${el.localName} incomplete; circular?`);
    }

    inst.constructor.__orderedComputedDeps = ordered;
  }

  return ordered;
}
/**
 * Generates a map of property-to-dependency count (`counts`, where "dependency
 * count" is the number of dependencies a given property has assuming it is a
 * computed property, otherwise 0).  It also returns a pre-populated list of
 * `ready` properties that have no dependencies and a `total` count, which is
 * used for error-checking the graph.
 *
 * Used by `orderedComputed: true` computed property algorithm.
 *
 * @param {!Polymer_PropertyEffects} inst The instance to generate dependency
 *   counts for.
 * @return {!Object} Object containing `counts` map (property-to-dependency
 *   count) and pre-populated `ready` array of properties that had zero
 *   dependencies.
 */


function dependencyCounts(inst) {
  const infoForComputed = inst[COMPUTE_INFO];
  const counts = {};
  const computedDeps = inst[TYPES.COMPUTE];
  const ready = [];
  let total = 0; // Count dependencies for each computed property

  for (let p in infoForComputed) {
    const info = infoForComputed[p]; // Be sure to add the method name itself in case of "dynamic functions"

    total += counts[p] = info.args.filter(a => !a.literal).length + (info.dynamicFn ? 1 : 0);
  } // Build list of ready properties (that aren't themselves computed)


  for (let p in computedDeps) {
    if (!infoForComputed[p]) {
      ready.push(p);
    }
  }

  return {
    counts,
    ready,
    total
  };
}
/**
 * Implements the "computed property" effect by running the method with the
 * values of the arguments specified in the `info` object and setting the
 * return value to the computed property specified.
 *
 * @param {!Polymer_PropertyEffects} inst The instance the effect will be run on
 * @param {string} property Name of property
 * @param {?Object} changedProps Bag of current property changes
 * @param {?Object} oldProps Bag of previous values for changed properties
 * @param {?} info Effect metadata
 * @return {boolean} True when the property being computed changed
 * @private
 */


function runComputedEffect(inst, property, changedProps, oldProps, info) {
  // Dirty check dependencies and run if any invalid
  let result = runMethodEffect(inst, property, changedProps, oldProps, info); // Abort if method returns a no-op result

  if (result === NOOP) {
    return false;
  }

  let computedProp = info.methodInfo;

  if (inst.__dataHasAccessor && inst.__dataHasAccessor[computedProp]) {
    return inst._setPendingProperty(computedProp, result, true);
  } else {
    inst[computedProp] = result;
    return false;
  }
}
/**
 * Computes path changes based on path links set up using the `linkPaths`
 * API.
 *
 * @param {!Polymer_PropertyEffects} inst The instance whose props are changing
 * @param {string} path Path that has changed
 * @param {*} value Value of changed path
 * @return {void}
 * @private
 */


function computeLinkedPaths(inst, path, value) {
  let links = inst.__dataLinkedPaths;

  if (links) {
    let link;

    for (let a in links) {
      let b = links[a];

      if (Object(_utils_path_js__WEBPACK_IMPORTED_MODULE_3__["isDescendant"])(a, path)) {
        link = Object(_utils_path_js__WEBPACK_IMPORTED_MODULE_3__["translate"])(a, b, path);

        inst._setPendingPropertyOrPath(link, value, true, true);
      } else if (Object(_utils_path_js__WEBPACK_IMPORTED_MODULE_3__["isDescendant"])(b, path)) {
        link = Object(_utils_path_js__WEBPACK_IMPORTED_MODULE_3__["translate"])(b, a, path);

        inst._setPendingPropertyOrPath(link, value, true, true);
      }
    }
  }
} // -- bindings ----------------------------------------------

/**
 * Adds binding metadata to the current `nodeInfo`, and binding effects
 * for all part dependencies to `templateInfo`.
 *
 * @param {Function} constructor Class that `_parseTemplate` is currently
 *   running on
 * @param {TemplateInfo} templateInfo Template metadata for current template
 * @param {NodeInfo} nodeInfo Node metadata for current template node
 * @param {string} kind Binding kind, either 'property', 'attribute', or 'text'
 * @param {string} target Target property name
 * @param {!Array<!BindingPart>} parts Array of binding part metadata
 * @param {string=} literal Literal text surrounding binding parts (specified
 *   only for 'property' bindings, since these must be initialized as part
 *   of boot-up)
 * @return {void}
 * @private
 */


function addBinding(constructor, templateInfo, nodeInfo, kind, target, parts, literal) {
  // Create binding metadata and add to nodeInfo
  nodeInfo.bindings = nodeInfo.bindings || [];
  let
  /** Binding */
  binding = {
    kind,
    target,
    parts,
    literal,
    isCompound: parts.length !== 1
  };
  nodeInfo.bindings.push(binding); // Add listener info to binding metadata

  if (shouldAddListener(binding)) {
    let {
      event,
      negate
    } = binding.parts[0];
    binding.listenerEvent = event || Object(_utils_case_map_js__WEBPACK_IMPORTED_MODULE_4__["camelToDashCase"])(target) + '-changed';
    binding.listenerNegate = negate;
  } // Add "propagate" property effects to templateInfo


  let index = templateInfo.nodeInfoList.length;

  for (let i = 0; i < binding.parts.length; i++) {
    let part = binding.parts[i];
    part.compoundIndex = i;
    addEffectForBindingPart(constructor, templateInfo, binding, part, index);
  }
}
/**
 * Adds property effects to the given `templateInfo` for the given binding
 * part.
 *
 * @param {Function} constructor Class that `_parseTemplate` is currently
 *   running on
 * @param {TemplateInfo} templateInfo Template metadata for current template
 * @param {!Binding} binding Binding metadata
 * @param {!BindingPart} part Binding part metadata
 * @param {number} index Index into `nodeInfoList` for this node
 * @return {void}
 */


function addEffectForBindingPart(constructor, templateInfo, binding, part, index) {
  if (!part.literal) {
    if (binding.kind === 'attribute' && binding.target[0] === '-') {
      console.warn('Cannot set attribute ' + binding.target + ' because "-" is not a valid attribute starting character');
    } else {
      let dependencies = part.dependencies;
      let info = {
        index,
        binding,
        part,
        evaluator: constructor
      };

      for (let j = 0; j < dependencies.length; j++) {
        let trigger = dependencies[j];

        if (typeof trigger == 'string') {
          trigger = parseArg(trigger);
          trigger.wildcard = true;
        }

        constructor._addTemplatePropertyEffect(templateInfo, trigger.rootProperty, {
          fn: runBindingEffect,
          info,
          trigger
        });
      }
    }
  }
}
/**
 * Implements the "binding" (property/path binding) effect.
 *
 * Note that binding syntax is overridable via `_parseBindings` and
 * `_evaluateBinding`.  This method will call `_evaluateBinding` for any
 * non-literal parts returned from `_parseBindings`.  However,
 * there is no support for _path_ bindings via custom binding parts,
 * as this is specific to Polymer's path binding syntax.
 *
 * @param {!Polymer_PropertyEffects} inst The instance the effect will be run on
 * @param {string} path Name of property
 * @param {Object} props Bag of current property changes
 * @param {Object} oldProps Bag of previous values for changed properties
 * @param {?} info Effect metadata
 * @param {boolean} hasPaths True with `props` contains one or more paths
 * @param {Array} nodeList List of nodes associated with `nodeInfoList` template
 *   metadata
 * @return {void}
 * @private
 */


function runBindingEffect(inst, path, props, oldProps, info, hasPaths, nodeList) {
  let node = nodeList[info.index];
  let binding = info.binding;
  let part = info.part; // Subpath notification: transform path and set to client
  // e.g.: foo="{{obj.sub}}", path: 'obj.sub.prop', set 'foo.prop'=obj.sub.prop

  if (hasPaths && part.source && path.length > part.source.length && binding.kind == 'property' && !binding.isCompound && node.__isPropertyEffectsClient && node.__dataHasAccessor && node.__dataHasAccessor[binding.target]) {
    let value = props[path];
    path = Object(_utils_path_js__WEBPACK_IMPORTED_MODULE_3__["translate"])(part.source, binding.target, path);

    if (node._setPendingPropertyOrPath(path, value, false, true)) {
      inst._enqueueClient(node);
    }
  } else {
    let value = info.evaluator._evaluateBinding(inst, part, path, props, oldProps, hasPaths); // Propagate value to child
    // Abort if value is a no-op result


    if (value !== NOOP) {
      applyBindingValue(inst, node, binding, part, value);
    }
  }
}
/**
 * Sets the value for an "binding" (binding) effect to a node,
 * either as a property or attribute.
 *
 * @param {!Polymer_PropertyEffects} inst The instance owning the binding effect
 * @param {Node} node Target node for binding
 * @param {!Binding} binding Binding metadata
 * @param {!BindingPart} part Binding part metadata
 * @param {*} value Value to set
 * @return {void}
 * @private
 */


function applyBindingValue(inst, node, binding, part, value) {
  value = computeBindingValue(node, value, binding, part);

  if (_utils_settings_js__WEBPACK_IMPORTED_MODULE_7__["sanitizeDOMValue"]) {
    value = Object(_utils_settings_js__WEBPACK_IMPORTED_MODULE_7__["sanitizeDOMValue"])(value, binding.target, binding.kind, node);
  }

  if (binding.kind == 'attribute') {
    // Attribute binding
    inst._valueToNodeAttribute(
    /** @type {Element} */
    node, value, binding.target);
  } else {
    // Property binding
    let prop = binding.target;

    if (node.__isPropertyEffectsClient && node.__dataHasAccessor && node.__dataHasAccessor[prop]) {
      if (!node[TYPES.READ_ONLY] || !node[TYPES.READ_ONLY][prop]) {
        if (node._setPendingProperty(prop, value)) {
          inst._enqueueClient(node);
        }
      }
    } else {
      // In legacy no-batching mode, bindings applied before dataReady are
      // equivalent to the "apply config" phase, which only set managed props
      inst._setUnmanagedPropertyToNode(node, prop, value);
    }
  }
}
/**
 * Transforms an "binding" effect value based on compound & negation
 * effect metadata, as well as handling for special-case properties
 *
 * @param {Node} node Node the value will be set to
 * @param {*} value Value to set
 * @param {!Binding} binding Binding metadata
 * @param {!BindingPart} part Binding part metadata
 * @return {*} Transformed value to set
 * @private
 */


function computeBindingValue(node, value, binding, part) {
  if (binding.isCompound) {
    let storage = node.__dataCompoundStorage[binding.target];
    storage[part.compoundIndex] = value;
    value = storage.join('');
  }

  if (binding.kind !== 'attribute') {
    // Some browsers serialize `undefined` to `"undefined"`
    if (binding.target === 'textContent' || binding.target === 'value' && (node.localName === 'input' || node.localName === 'textarea')) {
      value = value == undefined ? '' : value;
    }
  }

  return value;
}
/**
 * Returns true if a binding's metadata meets all the requirements to allow
 * 2-way binding, and therefore a `<property>-changed` event listener should be
 * added:
 * - used curly braces
 * - is a property (not attribute) binding
 * - is not a textContent binding
 * - is not compound
 *
 * @param {!Binding} binding Binding metadata
 * @return {boolean} True if 2-way listener should be added
 * @private
 */


function shouldAddListener(binding) {
  return Boolean(binding.target) && binding.kind != 'attribute' && binding.kind != 'text' && !binding.isCompound && binding.parts[0].mode === '{';
}
/**
 * Setup compound binding storage structures, notify listeners, and dataHost
 * references onto the bound nodeList.
 *
 * @param {!Polymer_PropertyEffects} inst Instance that bas been previously
 *     bound
 * @param {TemplateInfo} templateInfo Template metadata
 * @return {void}
 * @private
 */


function setupBindings(inst, templateInfo) {
  // Setup compound storage, dataHost, and notify listeners
  let {
    nodeList,
    nodeInfoList
  } = templateInfo;

  if (nodeInfoList.length) {
    for (let i = 0; i < nodeInfoList.length; i++) {
      let info = nodeInfoList[i];
      let node = nodeList[i];
      let bindings = info.bindings;

      if (bindings) {
        for (let i = 0; i < bindings.length; i++) {
          let binding = bindings[i];
          setupCompoundStorage(node, binding);
          addNotifyListener(node, inst, binding);
        }
      } // This ensures all bound elements have a host set, regardless
      // of whether they upgrade synchronous to creation


      node.__dataHost = inst;
    }
  }
}
/**
 * Initializes `__dataCompoundStorage` local storage on a bound node with
 * initial literal data for compound bindings, and sets the joined
 * literal parts to the bound property.
 *
 * When changes to compound parts occur, they are first set into the compound
 * storage array for that property, and then the array is joined to result in
 * the final value set to the property/attribute.
 *
 * @param {Node} node Bound node to initialize
 * @param {Binding} binding Binding metadata
 * @return {void}
 * @private
 */


function setupCompoundStorage(node, binding) {
  if (binding.isCompound) {
    // Create compound storage map
    let storage = node.__dataCompoundStorage || (node.__dataCompoundStorage = {});
    let parts = binding.parts; // Copy literals from parts into storage for this binding

    let literals = new Array(parts.length);

    for (let j = 0; j < parts.length; j++) {
      literals[j] = parts[j].literal;
    }

    let target = binding.target;
    storage[target] = literals; // Configure properties with their literal parts

    if (binding.literal && binding.kind == 'property') {
      // Note, className needs style scoping so this needs wrapping.
      // We may also want to consider doing this for `textContent` and
      // `innerHTML`.
      if (target === 'className') {
        node = Object(_utils_wrap_js__WEBPACK_IMPORTED_MODULE_1__["wrap"])(node);
      }

      node[target] = binding.literal;
    }
  }
}
/**
 * Adds a 2-way binding notification event listener to the node specified
 *
 * @param {Object} node Child element to add listener to
 * @param {!Polymer_PropertyEffects} inst Host element instance to handle
 *     notification event
 * @param {Binding} binding Binding metadata
 * @return {void}
 * @private
 */


function addNotifyListener(node, inst, binding) {
  if (binding.listenerEvent) {
    let part = binding.parts[0];
    node.addEventListener(binding.listenerEvent, function (e) {
      handleNotification(e, inst, binding.target, part.source, part.negate);
    });
  }
} // -- for method-based effects (complexObserver & computed) --------------

/**
 * Adds property effects for each argument in the method signature (and
 * optionally, for the method name if `dynamic` is true) that calls the
 * provided effect function.
 *
 * @param {Element | Object} model Prototype or instance
 * @param {!MethodSignature} sig Method signature metadata
 * @param {string} type Type of property effect to add
 * @param {Function} effectFn Function to run when arguments change
 * @param {*=} methodInfo Effect-specific information to be included in
 *   method effect metadata
 * @param {boolean|Object=} dynamicFn Boolean or object map indicating whether
 *   method names should be included as a dependency to the effect. Note,
 *   defaults to true if the signature is static (sig.static is true).
 * @return {!Object} Effect metadata for this method effect
 * @private
 */


function createMethodEffect(model, sig, type, effectFn, methodInfo, dynamicFn) {
  dynamicFn = sig.static || dynamicFn && (typeof dynamicFn !== 'object' || dynamicFn[sig.methodName]);
  let info = {
    methodName: sig.methodName,
    args: sig.args,
    methodInfo,
    dynamicFn
  };

  for (let i = 0, arg; i < sig.args.length && (arg = sig.args[i]); i++) {
    if (!arg.literal) {
      model._addPropertyEffect(arg.rootProperty, type, {
        fn: effectFn,
        info: info,
        trigger: arg
      });
    }
  }

  if (dynamicFn) {
    model._addPropertyEffect(sig.methodName, type, {
      fn: effectFn,
      info: info
    });
  }

  return info;
}
/**
 * Calls a method with arguments marshaled from properties on the instance
 * based on the method signature contained in the effect metadata.
 *
 * Multi-property observers, computed properties, and inline computing
 * functions call this function to invoke the method, then use the return
 * value accordingly.
 *
 * @param {!Polymer_PropertyEffects} inst The instance the effect will be run on
 * @param {string} property Name of property
 * @param {Object} props Bag of current property changes
 * @param {Object} oldProps Bag of previous values for changed properties
 * @param {?} info Effect metadata
 * @return {*} Returns the return value from the method invocation
 * @private
 */


function runMethodEffect(inst, property, props, oldProps, info) {
  // Instances can optionally have a _methodHost which allows redirecting where
  // to find methods. Currently used by `templatize`.
  let context = inst._methodHost || inst;
  let fn = context[info.methodName];

  if (fn) {
    let args = inst._marshalArgs(info.args, property, props);

    return args === NOOP ? NOOP : fn.apply(context, args);
  } else if (!info.dynamicFn) {
    console.warn('method `' + info.methodName + '` not defined');
  }
}

const emptyArray = []; // Regular expressions used for binding

const IDENT = '(?:' + '[a-zA-Z_$][\\w.:$\\-*]*' + ')';
const NUMBER = '(?:' + '[-+]?[0-9]*\\.?[0-9]+(?:[eE][-+]?[0-9]+)?' + ')';
const SQUOTE_STRING = '(?:' + '\'(?:[^\'\\\\]|\\\\.)*\'' + ')';
const DQUOTE_STRING = '(?:' + '"(?:[^"\\\\]|\\\\.)*"' + ')';
const STRING = '(?:' + SQUOTE_STRING + '|' + DQUOTE_STRING + ')';
const ARGUMENT = '(?:(' + IDENT + '|' + NUMBER + '|' + STRING + ')\\s*' + ')';
const ARGUMENTS = '(?:' + ARGUMENT + '(?:,\\s*' + ARGUMENT + ')*' + ')';
const ARGUMENT_LIST = '(?:' + '\\(\\s*' + '(?:' + ARGUMENTS + '?' + ')' + '\\)\\s*' + ')';
const BINDING = '(' + IDENT + '\\s*' + ARGUMENT_LIST + '?' + ')'; // Group 3

const OPEN_BRACKET = '(\\[\\[|{{)' + '\\s*';
const CLOSE_BRACKET = '(?:]]|}})';
const NEGATE = '(?:(!)\\s*)?'; // Group 2

const EXPRESSION = OPEN_BRACKET + NEGATE + BINDING + CLOSE_BRACKET;
const bindingRegex = new RegExp(EXPRESSION, "g");
/**
 * Create a string from binding parts of all the literal parts
 *
 * @param {!Array<BindingPart>} parts All parts to stringify
 * @return {string} String made from the literal parts
 */

function literalFromParts(parts) {
  let s = '';

  for (let i = 0; i < parts.length; i++) {
    let literal = parts[i].literal;
    s += literal || '';
  }

  return s;
}
/**
 * Parses an expression string for a method signature, and returns a metadata
 * describing the method in terms of `methodName`, `static` (whether all the
 * arguments are literals), and an array of `args`
 *
 * @param {string} expression The expression to parse
 * @return {?MethodSignature} The method metadata object if a method expression was
 *   found, otherwise `undefined`
 * @private
 */


function parseMethod(expression) {
  // tries to match valid javascript property names
  let m = expression.match(/([^\s]+?)\(([\s\S]*)\)/);

  if (m) {
    let methodName = m[1];
    let sig = {
      methodName,
      static: true,
      args: emptyArray
    };

    if (m[2].trim()) {
      // replace escaped commas with comma entity, split on un-escaped commas
      let args = m[2].replace(/\\,/g, '&comma;').split(',');
      return parseArgs(args, sig);
    } else {
      return sig;
    }
  }

  return null;
}
/**
 * Parses an array of arguments and sets the `args` property of the supplied
 * signature metadata object. Sets the `static` property to false if any
 * argument is a non-literal.
 *
 * @param {!Array<string>} argList Array of argument names
 * @param {!MethodSignature} sig Method signature metadata object
 * @return {!MethodSignature} The updated signature metadata object
 * @private
 */


function parseArgs(argList, sig) {
  sig.args = argList.map(function (rawArg) {
    let arg = parseArg(rawArg);

    if (!arg.literal) {
      sig.static = false;
    }

    return arg;
  }, this);
  return sig;
}
/**
 * Parses an individual argument, and returns an argument metadata object
 * with the following fields:
 *
 *   {
 *     value: 'prop',        // property/path or literal value
 *     literal: false,       // whether argument is a literal
 *     structured: false,    // whether the property is a path
 *     rootProperty: 'prop', // the root property of the path
 *     wildcard: false       // whether the argument was a wildcard '.*' path
 *   }
 *
 * @param {string} rawArg The string value of the argument
 * @return {!MethodArg} Argument metadata object
 * @private
 */


function parseArg(rawArg) {
  // clean up whitespace
  let arg = rawArg.trim() // replace comma entity with comma
  .replace(/&comma;/g, ',') // repair extra escape sequences; note only commas strictly need
  // escaping, but we allow any other char to be escaped since its
  // likely users will do this
  .replace(/\\(.)/g, '\$1'); // basic argument descriptor

  let a = {
    name: arg,
    value: '',
    literal: false
  }; // detect literal value (must be String or Number)

  let fc = arg[0];

  if (fc === '-') {
    fc = arg[1];
  }

  if (fc >= '0' && fc <= '9') {
    fc = '#';
  }

  switch (fc) {
    case "'":
    case '"':
      a.value = arg.slice(1, -1);
      a.literal = true;
      break;

    case '#':
      a.value = Number(arg);
      a.literal = true;
      break;
  } // if not literal, look for structured path


  if (!a.literal) {
    a.rootProperty = Object(_utils_path_js__WEBPACK_IMPORTED_MODULE_3__["root"])(arg); // detect structured path (has dots)

    a.structured = Object(_utils_path_js__WEBPACK_IMPORTED_MODULE_3__["isPath"])(arg);

    if (a.structured) {
      a.wildcard = arg.slice(-2) == '.*';

      if (a.wildcard) {
        a.name = arg.slice(0, -2);
      }
    }
  }

  return a;
}

function getArgValue(data, props, path) {
  let value = Object(_utils_path_js__WEBPACK_IMPORTED_MODULE_3__["get"])(data, path); // when data is not stored e.g. `splices`, get the value from changedProps
  // TODO(kschaaf): Note, this can cause a rare issue where the wildcard
  // info.value could pull a stale value out of changedProps during a reentrant
  // change that sets the value back to undefined.
  // https://github.com/Polymer/polymer/issues/5479

  if (value === undefined) {
    value = props[path];
  }

  return value;
} // data api

/**
 * Sends array splice notifications (`.splices` and `.length`)
 *
 * Note: this implementation only accepts normalized paths
 *
 * @param {!Polymer_PropertyEffects} inst Instance to send notifications to
 * @param {Array} array The array the mutations occurred on
 * @param {string} path The path to the array that was mutated
 * @param {Array} splices Array of splice records
 * @return {void}
 * @private
 */


function notifySplices(inst, array, path, splices) {
  const splicesData = {
    indexSplices: splices
  }; // Legacy behavior stored splices in `__data__` so it was *not* ephemeral.
  // To match this behavior, we store splices directly on the array.

  if (_utils_settings_js__WEBPACK_IMPORTED_MODULE_7__["legacyUndefined"] && !inst._overrideLegacyUndefined) {
    array.splices = splicesData;
  }

  inst.notifyPath(path + '.splices', splicesData);
  inst.notifyPath(path + '.length', array.length); // Clear splice data only when it's stored on the array.

  if (_utils_settings_js__WEBPACK_IMPORTED_MODULE_7__["legacyUndefined"] && !inst._overrideLegacyUndefined) {
    splicesData.indexSplices = [];
  }
}
/**
 * Creates a splice record and sends an array splice notification for
 * the described mutation
 *
 * Note: this implementation only accepts normalized paths
 *
 * @param {!Polymer_PropertyEffects} inst Instance to send notifications to
 * @param {Array} array The array the mutations occurred on
 * @param {string} path The path to the array that was mutated
 * @param {number} index Index at which the array mutation occurred
 * @param {number} addedCount Number of added items
 * @param {Array} removed Array of removed items
 * @return {void}
 * @private
 */


function notifySplice(inst, array, path, index, addedCount, removed) {
  notifySplices(inst, array, path, [{
    index: index,
    addedCount: addedCount,
    removed: removed,
    object: array,
    type: 'splice'
  }]);
}
/**
 * Returns an upper-cased version of the string.
 *
 * @param {string} name String to uppercase
 * @return {string} Uppercased string
 * @private
 */


function upper(name) {
  return name[0].toUpperCase() + name.substring(1);
}
/**
 * Element class mixin that provides meta-programming for Polymer's template
 * binding and data observation (collectively, "property effects") system.
 *
 * This mixin uses provides the following key static methods for adding
 * property effects to an element class:
 * - `addPropertyEffect`
 * - `createPropertyObserver`
 * - `createMethodObserver`
 * - `createNotifyingProperty`
 * - `createReadOnlyProperty`
 * - `createReflectedProperty`
 * - `createComputedProperty`
 * - `bindTemplate`
 *
 * Each method creates one or more property accessors, along with metadata
 * used by this mixin's implementation of `_propertiesChanged` to perform
 * the property effects.
 *
 * Underscored versions of the above methods also exist on the element
 * prototype for adding property effects on instances at runtime.
 *
 * Note that this mixin overrides several `PropertyAccessors` methods, in
 * many cases to maintain guarantees provided by the Polymer 1.x features;
 * notably it changes property accessors to be synchronous by default
 * whereas the default when using `PropertyAccessors` standalone is to be
 * async by default.
 *
 * @mixinFunction
 * @polymer
 * @appliesMixin TemplateStamp
 * @appliesMixin PropertyAccessors
 * @summary Element class mixin that provides meta-programming for Polymer's
 * template binding and data observation system.
 */


const PropertyEffects = Object(_utils_mixin_js__WEBPACK_IMPORTED_MODULE_2__["dedupingMixin"])(superClass => {
  /**
   * @constructor
   * @implements {Polymer_PropertyAccessors}
   * @implements {Polymer_TemplateStamp}
   * @unrestricted
   * @private
   */
  const propertyEffectsBase = Object(_template_stamp_js__WEBPACK_IMPORTED_MODULE_6__["TemplateStamp"])(Object(_property_accessors_js__WEBPACK_IMPORTED_MODULE_5__["PropertyAccessors"])(superClass));
  /**
   * @polymer
   * @mixinClass
   * @implements {Polymer_PropertyEffects}
   * @extends {propertyEffectsBase}
   * @unrestricted
   */

  class PropertyEffects extends propertyEffectsBase {
    constructor() {
      super();
      /** @type {boolean} */
      // Used to identify users of this mixin, ala instanceof

      this.__isPropertyEffectsClient = true;
      /** @type {boolean} */

      this.__dataClientsReady;
      /** @type {Array} */

      this.__dataPendingClients;
      /** @type {Object} */

      this.__dataToNotify;
      /** @type {Object} */

      this.__dataLinkedPaths;
      /** @type {boolean} */

      this.__dataHasPaths;
      /** @type {Object} */

      this.__dataCompoundStorage;
      /** @type {Polymer_PropertyEffects} */

      this.__dataHost;
      /** @type {!Object} */

      this.__dataTemp;
      /** @type {boolean} */

      this.__dataClientsInitialized;
      /** @type {!Object} */

      this.__data;
      /** @type {!Object|null} */

      this.__dataPending;
      /** @type {!Object} */

      this.__dataOld;
      /** @type {Object} */

      this.__computeEffects;
      /** @type {Object} */

      this.__computeInfo;
      /** @type {Object} */

      this.__reflectEffects;
      /** @type {Object} */

      this.__notifyEffects;
      /** @type {Object} */

      this.__propagateEffects;
      /** @type {Object} */

      this.__observeEffects;
      /** @type {Object} */

      this.__readOnly;
      /** @type {!TemplateInfo} */

      this.__templateInfo;
      /** @type {boolean} */

      this._overrideLegacyUndefined;
    }

    get PROPERTY_EFFECT_TYPES() {
      return TYPES;
    }
    /**
     * @override
     * @return {void}
     */


    _initializeProperties() {
      super._initializeProperties();

      this._registerHost();

      this.__dataClientsReady = false;
      this.__dataPendingClients = null;
      this.__dataToNotify = null;
      this.__dataLinkedPaths = null;
      this.__dataHasPaths = false; // May be set on instance prior to upgrade

      this.__dataCompoundStorage = this.__dataCompoundStorage || null;
      this.__dataHost = this.__dataHost || null;
      this.__dataTemp = {};
      this.__dataClientsInitialized = false;
    }

    _registerHost() {
      if (hostStack.length) {
        let host = hostStack[hostStack.length - 1];

        host._enqueueClient(this); // This ensures even non-bound elements have a host set, as
        // long as they upgrade synchronously


        this.__dataHost = host;
      }
    }
    /**
     * Overrides `PropertyAccessors` implementation to provide a
     * more efficient implementation of initializing properties from
     * the prototype on the instance.
     *
     * @override
     * @param {Object} props Properties to initialize on the prototype
     * @return {void}
     */


    _initializeProtoProperties(props) {
      this.__data = Object.create(props);
      this.__dataPending = Object.create(props);
      this.__dataOld = {};
    }
    /**
     * Overrides `PropertyAccessors` implementation to avoid setting
     * `_setProperty`'s `shouldNotify: true`.
     *
     * @override
     * @param {Object} props Properties to initialize on the instance
     * @return {void}
     */


    _initializeInstanceProperties(props) {
      let readOnly = this[TYPES.READ_ONLY];

      for (let prop in props) {
        if (!readOnly || !readOnly[prop]) {
          this.__dataPending = this.__dataPending || {};
          this.__dataOld = this.__dataOld || {};
          this.__data[prop] = this.__dataPending[prop] = props[prop];
        }
      }
    } // Prototype setup ----------------------------------------

    /**
     * Equivalent to static `addPropertyEffect` API but can be called on
     * an instance to add effects at runtime.  See that method for
     * full API docs.
     *
     * @override
     * @param {string} property Property that should trigger the effect
     * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES
     * @param {Object=} effect Effect metadata object
     * @return {void}
     * @protected
     */


    _addPropertyEffect(property, type, effect) {
      this._createPropertyAccessor(property, type == TYPES.READ_ONLY); // effects are accumulated into arrays per property based on type


      let effects = ensureOwnEffectMap(this, type, true)[property];

      if (!effects) {
        effects = this[type][property] = [];
      }

      effects.push(effect);
    }
    /**
     * Removes the given property effect.
     *
     * @override
     * @param {string} property Property the effect was associated with
     * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES
     * @param {Object=} effect Effect metadata object to remove
     * @return {void}
     */


    _removePropertyEffect(property, type, effect) {
      let effects = ensureOwnEffectMap(this, type, true)[property];
      let idx = effects.indexOf(effect);

      if (idx >= 0) {
        effects.splice(idx, 1);
      }
    }
    /**
     * Returns whether the current prototype/instance has a property effect
     * of a certain type.
     *
     * @override
     * @param {string} property Property name
     * @param {string=} type Effect type, from this.PROPERTY_EFFECT_TYPES
     * @return {boolean} True if the prototype/instance has an effect of this
     *     type
     * @protected
     */


    _hasPropertyEffect(property, type) {
      let effects = this[type];
      return Boolean(effects && effects[property]);
    }
    /**
     * Returns whether the current prototype/instance has a "read only"
     * accessor for the given property.
     *
     * @override
     * @param {string} property Property name
     * @return {boolean} True if the prototype/instance has an effect of this
     *     type
     * @protected
     */


    _hasReadOnlyEffect(property) {
      return this._hasPropertyEffect(property, TYPES.READ_ONLY);
    }
    /**
     * Returns whether the current prototype/instance has a "notify"
     * property effect for the given property.
     *
     * @override
     * @param {string} property Property name
     * @return {boolean} True if the prototype/instance has an effect of this
     *     type
     * @protected
     */


    _hasNotifyEffect(property) {
      return this._hasPropertyEffect(property, TYPES.NOTIFY);
    }
    /**
     * Returns whether the current prototype/instance has a "reflect to
     * attribute" property effect for the given property.
     *
     * @override
     * @param {string} property Property name
     * @return {boolean} True if the prototype/instance has an effect of this
     *     type
     * @protected
     */


    _hasReflectEffect(property) {
      return this._hasPropertyEffect(property, TYPES.REFLECT);
    }
    /**
     * Returns whether the current prototype/instance has a "computed"
     * property effect for the given property.
     *
     * @override
     * @param {string} property Property name
     * @return {boolean} True if the prototype/instance has an effect of this
     *     type
     * @protected
     */


    _hasComputedEffect(property) {
      return this._hasPropertyEffect(property, TYPES.COMPUTE);
    } // Runtime ----------------------------------------

    /**
     * Sets a pending property or path.  If the root property of the path in
     * question had no accessor, the path is set, otherwise it is enqueued
     * via `_setPendingProperty`.
     *
     * This function isolates relatively expensive functionality necessary
     * for the public API (`set`, `setProperties`, `notifyPath`, and property
     * change listeners via {{...}} bindings), such that it is only done
     * when paths enter the system, and not at every propagation step.  It
     * also sets a `__dataHasPaths` flag on the instance which is used to
     * fast-path slower path-matching code in the property effects host paths.
     *
     * `path` can be a path string or array of path parts as accepted by the
     * public API.
     *
     * @override
     * @param {string | !Array<number|string>} path Path to set
     * @param {*} value Value to set
     * @param {boolean=} shouldNotify Set to true if this change should
     *  cause a property notification event dispatch
     * @param {boolean=} isPathNotification If the path being set is a path
     *   notification of an already changed value, as opposed to a request
     *   to set and notify the change.  In the latter `false` case, a dirty
     *   check is performed and then the value is set to the path before
     *   enqueuing the pending property change.
     * @return {boolean} Returns true if the property/path was enqueued in
     *   the pending changes bag.
     * @protected
     */


    _setPendingPropertyOrPath(path, value, shouldNotify, isPathNotification) {
      if (isPathNotification || Object(_utils_path_js__WEBPACK_IMPORTED_MODULE_3__["root"])(Array.isArray(path) ? path[0] : path) !== path) {
        // Dirty check changes being set to a path against the actual object,
        // since this is the entry point for paths into the system; from here
        // the only dirty checks are against the `__dataTemp` cache to prevent
        // duplicate work in the same turn only. Note, if this was a notification
        // of a change already set to a path (isPathNotification: true),
        // we always let the change through and skip the `set` since it was
        // already dirty checked at the point of entry and the underlying
        // object has already been updated
        if (!isPathNotification) {
          let old = Object(_utils_path_js__WEBPACK_IMPORTED_MODULE_3__["get"])(this, path);
          path =
          /** @type {string} */
          Object(_utils_path_js__WEBPACK_IMPORTED_MODULE_3__["set"])(this, path, value); // Use property-accessor's simpler dirty check

          if (!path || !super._shouldPropertyChange(path, value, old)) {
            return false;
          }
        }

        this.__dataHasPaths = true;

        if (this._setPendingProperty(
        /**@type{string}*/
        path, value, shouldNotify)) {
          computeLinkedPaths(this,
          /**@type{string}*/
          path, value);
          return true;
        }
      } else {
        if (this.__dataHasAccessor && this.__dataHasAccessor[path]) {
          return this._setPendingProperty(
          /**@type{string}*/
          path, value, shouldNotify);
        } else {
          this[path] = value;
        }
      }

      return false;
    }
    /**
     * Applies a value to a non-Polymer element/node's property.
     *
     * The implementation makes a best-effort at binding interop:
     * Some native element properties have side-effects when
     * re-setting the same value (e.g. setting `<input>.value` resets the
     * cursor position), so we do a dirty-check before setting the value.
     * However, for better interop with non-Polymer custom elements that
     * accept objects, we explicitly re-set object changes coming from the
     * Polymer world (which may include deep object changes without the
     * top reference changing), erring on the side of providing more
     * information.
     *
     * Users may override this method to provide alternate approaches.
     *
     * @override
     * @param {!Node} node The node to set a property on
     * @param {string} prop The property to set
     * @param {*} value The value to set
     * @return {void}
     * @protected
     */


    _setUnmanagedPropertyToNode(node, prop, value) {
      // It is a judgment call that resetting primitives is
      // "bad" and resettings objects is also "good"; alternatively we could
      // implement a whitelist of tag & property values that should never
      // be reset (e.g. <input>.value && <select>.value)
      if (value !== node[prop] || typeof value == 'object') {
        // Note, className needs style scoping so this needs wrapping.
        if (prop === 'className') {
          node =
          /** @type {!Node} */
          Object(_utils_wrap_js__WEBPACK_IMPORTED_MODULE_1__["wrap"])(node);
        }

        node[prop] = value;
      }
    }
    /**
     * Overrides the `PropertiesChanged` implementation to introduce special
     * dirty check logic depending on the property & value being set:
     *
     * 1. Any value set to a path (e.g. 'obj.prop': 42 or 'obj.prop': {...})
     *    Stored in `__dataTemp`, dirty checked against `__dataTemp`
     * 2. Object set to simple property (e.g. 'prop': {...})
     *    Stored in `__dataTemp` and `__data`, dirty checked against
     *    `__dataTemp` by default implementation of `_shouldPropertyChange`
     * 3. Primitive value set to simple property (e.g. 'prop': 42)
     *    Stored in `__data`, dirty checked against `__data`
     *
     * The dirty-check is important to prevent cycles due to two-way
     * notification, but paths and objects are only dirty checked against any
     * previous value set during this turn via a "temporary cache" that is
     * cleared when the last `_propertiesChanged` exits. This is so:
     * a. any cached array paths (e.g. 'array.3.prop') may be invalidated
     *    due to array mutations like shift/unshift/splice; this is fine
     *    since path changes are dirty-checked at user entry points like `set`
     * b. dirty-checking for objects only lasts one turn to allow the user
     *    to mutate the object in-place and re-set it with the same identity
     *    and have all sub-properties re-propagated in a subsequent turn.
     *
     * The temp cache is not necessarily sufficient to prevent invalid array
     * paths, since a splice can happen during the same turn (with pathological
     * user code); we could introduce a "fixup" for temporarily cached array
     * paths if needed: https://github.com/Polymer/polymer/issues/4227
     *
     * @override
     * @param {string} property Name of the property
     * @param {*} value Value to set
     * @param {boolean=} shouldNotify True if property should fire notification
     *   event (applies only for `notify: true` properties)
     * @return {boolean} Returns true if the property changed
     */


    _setPendingProperty(property, value, shouldNotify) {
      let propIsPath = this.__dataHasPaths && Object(_utils_path_js__WEBPACK_IMPORTED_MODULE_3__["isPath"])(property);
      let prevProps = propIsPath ? this.__dataTemp : this.__data;

      if (this._shouldPropertyChange(property, value, prevProps[property])) {
        if (!this.__dataPending) {
          this.__dataPending = {};
          this.__dataOld = {};
        } // Ensure old is captured from the last turn


        if (!(property in this.__dataOld)) {
          this.__dataOld[property] = this.__data[property];
        } // Paths are stored in temporary cache (cleared at end of turn),
        // which is used for dirty-checking, all others stored in __data


        if (propIsPath) {
          this.__dataTemp[property] = value;
        } else {
          this.__data[property] = value;
        } // All changes go into pending property bag, passed to _propertiesChanged


        this.__dataPending[property] = value; // Track properties that should notify separately

        if (propIsPath || this[TYPES.NOTIFY] && this[TYPES.NOTIFY][property]) {
          this.__dataToNotify = this.__dataToNotify || {};
          this.__dataToNotify[property] = shouldNotify;
        }

        return true;
      }

      return false;
    }
    /**
     * Overrides base implementation to ensure all accessors set `shouldNotify`
     * to true, for per-property notification tracking.
     *
     * @override
     * @param {string} property Name of the property
     * @param {*} value Value to set
     * @return {void}
     */


    _setProperty(property, value) {
      if (this._setPendingProperty(property, value, true)) {
        this._invalidateProperties();
      }
    }
    /**
     * Overrides `PropertyAccessor`'s default async queuing of
     * `_propertiesChanged`: if `__dataReady` is false (has not yet been
     * manually flushed), the function no-ops; otherwise flushes
     * `_propertiesChanged` synchronously.
     *
     * @override
     * @return {void}
     */


    _invalidateProperties() {
      if (this.__dataReady) {
        this._flushProperties();
      }
    }
    /**
     * Enqueues the given client on a list of pending clients, whose
     * pending property changes can later be flushed via a call to
     * `_flushClients`.
     *
     * @override
     * @param {Object} client PropertyEffects client to enqueue
     * @return {void}
     * @protected
     */


    _enqueueClient(client) {
      this.__dataPendingClients = this.__dataPendingClients || [];

      if (client !== this) {
        this.__dataPendingClients.push(client);
      }
    }
    /**
     * Flushes any clients previously enqueued via `_enqueueClient`, causing
     * their `_flushProperties` method to run.
     *
     * @override
     * @return {void}
     * @protected
     */


    _flushClients() {
      if (!this.__dataClientsReady) {
        this.__dataClientsReady = true;

        this._readyClients(); // Override point where accessors are turned on; importantly,
        // this is after clients have fully readied, providing a guarantee
        // that any property effects occur only after all clients are ready.


        this.__dataReady = true;
      } else {
        this.__enableOrFlushClients();
      }
    } // NOTE: We ensure clients either enable or flush as appropriate. This
    // handles two corner cases:
    // (1) clients flush properly when connected/enabled before the host
    // enables; e.g.
    //   (a) Templatize stamps with no properties and does not flush and
    //   (b) the instance is inserted into dom and
    //   (c) then the instance flushes.
    // (2) clients enable properly when not connected/enabled when the host
    // flushes; e.g.
    //   (a) a template is runtime stamped and not yet connected/enabled
    //   (b) a host sets a property, causing stamped dom to flush
    //   (c) the stamped dom enables.


    __enableOrFlushClients() {
      let clients = this.__dataPendingClients;

      if (clients) {
        this.__dataPendingClients = null;

        for (let i = 0; i < clients.length; i++) {
          let client = clients[i];

          if (!client.__dataEnabled) {
            client._enableProperties();
          } else if (client.__dataPending) {
            client._flushProperties();
          }
        }
      }
    }
    /**
     * Perform any initial setup on client dom. Called before the first
     * `_flushProperties` call on client dom and before any element
     * observers are called.
     *
     * @override
     * @return {void}
     * @protected
     */


    _readyClients() {
      this.__enableOrFlushClients();
    }
    /**
     * Sets a bag of property changes to this instance, and
     * synchronously processes all effects of the properties as a batch.
     *
     * Property names must be simple properties, not paths.  Batched
     * path propagation is not supported.
     *
     * @override
     * @param {Object} props Bag of one or more key-value pairs whose key is
     *   a property and value is the new value to set for that property.
     * @param {boolean=} setReadOnly When true, any private values set in
     *   `props` will be set. By default, `setProperties` will not set
     *   `readOnly: true` root properties.
     * @return {void}
     * @public
     */


    setProperties(props, setReadOnly) {
      for (let path in props) {
        if (setReadOnly || !this[TYPES.READ_ONLY] || !this[TYPES.READ_ONLY][path]) {
          //TODO(kschaaf): explicitly disallow paths in setProperty?
          // wildcard observers currently only pass the first changed path
          // in the `info` object, and you could do some odd things batching
          // paths, e.g. {'foo.bar': {...}, 'foo': null}
          this._setPendingPropertyOrPath(path, props[path], true);
        }
      }

      this._invalidateProperties();
    }
    /**
     * Overrides `PropertyAccessors` so that property accessor
     * side effects are not enabled until after client dom is fully ready.
     * Also calls `_flushClients` callback to ensure client dom is enabled
     * that was not enabled as a result of flushing properties.
     *
     * @override
     * @return {void}
     */


    ready() {
      // It is important that `super.ready()` is not called here as it
      // immediately turns on accessors. Instead, we wait until `readyClients`
      // to enable accessors to provide a guarantee that clients are ready
      // before processing any accessors side effects.
      this._flushProperties(); // If no data was pending, `_flushProperties` will not `flushClients`
      // so ensure this is done.


      if (!this.__dataClientsReady) {
        this._flushClients();
      } // Before ready, client notifications do not trigger _flushProperties.
      // Therefore a flush is necessary here if data has been set.


      if (this.__dataPending) {
        this._flushProperties();
      }
    }
    /**
     * Implements `PropertyAccessors`'s properties changed callback.
     *
     * Runs each class of effects for the batch of changed properties in
     * a specific order (compute, propagate, reflect, observe, notify).
     *
     * @override
     * @param {!Object} currentProps Bag of all current accessor values
     * @param {?Object} changedProps Bag of properties changed since the last
     *   call to `_propertiesChanged`
     * @param {?Object} oldProps Bag of previous values for each property
     *   in `changedProps`
     * @return {void}
     */


    _propertiesChanged(currentProps, changedProps, oldProps) {
      // ----------------------------
      // let c = Object.getOwnPropertyNames(changedProps || {});
      // window.debug && console.group(this.localName + '#' + this.id + ': ' + c);
      // if (window.debug) { debugger; }
      // ----------------------------
      let hasPaths = this.__dataHasPaths;
      this.__dataHasPaths = false;
      let notifyProps; // Compute properties

      runComputedEffects(this, changedProps, oldProps, hasPaths); // Clear notify properties prior to possible reentry (propagate, observe),
      // but after computing effects have a chance to add to them

      notifyProps = this.__dataToNotify;
      this.__dataToNotify = null; // Propagate properties to clients

      this._propagatePropertyChanges(changedProps, oldProps, hasPaths); // Flush clients


      this._flushClients(); // Reflect properties


      runEffects(this, this[TYPES.REFLECT], changedProps, oldProps, hasPaths); // Observe properties

      runEffects(this, this[TYPES.OBSERVE], changedProps, oldProps, hasPaths); // Notify properties to host

      if (notifyProps) {
        runNotifyEffects(this, notifyProps, changedProps, oldProps, hasPaths);
      } // Clear temporary cache at end of turn


      if (this.__dataCounter == 1) {
        this.__dataTemp = {};
      } // ----------------------------
      // window.debug && console.groupEnd(this.localName + '#' + this.id + ': ' + c);
      // ----------------------------

    }
    /**
     * Called to propagate any property changes to stamped template nodes
     * managed by this element.
     *
     * @override
     * @param {Object} changedProps Bag of changed properties
     * @param {Object} oldProps Bag of previous values for changed properties
     * @param {boolean} hasPaths True with `props` contains one or more paths
     * @return {void}
     * @protected
     */


    _propagatePropertyChanges(changedProps, oldProps, hasPaths) {
      if (this[TYPES.PROPAGATE]) {
        runEffects(this, this[TYPES.PROPAGATE], changedProps, oldProps, hasPaths);
      }

      if (this.__templateInfo) {
        this._runEffectsForTemplate(this.__templateInfo, changedProps, oldProps, hasPaths);
      }
    }

    _runEffectsForTemplate(templateInfo, changedProps, oldProps, hasPaths) {
      const baseRunEffects = (changedProps, hasPaths) => {
        runEffects(this, templateInfo.propertyEffects, changedProps, oldProps, hasPaths, templateInfo.nodeList);

        for (let info = templateInfo.firstChild; info; info = info.nextSibling) {
          this._runEffectsForTemplate(info, changedProps, oldProps, hasPaths);
        }
      };

      if (templateInfo.runEffects) {
        templateInfo.runEffects(baseRunEffects, changedProps, hasPaths);
      } else {
        baseRunEffects(changedProps, hasPaths);
      }
    }
    /**
     * Aliases one data path as another, such that path notifications from one
     * are routed to the other.
     *
     * @override
     * @param {string | !Array<string|number>} to Target path to link.
     * @param {string | !Array<string|number>} from Source path to link.
     * @return {void}
     * @public
     */


    linkPaths(to, from) {
      to = Object(_utils_path_js__WEBPACK_IMPORTED_MODULE_3__["normalize"])(to);
      from = Object(_utils_path_js__WEBPACK_IMPORTED_MODULE_3__["normalize"])(from);
      this.__dataLinkedPaths = this.__dataLinkedPaths || {};
      this.__dataLinkedPaths[to] = from;
    }
    /**
     * Removes a data path alias previously established with `_linkPaths`.
     *
     * Note, the path to unlink should be the target (`to`) used when
     * linking the paths.
     *
     * @override
     * @param {string | !Array<string|number>} path Target path to unlink.
     * @return {void}
     * @public
     */


    unlinkPaths(path) {
      path = Object(_utils_path_js__WEBPACK_IMPORTED_MODULE_3__["normalize"])(path);

      if (this.__dataLinkedPaths) {
        delete this.__dataLinkedPaths[path];
      }
    }
    /**
     * Notify that an array has changed.
     *
     * Example:
     *
     *     this.items = [ {name: 'Jim'}, {name: 'Todd'}, {name: 'Bill'} ];
     *     ...
     *     this.items.splice(1, 1, {name: 'Sam'});
     *     this.items.push({name: 'Bob'});
     *     this.notifySplices('items', [
     *       { index: 1, removed: [{name: 'Todd'}], addedCount: 1,
     *         object: this.items, type: 'splice' },
     *       { index: 3, removed: [], addedCount: 1,
     *         object: this.items, type: 'splice'}
     *     ]);
     *
     * @param {string} path Path that should be notified.
     * @param {Array} splices Array of splice records indicating ordered
     *   changes that occurred to the array. Each record should have the
     *   following fields:
     *    * index: index at which the change occurred
     *    * removed: array of items that were removed from this index
     *    * addedCount: number of new items added at this index
     *    * object: a reference to the array in question
     *    * type: the string literal 'splice'
     *
     *   Note that splice records _must_ be normalized such that they are
     *   reported in index order (raw results from `Object.observe` are not
     *   ordered and must be normalized/merged before notifying).
     *
     * @override
     * @return {void}
     * @public
     */


    notifySplices(path, splices) {
      let info = {
        path: ''
      };
      let array =
      /** @type {Array} */
      Object(_utils_path_js__WEBPACK_IMPORTED_MODULE_3__["get"])(this, path, info);
      notifySplices(this, array, info.path, splices);
    }
    /**
     * Convenience method for reading a value from a path.
     *
     * Note, if any part in the path is undefined, this method returns
     * `undefined` (this method does not throw when dereferencing undefined
     * paths).
     *
     * @override
     * @param {(string|!Array<(string|number)>)} path Path to the value
     *   to read.  The path may be specified as a string (e.g. `foo.bar.baz`)
     *   or an array of path parts (e.g. `['foo.bar', 'baz']`).  Note that
     *   bracketed expressions are not supported; string-based path parts
     *   *must* be separated by dots.  Note that when dereferencing array
     *   indices, the index may be used as a dotted part directly
     *   (e.g. `users.12.name` or `['users', 12, 'name']`).
     * @param {Object=} root Root object from which the path is evaluated.
     * @return {*} Value at the path, or `undefined` if any part of the path
     *   is undefined.
     * @public
     */


    get(path, root) {
      return Object(_utils_path_js__WEBPACK_IMPORTED_MODULE_3__["get"])(root || this, path);
    }
    /**
     * Convenience method for setting a value to a path and notifying any
     * elements bound to the same path.
     *
     * Note, if any part in the path except for the last is undefined,
     * this method does nothing (this method does not throw when
     * dereferencing undefined paths).
     *
     * @override
     * @param {(string|!Array<(string|number)>)} path Path to the value
     *   to write.  The path may be specified as a string (e.g. `'foo.bar.baz'`)
     *   or an array of path parts (e.g. `['foo.bar', 'baz']`).  Note that
     *   bracketed expressions are not supported; string-based path parts
     *   *must* be separated by dots.  Note that when dereferencing array
     *   indices, the index may be used as a dotted part directly
     *   (e.g. `'users.12.name'` or `['users', 12, 'name']`).
     * @param {*} value Value to set at the specified path.
     * @param {Object=} root Root object from which the path is evaluated.
     *   When specified, no notification will occur.
     * @return {void}
     * @public
     */


    set(path, value, root) {
      if (root) {
        Object(_utils_path_js__WEBPACK_IMPORTED_MODULE_3__["set"])(root, path, value);
      } else {
        if (!this[TYPES.READ_ONLY] || !this[TYPES.READ_ONLY][
        /** @type {string} */
        path]) {
          if (this._setPendingPropertyOrPath(path, value, true)) {
            this._invalidateProperties();
          }
        }
      }
    }
    /**
     * Adds items onto the end of the array at the path specified.
     *
     * The arguments after `path` and return value match that of
     * `Array.prototype.push`.
     *
     * This method notifies other paths to the same array that a
     * splice occurred to the array.
     *
     * @override
     * @param {string | !Array<string|number>} path Path to array.
     * @param {...*} items Items to push onto array
     * @return {number} New length of the array.
     * @public
     */


    push(path, ...items) {
      let info = {
        path: ''
      };
      let array =
      /** @type {Array}*/
      Object(_utils_path_js__WEBPACK_IMPORTED_MODULE_3__["get"])(this, path, info);
      let len = array.length;
      let ret = array.push(...items);

      if (items.length) {
        notifySplice(this, array, info.path, len, items.length, []);
      }

      return ret;
    }
    /**
     * Removes an item from the end of array at the path specified.
     *
     * The arguments after `path` and return value match that of
     * `Array.prototype.pop`.
     *
     * This method notifies other paths to the same array that a
     * splice occurred to the array.
     *
     * @override
     * @param {string | !Array<string|number>} path Path to array.
     * @return {*} Item that was removed.
     * @public
     */


    pop(path) {
      let info = {
        path: ''
      };
      let array =
      /** @type {Array} */
      Object(_utils_path_js__WEBPACK_IMPORTED_MODULE_3__["get"])(this, path, info);
      let hadLength = Boolean(array.length);
      let ret = array.pop();

      if (hadLength) {
        notifySplice(this, array, info.path, array.length, 0, [ret]);
      }

      return ret;
    }
    /**
     * Starting from the start index specified, removes 0 or more items
     * from the array and inserts 0 or more new items in their place.
     *
     * The arguments after `path` and return value match that of
     * `Array.prototype.splice`.
     *
     * This method notifies other paths to the same array that a
     * splice occurred to the array.
     *
     * @override
     * @param {string | !Array<string|number>} path Path to array.
     * @param {number} start Index from which to start removing/inserting.
     * @param {number=} deleteCount Number of items to remove.
     * @param {...*} items Items to insert into array.
     * @return {!Array} Array of removed items.
     * @public
     */


    splice(path, start, deleteCount, ...items) {
      let info = {
        path: ''
      };
      let array =
      /** @type {Array} */
      Object(_utils_path_js__WEBPACK_IMPORTED_MODULE_3__["get"])(this, path, info); // Normalize fancy native splice handling of crazy start values

      if (start < 0) {
        start = array.length - Math.floor(-start);
      } else if (start) {
        start = Math.floor(start);
      } // array.splice does different things based on the number of arguments
      // you pass in. Therefore, array.splice(0) and array.splice(0, undefined)
      // do different things. In the former, the whole array is cleared. In the
      // latter, no items are removed.
      // This means that we need to detect whether 1. one of the arguments
      // is actually passed in and then 2. determine how many arguments
      // we should pass on to the native array.splice
      //


      let ret; // Omit any additional arguments if they were not passed in

      if (arguments.length === 2) {
        ret = array.splice(start); // Either start was undefined and the others were defined, but in this
        // case we can safely pass on all arguments
        //
        // Note: this includes the case where none of the arguments were passed in,
        // e.g. this.splice('array'). However, if both start and deleteCount
        // are undefined, array.splice will not modify the array (as expected)
      } else {
        ret = array.splice(start, deleteCount, ...items);
      } // At the end, check whether any items were passed in (e.g. insertions)
      // or if the return array contains items (e.g. deletions).
      // Only notify if items were added or deleted.


      if (items.length || ret.length) {
        notifySplice(this, array, info.path, start, items.length, ret);
      }

      return ret;
    }
    /**
     * Removes an item from the beginning of array at the path specified.
     *
     * The arguments after `path` and return value match that of
     * `Array.prototype.pop`.
     *
     * This method notifies other paths to the same array that a
     * splice occurred to the array.
     *
     * @override
     * @param {string | !Array<string|number>} path Path to array.
     * @return {*} Item that was removed.
     * @public
     */


    shift(path) {
      let info = {
        path: ''
      };
      let array =
      /** @type {Array} */
      Object(_utils_path_js__WEBPACK_IMPORTED_MODULE_3__["get"])(this, path, info);
      let hadLength = Boolean(array.length);
      let ret = array.shift();

      if (hadLength) {
        notifySplice(this, array, info.path, 0, 0, [ret]);
      }

      return ret;
    }
    /**
     * Adds items onto the beginning of the array at the path specified.
     *
     * The arguments after `path` and return value match that of
     * `Array.prototype.push`.
     *
     * This method notifies other paths to the same array that a
     * splice occurred to the array.
     *
     * @override
     * @param {string | !Array<string|number>} path Path to array.
     * @param {...*} items Items to insert info array
     * @return {number} New length of the array.
     * @public
     */


    unshift(path, ...items) {
      let info = {
        path: ''
      };
      let array =
      /** @type {Array} */
      Object(_utils_path_js__WEBPACK_IMPORTED_MODULE_3__["get"])(this, path, info);
      let ret = array.unshift(...items);

      if (items.length) {
        notifySplice(this, array, info.path, 0, items.length, []);
      }

      return ret;
    }
    /**
     * Notify that a path has changed.
     *
     * Example:
     *
     *     this.item.user.name = 'Bob';
     *     this.notifyPath('item.user.name');
     *
     * @override
     * @param {string} path Path that should be notified.
     * @param {*=} value Value at the path (optional).
     * @return {void}
     * @public
     */


    notifyPath(path, value) {
      /** @type {string} */
      let propPath;

      if (arguments.length == 1) {
        // Get value if not supplied
        let info = {
          path: ''
        };
        value = Object(_utils_path_js__WEBPACK_IMPORTED_MODULE_3__["get"])(this, path, info);
        propPath = info.path;
      } else if (Array.isArray(path)) {
        // Normalize path if needed
        propPath = Object(_utils_path_js__WEBPACK_IMPORTED_MODULE_3__["normalize"])(path);
      } else {
        propPath =
        /** @type{string} */
        path;
      }

      if (this._setPendingPropertyOrPath(propPath, value, true, true)) {
        this._invalidateProperties();
      }
    }
    /**
     * Equivalent to static `createReadOnlyProperty` API but can be called on
     * an instance to add effects at runtime.  See that method for
     * full API docs.
     *
     * @override
     * @param {string} property Property name
     * @param {boolean=} protectedSetter Creates a custom protected setter
     *   when `true`.
     * @return {void}
     * @protected
     */


    _createReadOnlyProperty(property, protectedSetter) {
      this._addPropertyEffect(property, TYPES.READ_ONLY);

      if (protectedSetter) {
        this['_set' + upper(property)] =
        /** @this {PropertyEffects} */
        function (value) {
          this._setProperty(property, value);
        };
      }
    }
    /**
     * Equivalent to static `createPropertyObserver` API but can be called on
     * an instance to add effects at runtime.  See that method for
     * full API docs.
     *
     * @override
     * @param {string} property Property name
     * @param {string|function(*,*)} method Function or name of observer method
     *     to call
     * @param {boolean=} dynamicFn Whether the method name should be included as
     *   a dependency to the effect.
     * @return {void}
     * @protected
     */


    _createPropertyObserver(property, method, dynamicFn) {
      let info = {
        property,
        method,
        dynamicFn: Boolean(dynamicFn)
      };

      this._addPropertyEffect(property, TYPES.OBSERVE, {
        fn: runObserverEffect,
        info,
        trigger: {
          name: property
        }
      });

      if (dynamicFn) {
        this._addPropertyEffect(
        /** @type {string} */
        method, TYPES.OBSERVE, {
          fn: runObserverEffect,
          info,
          trigger: {
            name: method
          }
        });
      }
    }
    /**
     * Equivalent to static `createMethodObserver` API but can be called on
     * an instance to add effects at runtime.  See that method for
     * full API docs.
     *
     * @override
     * @param {string} expression Method expression
     * @param {boolean|Object=} dynamicFn Boolean or object map indicating
     *   whether method names should be included as a dependency to the effect.
     * @return {void}
     * @protected
     */


    _createMethodObserver(expression, dynamicFn) {
      let sig = parseMethod(expression);

      if (!sig) {
        throw new Error("Malformed observer expression '" + expression + "'");
      }

      createMethodEffect(this, sig, TYPES.OBSERVE, runMethodEffect, null, dynamicFn);
    }
    /**
     * Equivalent to static `createNotifyingProperty` API but can be called on
     * an instance to add effects at runtime.  See that method for
     * full API docs.
     *
     * @override
     * @param {string} property Property name
     * @return {void}
     * @protected
     */


    _createNotifyingProperty(property) {
      this._addPropertyEffect(property, TYPES.NOTIFY, {
        fn: runNotifyEffect,
        info: {
          eventName: Object(_utils_case_map_js__WEBPACK_IMPORTED_MODULE_4__["camelToDashCase"])(property) + '-changed',
          property: property
        }
      });
    }
    /**
     * Equivalent to static `createReflectedProperty` API but can be called on
     * an instance to add effects at runtime.  See that method for
     * full API docs.
     *
     * @override
     * @param {string} property Property name
     * @return {void}
     * @protected
     * @suppress {missingProperties} go/missingfnprops
     */


    _createReflectedProperty(property) {
      let attr = this.constructor.attributeNameForProperty(property);

      if (attr[0] === '-') {
        console.warn('Property ' + property + ' cannot be reflected to attribute ' + attr + ' because "-" is not a valid starting attribute name. Use a lowercase first letter for the property instead.');
      } else {
        this._addPropertyEffect(property, TYPES.REFLECT, {
          fn: runReflectEffect,
          info: {
            attrName: attr
          }
        });
      }
    }
    /**
     * Equivalent to static `createComputedProperty` API but can be called on
     * an instance to add effects at runtime.  See that method for
     * full API docs.
     *
     * @override
     * @param {string} property Name of computed property to set
     * @param {string} expression Method expression
     * @param {boolean|Object=} dynamicFn Boolean or object map indicating
     *   whether method names should be included as a dependency to the effect.
     * @return {void}
     * @protected
     */


    _createComputedProperty(property, expression, dynamicFn) {
      let sig = parseMethod(expression);

      if (!sig) {
        throw new Error("Malformed computed expression '" + expression + "'");
      }

      const info = createMethodEffect(this, sig, TYPES.COMPUTE, runComputedEffect, property, dynamicFn); // Effects are normally stored as map of dependency->effect, but for
      // ordered computation, we also need tree of computedProp->dependencies

      ensureOwnEffectMap(this, COMPUTE_INFO)[property] = info;
    }
    /**
     * Gather the argument values for a method specified in the provided array
     * of argument metadata.
     *
     * The `path` and `value` arguments are used to fill in wildcard descriptor
     * when the method is being called as a result of a path notification.
     *
     * @param {!Array<!MethodArg>} args Array of argument metadata
     * @param {string} path Property/path name that triggered the method effect
     * @param {Object} props Bag of current property changes
     * @return {!Array<*>} Array of argument values
     * @private
     */


    _marshalArgs(args, path, props) {
      const data = this.__data;
      const values = [];

      for (let i = 0, l = args.length; i < l; i++) {
        let {
          name,
          structured,
          wildcard,
          value,
          literal
        } = args[i];

        if (!literal) {
          if (wildcard) {
            const matches = Object(_utils_path_js__WEBPACK_IMPORTED_MODULE_3__["isDescendant"])(name, path);
            const pathValue = getArgValue(data, props, matches ? path : name);
            value = {
              path: matches ? path : name,
              value: pathValue,
              base: matches ? Object(_utils_path_js__WEBPACK_IMPORTED_MODULE_3__["get"])(data, name) : pathValue
            };
          } else {
            value = structured ? getArgValue(data, props, name) : data[name];
          }
        } // When the `legacyUndefined` flag is enabled, pass a no-op value
        // so that the observer, computed property, or compound binding is aborted.


        if (_utils_settings_js__WEBPACK_IMPORTED_MODULE_7__["legacyUndefined"] && !this._overrideLegacyUndefined && value === undefined && args.length > 1) {
          return NOOP;
        }

        values[i] = value;
      }

      return values;
    } // -- static class methods ------------

    /**
     * Ensures an accessor exists for the specified property, and adds
     * to a list of "property effects" that will run when the accessor for
     * the specified property is set.  Effects are grouped by "type", which
     * roughly corresponds to a phase in effect processing.  The effect
     * metadata should be in the following form:
     *
     *     {
     *       fn: effectFunction, // Reference to function to call to perform effect
     *       info: { ... }       // Effect metadata passed to function
     *       trigger: {          // Optional triggering metadata; if not provided
     *         name: string      // the property is treated as a wildcard
     *         structured: boolean
     *         wildcard: boolean
     *       }
     *     }
     *
     * Effects are called from `_propertiesChanged` in the following order by
     * type:
     *
     * 1. COMPUTE
     * 2. PROPAGATE
     * 3. REFLECT
     * 4. OBSERVE
     * 5. NOTIFY
     *
     * Effect functions are called with the following signature:
     *
     *     effectFunction(inst, path, props, oldProps, info, hasPaths)
     *
     * @param {string} property Property that should trigger the effect
     * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES
     * @param {Object=} effect Effect metadata object
     * @return {void}
     * @protected
     * @nocollapse
     */


    static addPropertyEffect(property, type, effect) {
      this.prototype._addPropertyEffect(property, type, effect);
    }
    /**
     * Creates a single-property observer for the given property.
     *
     * @param {string} property Property name
     * @param {string|function(*,*)} method Function or name of observer method to call
     * @param {boolean=} dynamicFn Whether the method name should be included as
     *   a dependency to the effect.
     * @return {void}
     * @protected
     * @nocollapse
     */


    static createPropertyObserver(property, method, dynamicFn) {
      this.prototype._createPropertyObserver(property, method, dynamicFn);
    }
    /**
     * Creates a multi-property "method observer" based on the provided
     * expression, which should be a string in the form of a normal JavaScript
     * function signature: `'methodName(arg1, [..., argn])'`.  Each argument
     * should correspond to a property or path in the context of this
     * prototype (or instance), or may be a literal string or number.
     *
     * @param {string} expression Method expression
     * @param {boolean|Object=} dynamicFn Boolean or object map indicating
     * @return {void}
     *   whether method names should be included as a dependency to the effect.
     * @protected
     * @nocollapse
     */


    static createMethodObserver(expression, dynamicFn) {
      this.prototype._createMethodObserver(expression, dynamicFn);
    }
    /**
     * Causes the setter for the given property to dispatch `<property>-changed`
     * events to notify of changes to the property.
     *
     * @param {string} property Property name
     * @return {void}
     * @protected
     * @nocollapse
     */


    static createNotifyingProperty(property) {
      this.prototype._createNotifyingProperty(property);
    }
    /**
     * Creates a read-only accessor for the given property.
     *
     * To set the property, use the protected `_setProperty` API.
     * To create a custom protected setter (e.g. `_setMyProp()` for
     * property `myProp`), pass `true` for `protectedSetter`.
     *
     * Note, if the property will have other property effects, this method
     * should be called first, before adding other effects.
     *
     * @param {string} property Property name
     * @param {boolean=} protectedSetter Creates a custom protected setter
     *   when `true`.
     * @return {void}
     * @protected
     * @nocollapse
     */


    static createReadOnlyProperty(property, protectedSetter) {
      this.prototype._createReadOnlyProperty(property, protectedSetter);
    }
    /**
     * Causes the setter for the given property to reflect the property value
     * to a (dash-cased) attribute of the same name.
     *
     * @param {string} property Property name
     * @return {void}
     * @protected
     * @nocollapse
     */


    static createReflectedProperty(property) {
      this.prototype._createReflectedProperty(property);
    }
    /**
     * Creates a computed property whose value is set to the result of the
     * method described by the given `expression` each time one or more
     * arguments to the method changes.  The expression should be a string
     * in the form of a normal JavaScript function signature:
     * `'methodName(arg1, [..., argn])'`
     *
     * @param {string} property Name of computed property to set
     * @param {string} expression Method expression
     * @param {boolean|Object=} dynamicFn Boolean or object map indicating whether
     *   method names should be included as a dependency to the effect.
     * @return {void}
     * @protected
     * @nocollapse
     */


    static createComputedProperty(property, expression, dynamicFn) {
      this.prototype._createComputedProperty(property, expression, dynamicFn);
    }
    /**
     * Parses the provided template to ensure binding effects are created
     * for them, and then ensures property accessors are created for any
     * dependent properties in the template.  Binding effects for bound
     * templates are stored in a linked list on the instance so that
     * templates can be efficiently stamped and unstamped.
     *
     * @param {!HTMLTemplateElement} template Template containing binding
     *   bindings
     * @return {!TemplateInfo} Template metadata object
     * @protected
     * @nocollapse
     */


    static bindTemplate(template) {
      return this.prototype._bindTemplate(template);
    } // -- binding ----------------------------------------------

    /*
     * Overview of binding flow:
     *
     * During finalization (`instanceBinding==false`, `wasPreBound==false`):
     *  `_bindTemplate(t, false)` called directly during finalization - parses
     *  the template (for the first time), and then assigns that _prototypical_
     *  template info to `__preboundTemplateInfo` _on the prototype_; note in
     *  this case `wasPreBound` is false; this is the first time we're binding
     *  it, thus we create accessors.
     *
     * During first stamping (`instanceBinding==true`, `wasPreBound==true`):
     *   `_stampTemplate` calls `_bindTemplate(t, true)`: the `templateInfo`
     *   returned matches the prebound one, and so this is `wasPreBound == true`
     *   state; thus we _skip_ creating accessors, but _do_ create an instance
     *   of the template info to serve as the start of our linked list (needs to
     *   be an instance, not the prototypical one, so that we can add `nodeList`
     *   to it to contain the `nodeInfo`-ordered list of instance nodes for
     *   bindings, and so we can chain runtime-stamped template infos off of
     *   it). At this point, the call to `_stampTemplate` calls
     *   `applyTemplateInfo` for each nested `<template>` found during parsing
     *   to hand prototypical `_templateInfo` to them; we also pass the _parent_
     *   `templateInfo` to the `<template>` so that we have the instance-time
     *   parent to link the `templateInfo` under in the case it was
     *   runtime-stamped.
     *
     * During subsequent runtime stamping (`instanceBinding==true`,
     *   `wasPreBound==false`): `_stampTemplate` calls `_bindTemplate(t, true)`
     *   - here `templateInfo` is guaranteed to _not_ match the prebound one,
     *   because it was either a different template altogether, or even if it
     *   was the same template, the step above created a instance of the info;
     *   in this case `wasPreBound == false`, so we _do_ create accessors, _and_
     *   link a instance into the linked list.
     */

    /**
     * Equivalent to static `bindTemplate` API but can be called on an instance
     * to add effects at runtime.  See that method for full API docs.
     *
     * This method may be called on the prototype (for prototypical template
     * binding, to avoid creating accessors every instance) once per prototype,
     * and will be called with `runtimeBinding: true` by `_stampTemplate` to
     * create and link an instance of the template metadata associated with a
     * particular stamping.
     *
     * @override
     * @param {!HTMLTemplateElement} template Template containing binding
     * bindings
     * @param {boolean=} instanceBinding When false (default), performs
     * "prototypical" binding of the template and overwrites any previously
     * bound template for the class. When true (as passed from
     * `_stampTemplate`), the template info is instanced and linked into the
     * list of bound templates.
     * @return {!TemplateInfo} Template metadata object; for `runtimeBinding`,
     * this is an instance of the prototypical template info
     * @protected
     * @suppress {missingProperties} go/missingfnprops
     */


    _bindTemplate(template, instanceBinding) {
      let templateInfo = this.constructor._parseTemplate(template);

      let wasPreBound = this.__preBoundTemplateInfo == templateInfo; // Optimization: since this is called twice for proto-bound templates,
      // don't attempt to recreate accessors if this template was pre-bound

      if (!wasPreBound) {
        for (let prop in templateInfo.propertyEffects) {
          this._createPropertyAccessor(prop);
        }
      }

      if (instanceBinding) {
        // For instance-time binding, create instance of template metadata
        // and link into tree of templates if necessary
        templateInfo =
        /** @type {!TemplateInfo} */
        Object.create(templateInfo);
        templateInfo.wasPreBound = wasPreBound;

        if (!this.__templateInfo) {
          // Set the info to the root of the tree
          this.__templateInfo = templateInfo;
        } else {
          // Append this template info onto the end of its parent template's
          // list, which will determine the tree structure via which property
          // effects are run; if this template was not nested in another
          // template, use the root template (the first stamped one) as the
          // parent. Note, `parent` is the `templateInfo` instance for this
          // template's parent (containing) template, which was set up in
          // `applyTemplateInfo`.  While a given template's `parent` is set
          // apriori, it is only added to the parent's child list at the point
          // that it is being bound, since a template may or may not ever be
          // stamped, and may be stamped more than once (in which case instances
          // of the template info will be in the tree under its parent more than
          // once).
          const parent = template._parentTemplateInfo || this.__templateInfo;
          const previous = parent.lastChild;
          templateInfo.parent = parent;
          parent.lastChild = templateInfo;
          templateInfo.previousSibling = previous;

          if (previous) {
            previous.nextSibling = templateInfo;
          } else {
            parent.firstChild = templateInfo;
          }
        }
      } else {
        this.__preBoundTemplateInfo = templateInfo;
      }

      return templateInfo;
    }
    /**
     * Adds a property effect to the given template metadata, which is run
     * at the "propagate" stage of `_propertiesChanged` when the template
     * has been bound to the element via `_bindTemplate`.
     *
     * The `effect` object should match the format in `_addPropertyEffect`.
     *
     * @param {Object} templateInfo Template metadata to add effect to
     * @param {string} prop Property that should trigger the effect
     * @param {Object=} effect Effect metadata object
     * @return {void}
     * @protected
     * @nocollapse
     */


    static _addTemplatePropertyEffect(templateInfo, prop, effect) {
      let hostProps = templateInfo.hostProps = templateInfo.hostProps || {};
      hostProps[prop] = true;
      let effects = templateInfo.propertyEffects = templateInfo.propertyEffects || {};
      let propEffects = effects[prop] = effects[prop] || [];
      propEffects.push(effect);
    }
    /**
     * Stamps the provided template and performs instance-time setup for
     * Polymer template features, including data bindings, declarative event
     * listeners, and the `this.$` map of `id`'s to nodes.  A document fragment
     * is returned containing the stamped DOM, ready for insertion into the
     * DOM.
     *
     * This method may be called more than once; however note that due to
     * `shadycss` polyfill limitations, only styles from templates prepared
     * using `ShadyCSS.prepareTemplate` will be correctly polyfilled (scoped
     * to the shadow root and support CSS custom properties), and note that
     * `ShadyCSS.prepareTemplate` may only be called once per element. As such,
     * any styles required by in runtime-stamped templates must be included
     * in the main element template.
     *
     * @param {!HTMLTemplateElement} template Template to stamp
     * @param {TemplateInfo=} templateInfo Optional bound template info associated
     *   with the template to be stamped; if omitted the template will be
     *   automatically bound.
     * @return {!StampedTemplate} Cloned template content
     * @override
     * @protected
     */


    _stampTemplate(template, templateInfo) {
      templateInfo = templateInfo ||
      /** @type {!TemplateInfo} */
      this._bindTemplate(template, true); // Ensures that created dom is `_enqueueClient`'d to this element so
      // that it can be flushed on next call to `_flushProperties`

      hostStack.push(this);

      let dom = super._stampTemplate(template, templateInfo);

      hostStack.pop(); // Add template-instance-specific data to instanced templateInfo

      templateInfo.nodeList = dom.nodeList; // Capture child nodes to allow unstamping of non-prototypical templates

      if (!templateInfo.wasPreBound) {
        let nodes = templateInfo.childNodes = [];

        for (let n = dom.firstChild; n; n = n.nextSibling) {
          nodes.push(n);
        }
      }

      dom.templateInfo = templateInfo; // Setup compound storage, 2-way listeners, and dataHost for bindings

      setupBindings(this, templateInfo); // Flush properties into template nodes; the check on `__dataClientsReady`
      // ensures we don't needlessly run effects for an element's initial
      // prototypical template stamping since they will happen as a part of the
      // first call to `_propertiesChanged`. This flag is set to true
      // after running the initial propagate effects, and immediately before
      // flushing clients. Since downstream clients could cause stamping on
      // this host (e.g. a fastDomIf `dom-if` being forced to render
      // synchronously), this flag ensures effects for runtime-stamped templates
      // are run at this point during the initial element boot-up.

      if (this.__dataClientsReady) {
        this._runEffectsForTemplate(templateInfo, this.__data, null, false);

        this._flushClients();
      }

      return dom;
    }
    /**
     * Removes and unbinds the nodes previously contained in the provided
     * DocumentFragment returned from `_stampTemplate`.
     *
     * @override
     * @param {!StampedTemplate} dom DocumentFragment previously returned
     *   from `_stampTemplate` associated with the nodes to be removed
     * @return {void}
     * @protected
     */


    _removeBoundDom(dom) {
      // Unlink template info; Note that while the child is unlinked from its
      // parent list, a template's `parent` reference is never removed, since
      // this is is determined by the tree structure and applied at
      // `applyTemplateInfo` time.
      const templateInfo = dom.templateInfo;
      const {
        previousSibling,
        nextSibling,
        parent
      } = templateInfo;

      if (previousSibling) {
        previousSibling.nextSibling = nextSibling;
      } else if (parent) {
        parent.firstChild = nextSibling;
      }

      if (nextSibling) {
        nextSibling.previousSibling = previousSibling;
      } else if (parent) {
        parent.lastChild = previousSibling;
      }

      templateInfo.nextSibling = templateInfo.previousSibling = null; // Remove stamped nodes

      let nodes = templateInfo.childNodes;

      for (let i = 0; i < nodes.length; i++) {
        let node = nodes[i];
        Object(_utils_wrap_js__WEBPACK_IMPORTED_MODULE_1__["wrap"])(Object(_utils_wrap_js__WEBPACK_IMPORTED_MODULE_1__["wrap"])(node).parentNode).removeChild(node);
      }
    }
    /**
     * Overrides default `TemplateStamp` implementation to add support for
     * parsing bindings from `TextNode`'s' `textContent`.  A `bindings`
     * array is added to `nodeInfo` and populated with binding metadata
     * with information capturing the binding target, and a `parts` array
     * with one or more metadata objects capturing the source(s) of the
     * binding.
     *
     * @param {Node} node Node to parse
     * @param {TemplateInfo} templateInfo Template metadata for current template
     * @param {NodeInfo} nodeInfo Node metadata for current template node
     * @return {boolean} `true` if the visited node added node-specific
     *   metadata to `nodeInfo`
     * @protected
     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
     * @nocollapse
     */


    static _parseTemplateNode(node, templateInfo, nodeInfo) {
      // TODO(https://github.com/google/closure-compiler/issues/3240):
      //     Change back to just super.methodCall()
      let noted = propertyEffectsBase._parseTemplateNode.call(this, node, templateInfo, nodeInfo);

      if (node.nodeType === Node.TEXT_NODE) {
        let parts = this._parseBindings(node.textContent, templateInfo);

        if (parts) {
          // Initialize the textContent with any literal parts
          // NOTE: default to a space here so the textNode remains; some browsers
          // (IE) omit an empty textNode following cloneNode/importNode.
          node.textContent = literalFromParts(parts) || ' ';
          addBinding(this, templateInfo, nodeInfo, 'text', 'textContent', parts);
          noted = true;
        }
      }

      return noted;
    }
    /**
     * Overrides default `TemplateStamp` implementation to add support for
     * parsing bindings from attributes.  A `bindings`
     * array is added to `nodeInfo` and populated with binding metadata
     * with information capturing the binding target, and a `parts` array
     * with one or more metadata objects capturing the source(s) of the
     * binding.
     *
     * @param {Element} node Node to parse
     * @param {TemplateInfo} templateInfo Template metadata for current template
     * @param {NodeInfo} nodeInfo Node metadata for current template node
     * @param {string} name Attribute name
     * @param {string} value Attribute value
     * @return {boolean} `true` if the visited node added node-specific
     *   metadata to `nodeInfo`
     * @protected
     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
     * @nocollapse
     */


    static _parseTemplateNodeAttribute(node, templateInfo, nodeInfo, name, value) {
      let parts = this._parseBindings(value, templateInfo);

      if (parts) {
        // Attribute or property
        let origName = name;
        let kind = 'property'; // The only way we see a capital letter here is if the attr has
        // a capital letter in it per spec. In this case, to make sure
        // this binding works, we go ahead and make the binding to the attribute.

        if (capitalAttributeRegex.test(name)) {
          kind = 'attribute';
        } else if (name[name.length - 1] == '$') {
          name = name.slice(0, -1);
          kind = 'attribute';
        } // Initialize attribute bindings with any literal parts


        let literal = literalFromParts(parts);

        if (literal && kind == 'attribute') {
          // Ensure a ShadyCSS template scoped style is not removed
          // when a class$ binding's initial literal value is set.
          if (name == 'class' && node.hasAttribute('class')) {
            literal += ' ' + node.getAttribute(name);
          }

          node.setAttribute(name, literal);
        } // support disable-upgrade


        if (kind == 'attribute' && origName == 'disable-upgrade$') {
          node.setAttribute(name, '');
        } // Clear attribute before removing, since IE won't allow removing
        // `value` attribute if it previously had a value (can't
        // unconditionally set '' before removing since attributes with `$`
        // can't be set using setAttribute)


        if (node.localName === 'input' && origName === 'value') {
          node.setAttribute(origName, '');
        } // Remove annotation


        node.removeAttribute(origName); // Case hackery: attributes are lower-case, but bind targets
        // (properties) are case sensitive. Gambit is to map dash-case to
        // camel-case: `foo-bar` becomes `fooBar`.
        // Attribute bindings are excepted.

        if (kind === 'property') {
          name = Object(_utils_case_map_js__WEBPACK_IMPORTED_MODULE_4__["dashToCamelCase"])(name);
        }

        addBinding(this, templateInfo, nodeInfo, kind, name, parts, literal);
        return true;
      } else {
        // TODO(https://github.com/google/closure-compiler/issues/3240):
        //     Change back to just super.methodCall()
        return propertyEffectsBase._parseTemplateNodeAttribute.call(this, node, templateInfo, nodeInfo, name, value);
      }
    }
    /**
     * Overrides default `TemplateStamp` implementation to add support for
     * binding the properties that a nested template depends on to the template
     * as `_host_<property>`.
     *
     * @param {Node} node Node to parse
     * @param {TemplateInfo} templateInfo Template metadata for current template
     * @param {NodeInfo} nodeInfo Node metadata for current template node
     * @return {boolean} `true` if the visited node added node-specific
     *   metadata to `nodeInfo`
     * @protected
     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
     * @nocollapse
     */


    static _parseTemplateNestedTemplate(node, templateInfo, nodeInfo) {
      // TODO(https://github.com/google/closure-compiler/issues/3240):
      //     Change back to just super.methodCall()
      let noted = propertyEffectsBase._parseTemplateNestedTemplate.call(this, node, templateInfo, nodeInfo);

      const parent = node.parentNode;
      const nestedTemplateInfo = nodeInfo.templateInfo;
      const isDomIf = parent.localName === 'dom-if';
      const isDomRepeat = parent.localName === 'dom-repeat'; // Remove nested template and redirect its host bindings & templateInfo
      // onto the parent (dom-if/repeat element)'s nodeInfo

      if (_utils_settings_js__WEBPACK_IMPORTED_MODULE_7__["removeNestedTemplates"] && (isDomIf || isDomRepeat)) {
        parent.removeChild(node); // Use the parent's nodeInfo (for the dom-if/repeat) to record the
        // templateInfo, and use that for any host property bindings below

        nodeInfo = nodeInfo.parentInfo;
        nodeInfo.templateInfo = nestedTemplateInfo; // Ensure the parent dom-if/repeat is noted since it now may have host
        // bindings; it may not have been if it did not have its own bindings

        nodeInfo.noted = true;
        noted = false;
      } // Merge host props into outer template and add bindings


      let hostProps = nestedTemplateInfo.hostProps;

      if (_utils_settings_js__WEBPACK_IMPORTED_MODULE_7__["fastDomIf"] && isDomIf) {
        // `fastDomIf` mode uses runtime-template stamping to add accessors/
        // effects to properties used in its template; as such we don't need to
        // tax the host element with `_host_` bindings for the `dom-if`.
        // However, in the event it is nested in a `dom-repeat`, it is still
        // important that its host properties are added to the
        // TemplateInstance's `hostProps` so that they are forwarded to the
        // TemplateInstance.
        if (hostProps) {
          templateInfo.hostProps = Object.assign(templateInfo.hostProps || {}, hostProps); // Ensure the dom-if is noted so that it has a __dataHost, since
          // `fastDomIf` uses the host for runtime template stamping; note this
          // was already ensured above in the `removeNestedTemplates` case

          if (!_utils_settings_js__WEBPACK_IMPORTED_MODULE_7__["removeNestedTemplates"]) {
            nodeInfo.parentInfo.noted = true;
          }
        }
      } else {
        let mode = '{';

        for (let source in hostProps) {
          let parts = [{
            mode,
            source,
            dependencies: [source],
            hostProp: true
          }];
          addBinding(this, templateInfo, nodeInfo, 'property', '_host_' + source, parts);
        }
      }

      return noted;
    }
    /**
     * Called to parse text in a template (either attribute values or
     * textContent) into binding metadata.
     *
     * Any overrides of this method should return an array of binding part
     * metadata  representing one or more bindings found in the provided text
     * and any "literal" text in between.  Any non-literal parts will be passed
     * to `_evaluateBinding` when any dependencies change.  The only required
     * fields of each "part" in the returned array are as follows:
     *
     * - `dependencies` - Array containing trigger metadata for each property
     *   that should trigger the binding to update
     * - `literal` - String containing text if the part represents a literal;
     *   in this case no `dependencies` are needed
     *
     * Additional metadata for use by `_evaluateBinding` may be provided in
     * each part object as needed.
     *
     * The default implementation handles the following types of bindings
     * (one or more may be intermixed with literal strings):
     * - Property binding: `[[prop]]`
     * - Path binding: `[[object.prop]]`
     * - Negated property or path bindings: `[[!prop]]` or `[[!object.prop]]`
     * - Two-way property or path bindings (supports negation):
     *   `{{prop}}`, `{{object.prop}}`, `{{!prop}}` or `{{!object.prop}}`
     * - Inline computed method (supports negation):
     *   `[[compute(a, 'literal', b)]]`, `[[!compute(a, 'literal', b)]]`
     *
     * The default implementation uses a regular expression for best
     * performance. However, the regular expression uses a white-list of
     * allowed characters in a data-binding, which causes problems for
     * data-bindings that do use characters not in this white-list.
     *
     * Instead of updating the white-list with all allowed characters,
     * there is a StrictBindingParser (see lib/mixins/strict-binding-parser)
     * that uses a state machine instead. This state machine is able to handle
     * all characters. However, it is slightly less performant, therefore we
     * extracted it into a separate optional mixin.
     *
     * @param {string} text Text to parse from attribute or textContent
     * @param {Object} templateInfo Current template metadata
     * @return {Array<!BindingPart>} Array of binding part metadata
     * @protected
     * @nocollapse
     */


    static _parseBindings(text, templateInfo) {
      let parts = [];
      let lastIndex = 0;
      let m; // Example: "literal1{{prop}}literal2[[!compute(foo,bar)]]final"
      // Regex matches:
      //        Iteration 1:  Iteration 2:
      // m[1]: '{{'          '[['
      // m[2]: ''            '!'
      // m[3]: 'prop'        'compute(foo,bar)'

      while ((m = bindingRegex.exec(text)) !== null) {
        // Add literal part
        if (m.index > lastIndex) {
          parts.push({
            literal: text.slice(lastIndex, m.index)
          });
        } // Add binding part


        let mode = m[1][0];
        let negate = Boolean(m[2]);
        let source = m[3].trim();
        let customEvent = false,
            notifyEvent = '',
            colon = -1;

        if (mode == '{' && (colon = source.indexOf('::')) > 0) {
          notifyEvent = source.substring(colon + 2);
          source = source.substring(0, colon);
          customEvent = true;
        }

        let signature = parseMethod(source);
        let dependencies = [];

        if (signature) {
          // Inline computed function
          let {
            args,
            methodName
          } = signature;

          for (let i = 0; i < args.length; i++) {
            let arg = args[i];

            if (!arg.literal) {
              dependencies.push(arg);
            }
          }

          let dynamicFns = templateInfo.dynamicFns;

          if (dynamicFns && dynamicFns[methodName] || signature.static) {
            dependencies.push(methodName);
            signature.dynamicFn = true;
          }
        } else {
          // Property or path
          dependencies.push(source);
        }

        parts.push({
          source,
          mode,
          negate,
          customEvent,
          signature,
          dependencies,
          event: notifyEvent
        });
        lastIndex = bindingRegex.lastIndex;
      } // Add a final literal part


      if (lastIndex && lastIndex < text.length) {
        let literal = text.substring(lastIndex);

        if (literal) {
          parts.push({
            literal: literal
          });
        }
      }

      if (parts.length) {
        return parts;
      } else {
        return null;
      }
    }
    /**
     * Called to evaluate a previously parsed binding part based on a set of
     * one or more changed dependencies.
     *
     * @param {!Polymer_PropertyEffects} inst Element that should be used as
     *     scope for binding dependencies
     * @param {BindingPart} part Binding part metadata
     * @param {string} path Property/path that triggered this effect
     * @param {Object} props Bag of current property changes
     * @param {Object} oldProps Bag of previous values for changed properties
     * @param {boolean} hasPaths True with `props` contains one or more paths
     * @return {*} Value the binding part evaluated to
     * @protected
     * @nocollapse
     */


    static _evaluateBinding(inst, part, path, props, oldProps, hasPaths) {
      let value;

      if (part.signature) {
        value = runMethodEffect(inst, path, props, oldProps, part.signature);
      } else if (path != part.source) {
        value = Object(_utils_path_js__WEBPACK_IMPORTED_MODULE_3__["get"])(inst, part.source);
      } else {
        if (hasPaths && Object(_utils_path_js__WEBPACK_IMPORTED_MODULE_3__["isPath"])(path)) {
          value = Object(_utils_path_js__WEBPACK_IMPORTED_MODULE_3__["get"])(inst, path);
        } else {
          value = inst.__data[path];
        }
      }

      if (part.negate) {
        value = !value;
      }

      return value;
    }

  }

  return PropertyEffects;
});
/**
 * Stack for enqueuing client dom created by a host element.
 *
 * By default elements are flushed via `_flushProperties` when
 * `connectedCallback` is called. Elements attach their client dom to
 * themselves at `ready` time which results from this first flush.
 * This provides an ordering guarantee that the client dom an element
 * creates is flushed before the element itself (i.e. client `ready`
 * fires before host `ready`).
 *
 * However, if `_flushProperties` is called *before* an element is connected,
 * as for example `Templatize` does, this ordering guarantee cannot be
 * satisfied because no elements are connected. (Note: Bound elements that
 * receive data do become enqueued clients and are properly ordered but
 * unbound elements are not.)
 *
 * To maintain the desired "client before host" ordering guarantee for this
 * case we rely on the "host stack. Client nodes registers themselves with
 * the creating host element when created. This ensures that all client dom
 * is readied in the proper order, maintaining the desired guarantee.
 *
 * @private
 */

const hostStack = [];

/***/ }),

/***/ "./node_modules/@polymer/polymer/lib/mixins/template-stamp.js":
/*!********************************************************************!*\
  !*** ./node_modules/@polymer/polymer/lib/mixins/template-stamp.js ***!
  \********************************************************************/
/*! exports provided: TemplateStamp */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TemplateStamp", function() { return TemplateStamp; });
/* harmony import */ var _utils_boot_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/boot.js */ "./node_modules/@polymer/polymer/lib/utils/boot.js");
/* harmony import */ var _utils_mixin_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/mixin.js */ "./node_modules/@polymer/polymer/lib/utils/mixin.js");
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

 // 1.x backwards-compatible auto-wrapper for template type extensions
// This is a clear layering violation and gives favored-nation status to
// dom-if and dom-repeat templates.  This is a conceit we're choosing to keep
// a.) to ease 1.x backwards-compatibility due to loss of `is`, and
// b.) to maintain if/repeat capability in parser-constrained elements
//     (e.g. table, select) in lieu of native CE type extensions without
//     massive new invention in this space (e.g. directive system)

const templateExtensions = {
  'dom-if': true,
  'dom-repeat': true
};
let placeholderBugDetect = false;
let placeholderBug = false;

function hasPlaceholderBug() {
  if (!placeholderBugDetect) {
    placeholderBugDetect = true;
    const t = document.createElement('textarea');
    t.placeholder = 'a';
    placeholderBug = t.placeholder === t.textContent;
  }

  return placeholderBug;
}
/**
 * Some browsers have a bug with textarea, where placeholder text is copied as
 * a textnode child of the textarea.
 *
 * If the placeholder is a binding, this can break template stamping in two
 * ways.
 *
 * One issue is that when the `placeholder` attribute is removed when the
 * binding is processed, the textnode child of the textarea is deleted, and the
 * template info tries to bind into that node.
 *
 * With `legacyOptimizations` in use, when the template is stamped and the
 * `textarea.textContent` binding is processed, no corresponding node is found
 * because it was removed during parsing. An exception is generated when this
 * binding is updated.
 *
 * With `legacyOptimizations` not in use, the template is cloned before
 * processing and this changes the above behavior. The cloned template also has
 * a value property set to the placeholder and textContent. This prevents the
 * removal of the textContent when the placeholder attribute is removed.
 * Therefore the exception does not occur. However, there is an extra
 * unnecessary binding.
 *
 * @param {!Node} node Check node for placeholder bug
 * @return {void}
 */


function fixPlaceholder(node) {
  if (hasPlaceholderBug() && node.localName === 'textarea' && node.placeholder && node.placeholder === node.textContent) {
    node.textContent = null;
  }
}

function wrapTemplateExtension(node) {
  let is = node.getAttribute('is');

  if (is && templateExtensions[is]) {
    let t = node;
    t.removeAttribute('is');
    node = t.ownerDocument.createElement(is);
    t.parentNode.replaceChild(node, t);
    node.appendChild(t);

    while (t.attributes.length) {
      node.setAttribute(t.attributes[0].name, t.attributes[0].value);
      t.removeAttribute(t.attributes[0].name);
    }
  }

  return node;
}

function findTemplateNode(root, nodeInfo) {
  // recursively ascend tree until we hit root
  let parent = nodeInfo.parentInfo && findTemplateNode(root, nodeInfo.parentInfo); // unwind the stack, returning the indexed node at each level

  if (parent) {
    // note: marginally faster than indexing via childNodes
    // (http://jsperf.com/childnodes-lookup)
    for (let n = parent.firstChild, i = 0; n; n = n.nextSibling) {
      if (nodeInfo.parentIndex === i++) {
        return n;
      }
    }
  } else {
    return root;
  }
} // construct `$` map (from id annotations)


function applyIdToMap(inst, map, node, nodeInfo) {
  if (nodeInfo.id) {
    map[nodeInfo.id] = node;
  }
} // install event listeners (from event annotations)


function applyEventListener(inst, node, nodeInfo) {
  if (nodeInfo.events && nodeInfo.events.length) {
    for (let j = 0, e$ = nodeInfo.events, e; j < e$.length && (e = e$[j]); j++) {
      inst._addMethodEventListenerToNode(node, e.name, e.value, inst);
    }
  }
} // push configuration references at configure time


function applyTemplateInfo(inst, node, nodeInfo, parentTemplateInfo) {
  if (nodeInfo.templateInfo) {
    // Give the node an instance of this templateInfo and set its parent
    node._templateInfo = nodeInfo.templateInfo;
    node._parentTemplateInfo = parentTemplateInfo;
  }
}

function createNodeEventHandler(context, eventName, methodName) {
  // Instances can optionally have a _methodHost which allows redirecting where
  // to find methods. Currently used by `templatize`.
  context = context._methodHost || context;

  let handler = function (e) {
    if (context[methodName]) {
      context[methodName](e, e.detail);
    } else {
      console.warn('listener method `' + methodName + '` not defined');
    }
  };

  return handler;
}
/**
 * Element mixin that provides basic template parsing and stamping, including
 * the following template-related features for stamped templates:
 *
 * - Declarative event listeners (`on-eventname="listener"`)
 * - Map of node id's to stamped node instances (`this.$.id`)
 * - Nested template content caching/removal and re-installation (performance
 *   optimization)
 *
 * @mixinFunction
 * @polymer
 * @summary Element class mixin that provides basic template parsing and stamping
 */


const TemplateStamp = Object(_utils_mixin_js__WEBPACK_IMPORTED_MODULE_1__["dedupingMixin"])(
/**
 * @template T
 * @param {function(new:T)} superClass Class to apply mixin to.
 * @return {function(new:T)} superClass with mixin applied.
 */
superClass => {
  /**
   * @polymer
   * @mixinClass
   * @implements {Polymer_TemplateStamp}
   */
  class TemplateStamp extends superClass {
    /**
     * Scans a template to produce template metadata.
     *
     * Template-specific metadata are stored in the object returned, and node-
     * specific metadata are stored in objects in its flattened `nodeInfoList`
     * array.  Only nodes in the template that were parsed as nodes of
     * interest contain an object in `nodeInfoList`.  Each `nodeInfo` object
     * contains an `index` (`childNodes` index in parent) and optionally
     * `parent`, which points to node info of its parent (including its index).
     *
     * The template metadata object returned from this method has the following
     * structure (many fields optional):
     *
     * ```js
     *   {
     *     // Flattened list of node metadata (for nodes that generated metadata)
     *     nodeInfoList: [
     *       {
     *         // `id` attribute for any nodes with id's for generating `$` map
     *         id: {string},
     *         // `on-event="handler"` metadata
     *         events: [
     *           {
     *             name: {string},   // event name
     *             value: {string},  // handler method name
     *           }, ...
     *         ],
     *         // Notes when the template contained a `<slot>` for shady DOM
     *         // optimization purposes
     *         hasInsertionPoint: {boolean},
     *         // For nested `<template>`` nodes, nested template metadata
     *         templateInfo: {object}, // nested template metadata
     *         // Metadata to allow efficient retrieval of instanced node
     *         // corresponding to this metadata
     *         parentInfo: {number},   // reference to parent nodeInfo>
     *         parentIndex: {number},  // index in parent's `childNodes` collection
     *         infoIndex: {number},    // index of this `nodeInfo` in `templateInfo.nodeInfoList`
     *       },
     *       ...
     *     ],
     *     // When true, the template had the `strip-whitespace` attribute
     *     // or was nested in a template with that setting
     *     stripWhitespace: {boolean},
     *     // For nested templates, nested template content is moved into
     *     // a document fragment stored here; this is an optimization to
     *     // avoid the cost of nested template cloning
     *     content: {DocumentFragment}
     *   }
     * ```
     *
     * This method kicks off a recursive treewalk as follows:
     *
     * ```
     *    _parseTemplate <---------------------+
     *      _parseTemplateContent              |
     *        _parseTemplateNode  <------------|--+
     *          _parseTemplateNestedTemplate --+  |
     *          _parseTemplateChildNodes ---------+
     *          _parseTemplateNodeAttributes
     *            _parseTemplateNodeAttribute
     *
     * ```
     *
     * These methods may be overridden to add custom metadata about templates
     * to either `templateInfo` or `nodeInfo`.
     *
     * Note that this method may be destructive to the template, in that
     * e.g. event annotations may be removed after being noted in the
     * template metadata.
     *
     * @param {!HTMLTemplateElement} template Template to parse
     * @param {TemplateInfo=} outerTemplateInfo Template metadata from the outer
     *   template, for parsing nested templates
     * @return {!TemplateInfo} Parsed template metadata
     * @nocollapse
     */
    static _parseTemplate(template, outerTemplateInfo) {
      // since a template may be re-used, memo-ize metadata
      if (!template._templateInfo) {
        // TODO(rictic): fix typing
        let
        /** ? */
        templateInfo = template._templateInfo = {};
        templateInfo.nodeInfoList = [];
        templateInfo.nestedTemplate = Boolean(outerTemplateInfo);
        templateInfo.stripWhiteSpace = outerTemplateInfo && outerTemplateInfo.stripWhiteSpace || template.hasAttribute('strip-whitespace'); // TODO(rictic): fix typing

        this._parseTemplateContent(template, templateInfo,
        /** @type {?} */
        {
          parent: null
        });
      }

      return template._templateInfo;
    }
    /**
     * See docs for _parseTemplateNode.
     *
     * @param {!HTMLTemplateElement} template .
     * @param {!TemplateInfo} templateInfo .
     * @param {!NodeInfo} nodeInfo .
     * @return {boolean} .
     * @nocollapse
     */


    static _parseTemplateContent(template, templateInfo, nodeInfo) {
      return this._parseTemplateNode(template.content, templateInfo, nodeInfo);
    }
    /**
     * Parses template node and adds template and node metadata based on
     * the current node, and its `childNodes` and `attributes`.
     *
     * This method may be overridden to add custom node or template specific
     * metadata based on this node.
     *
     * @param {Node} node Node to parse
     * @param {!TemplateInfo} templateInfo Template metadata for current template
     * @param {!NodeInfo} nodeInfo Node metadata for current template.
     * @return {boolean} `true` if the visited node added node-specific
     *   metadata to `nodeInfo`
     * @nocollapse
     */


    static _parseTemplateNode(node, templateInfo, nodeInfo) {
      let noted = false;
      let element =
      /** @type {!HTMLTemplateElement} */
      node;

      if (element.localName == 'template' && !element.hasAttribute('preserve-content')) {
        noted = this._parseTemplateNestedTemplate(element, templateInfo, nodeInfo) || noted;
      } else if (element.localName === 'slot') {
        // For ShadyDom optimization, indicating there is an insertion point
        templateInfo.hasInsertionPoint = true;
      }

      fixPlaceholder(element);

      if (element.firstChild) {
        this._parseTemplateChildNodes(element, templateInfo, nodeInfo);
      }

      if (element.hasAttributes && element.hasAttributes()) {
        noted = this._parseTemplateNodeAttributes(element, templateInfo, nodeInfo) || noted;
      } // Checking `nodeInfo.noted` allows a child node of this node (who gets
      // access to `parentInfo`) to cause the parent to be noted, which
      // otherwise has no return path via `_parseTemplateChildNodes` (used by
      // some optimizations)


      return noted || nodeInfo.noted;
    }
    /**
     * Parses template child nodes for the given root node.
     *
     * This method also wraps whitelisted legacy template extensions
     * (`is="dom-if"` and `is="dom-repeat"`) with their equivalent element
     * wrappers, collapses text nodes, and strips whitespace from the template
     * if the `templateInfo.stripWhitespace` setting was provided.
     *
     * @param {Node} root Root node whose `childNodes` will be parsed
     * @param {!TemplateInfo} templateInfo Template metadata for current template
     * @param {!NodeInfo} nodeInfo Node metadata for current template.
     * @return {void}
     */


    static _parseTemplateChildNodes(root, templateInfo, nodeInfo) {
      if (root.localName === 'script' || root.localName === 'style') {
        return;
      }

      for (let node = root.firstChild, parentIndex = 0, next; node; node = next) {
        // Wrap templates
        if (node.localName == 'template') {
          node = wrapTemplateExtension(node);
        } // collapse adjacent textNodes: fixes an IE issue that can cause
        // text nodes to be inexplicably split =(
        // note that root.normalize() should work but does not so we do this
        // manually.


        next = node.nextSibling;

        if (node.nodeType === Node.TEXT_NODE) {
          let
          /** Node */
          n = next;

          while (n && n.nodeType === Node.TEXT_NODE) {
            node.textContent += n.textContent;
            next = n.nextSibling;
            root.removeChild(n);
            n = next;
          } // optionally strip whitespace


          if (templateInfo.stripWhiteSpace && !node.textContent.trim()) {
            root.removeChild(node);
            continue;
          }
        }

        let childInfo =
        /** @type {!NodeInfo} */
        {
          parentIndex,
          parentInfo: nodeInfo
        };

        if (this._parseTemplateNode(node, templateInfo, childInfo)) {
          childInfo.infoIndex = templateInfo.nodeInfoList.push(childInfo) - 1;
        } // Increment if not removed


        if (node.parentNode) {
          parentIndex++;
        }
      }
    }
    /**
     * Parses template content for the given nested `<template>`.
     *
     * Nested template info is stored as `templateInfo` in the current node's
     * `nodeInfo`. `template.content` is removed and stored in `templateInfo`.
     * It will then be the responsibility of the host to set it back to the
     * template and for users stamping nested templates to use the
     * `_contentForTemplate` method to retrieve the content for this template
     * (an optimization to avoid the cost of cloning nested template content).
     *
     * @param {HTMLTemplateElement} node Node to parse (a <template>)
     * @param {TemplateInfo} outerTemplateInfo Template metadata for current template
     *   that includes the template `node`
     * @param {!NodeInfo} nodeInfo Node metadata for current template.
     * @return {boolean} `true` if the visited node added node-specific
     *   metadata to `nodeInfo`
     * @nocollapse
     */


    static _parseTemplateNestedTemplate(node, outerTemplateInfo, nodeInfo) {
      // TODO(rictic): the type of node should be non-null
      let element =
      /** @type {!HTMLTemplateElement} */
      node;

      let templateInfo = this._parseTemplate(element, outerTemplateInfo);

      let content = templateInfo.content = element.content.ownerDocument.createDocumentFragment();
      content.appendChild(element.content);
      nodeInfo.templateInfo = templateInfo;
      return true;
    }
    /**
     * Parses template node attributes and adds node metadata to `nodeInfo`
     * for nodes of interest.
     *
     * @param {Element} node Node to parse
     * @param {!TemplateInfo} templateInfo Template metadata for current
     *     template
     * @param {!NodeInfo} nodeInfo Node metadata for current template.
     * @return {boolean} `true` if the visited node added node-specific
     *   metadata to `nodeInfo`
     * @nocollapse
     */


    static _parseTemplateNodeAttributes(node, templateInfo, nodeInfo) {
      // Make copy of original attribute list, since the order may change
      // as attributes are added and removed
      let noted = false;
      let attrs = Array.from(node.attributes);

      for (let i = attrs.length - 1, a; a = attrs[i]; i--) {
        noted = this._parseTemplateNodeAttribute(node, templateInfo, nodeInfo, a.name, a.value) || noted;
      }

      return noted;
    }
    /**
     * Parses a single template node attribute and adds node metadata to
     * `nodeInfo` for attributes of interest.
     *
     * This implementation adds metadata for `on-event="handler"` attributes
     * and `id` attributes.
     *
     * @param {Element} node Node to parse
     * @param {!TemplateInfo} templateInfo Template metadata for current template
     * @param {!NodeInfo} nodeInfo Node metadata for current template.
     * @param {string} name Attribute name
     * @param {string} value Attribute value
     * @return {boolean} `true` if the visited node added node-specific
     *   metadata to `nodeInfo`
     * @nocollapse
     */


    static _parseTemplateNodeAttribute(node, templateInfo, nodeInfo, name, value) {
      // events (on-*)
      if (name.slice(0, 3) === 'on-') {
        node.removeAttribute(name);
        nodeInfo.events = nodeInfo.events || [];
        nodeInfo.events.push({
          name: name.slice(3),
          value
        });
        return true;
      } // static id
      else if (name === 'id') {
          nodeInfo.id = value;
          return true;
        }

      return false;
    }
    /**
     * Returns the `content` document fragment for a given template.
     *
     * For nested templates, Polymer performs an optimization to cache nested
     * template content to avoid the cost of cloning deeply nested templates.
     * This method retrieves the cached content for a given template.
     *
     * @param {HTMLTemplateElement} template Template to retrieve `content` for
     * @return {DocumentFragment} Content fragment
     * @nocollapse
     */


    static _contentForTemplate(template) {
      let templateInfo =
      /** @type {HTMLTemplateElementWithInfo} */
      template._templateInfo;
      return templateInfo && templateInfo.content || template.content;
    }
    /**
     * Clones the provided template content and returns a document fragment
     * containing the cloned dom.
     *
     * The template is parsed (once and memoized) using this library's
     * template parsing features, and provides the following value-added
     * features:
     * * Adds declarative event listeners for `on-event="handler"` attributes
     * * Generates an "id map" for all nodes with id's under `$` on returned
     *   document fragment
     * * Passes template info including `content` back to templates as
     *   `_templateInfo` (a performance optimization to avoid deep template
     *   cloning)
     *
     * Note that the memoized template parsing process is destructive to the
     * template: attributes for bindings and declarative event listeners are
     * removed after being noted in notes, and any nested `<template>.content`
     * is removed and stored in notes as well.
     *
     * @param {!HTMLTemplateElement} template Template to stamp
     * @param {TemplateInfo=} templateInfo Optional template info associated
     *   with the template to be stamped; if omitted the template will be
     *   automatically parsed.
     * @return {!StampedTemplate} Cloned template content
     * @override
     */


    _stampTemplate(template, templateInfo) {
      // Polyfill support: bootstrap the template if it has not already been
      if (template && !template.content && window.HTMLTemplateElement && HTMLTemplateElement.decorate) {
        HTMLTemplateElement.decorate(template);
      } // Accepting the `templateInfo` via an argument allows for creating
      // instances of the `templateInfo` by the caller, useful for adding
      // instance-time information to the prototypical data


      templateInfo = templateInfo || this.constructor._parseTemplate(template);
      let nodeInfo = templateInfo.nodeInfoList;
      let content = templateInfo.content || template.content;
      let dom =
      /** @type {DocumentFragment} */
      document.importNode(content, true); // NOTE: ShadyDom optimization indicating there is an insertion point

      dom.__noInsertionPoint = !templateInfo.hasInsertionPoint;
      let nodes = dom.nodeList = new Array(nodeInfo.length);
      dom.$ = {};

      for (let i = 0, l = nodeInfo.length, info; i < l && (info = nodeInfo[i]); i++) {
        let node = nodes[i] = findTemplateNode(dom, info);
        applyIdToMap(this, dom.$, node, info);
        applyTemplateInfo(this, node, info, templateInfo);
        applyEventListener(this, node, info);
      }

      dom =
      /** @type {!StampedTemplate} */
      dom; // eslint-disable-line no-self-assign

      return dom;
    }
    /**
     * Adds an event listener by method name for the event provided.
     *
     * This method generates a handler function that looks up the method
     * name at handling time.
     *
     * @param {!EventTarget} node Node to add listener on
     * @param {string} eventName Name of event
     * @param {string} methodName Name of method
     * @param {*=} context Context the method will be called on (defaults
     *   to `node`)
     * @return {Function} Generated handler function
     * @override
     */


    _addMethodEventListenerToNode(node, eventName, methodName, context) {
      context = context || node;
      let handler = createNodeEventHandler(context, eventName, methodName);

      this._addEventListenerToNode(node, eventName, handler);

      return handler;
    }
    /**
     * Override point for adding custom or simulated event handling.
     *
     * @param {!EventTarget} node Node to add event listener to
     * @param {string} eventName Name of event
     * @param {function(!Event):void} handler Listener function to add
     * @return {void}
     * @override
     */


    _addEventListenerToNode(node, eventName, handler) {
      node.addEventListener(eventName, handler);
    }
    /**
     * Override point for adding custom or simulated event handling.
     *
     * @param {!EventTarget} node Node to remove event listener from
     * @param {string} eventName Name of event
     * @param {function(!Event):void} handler Listener function to remove
     * @return {void}
     * @override
     */


    _removeEventListenerFromNode(node, eventName, handler) {
      node.removeEventListener(eventName, handler);
    }

  }

  return TemplateStamp;
});

/***/ }),

/***/ "./node_modules/@polymer/polymer/lib/utils/async.js":
/*!**********************************************************!*\
  !*** ./node_modules/@polymer/polymer/lib/utils/async.js ***!
  \**********************************************************/
/*! exports provided: timeOut, animationFrame, idlePeriod, microTask */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "timeOut", function() { return timeOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "animationFrame", function() { return animationFrame; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "idlePeriod", function() { return idlePeriod; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "microTask", function() { return microTask; });
/* harmony import */ var _boot_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./boot.js */ "./node_modules/@polymer/polymer/lib/utils/boot.js");
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

/**
 * @fileoverview
 *
 * This module provides a number of strategies for enqueuing asynchronous
 * tasks. Each sub-module provides a standard `run(fn)` interface that returns a
 * handle, and a `cancel(handle)` interface for canceling async tasks before
 * they run.
 *
 * @summary Module that provides a number of strategies for enqueuing
 * asynchronous tasks.
 */
 // Microtask implemented using Mutation Observer

let microtaskCurrHandle = 0;
let microtaskLastHandle = 0;
let microtaskCallbacks = [];
let microtaskNodeContent = 0;
let microtaskScheduled = false;
let microtaskNode = document.createTextNode('');
new window.MutationObserver(microtaskFlush).observe(microtaskNode, {
  characterData: true
});

function microtaskFlush() {
  microtaskScheduled = false;
  const len = microtaskCallbacks.length;

  for (let i = 0; i < len; i++) {
    let cb = microtaskCallbacks[i];

    if (cb) {
      try {
        cb();
      } catch (e) {
        setTimeout(() => {
          throw e;
        });
      }
    }
  }

  microtaskCallbacks.splice(0, len);
  microtaskLastHandle += len;
}
/**
 * Async interface wrapper around `setTimeout`.
 *
 * @namespace
 * @summary Async interface wrapper around `setTimeout`.
 */


const timeOut = {
  /**
   * Returns a sub-module with the async interface providing the provided
   * delay.
   *
   * @memberof timeOut
   * @param {number=} delay Time to wait before calling callbacks in ms
   * @return {!AsyncInterface} An async timeout interface
   */
  after(delay) {
    return {
      run(fn) {
        return window.setTimeout(fn, delay);
      },

      cancel(handle) {
        window.clearTimeout(handle);
      }

    };
  },

  /**
   * Enqueues a function called in the next task.
   *
   * @memberof timeOut
   * @param {!Function} fn Callback to run
   * @param {number=} delay Delay in milliseconds
   * @return {number} Handle used for canceling task
   */
  run(fn, delay) {
    return window.setTimeout(fn, delay);
  },

  /**
   * Cancels a previously enqueued `timeOut` callback.
   *
   * @memberof timeOut
   * @param {number} handle Handle returned from `run` of callback to cancel
   * @return {void}
   */
  cancel(handle) {
    window.clearTimeout(handle);
  }

};

/**
 * Async interface wrapper around `requestAnimationFrame`.
 *
 * @namespace
 * @summary Async interface wrapper around `requestAnimationFrame`.
 */

const animationFrame = {
  /**
   * Enqueues a function called at `requestAnimationFrame` timing.
   *
   * @memberof animationFrame
   * @param {function(number):void} fn Callback to run
   * @return {number} Handle used for canceling task
   */
  run(fn) {
    return window.requestAnimationFrame(fn);
  },

  /**
   * Cancels a previously enqueued `animationFrame` callback.
   *
   * @memberof animationFrame
   * @param {number} handle Handle returned from `run` of callback to cancel
   * @return {void}
   */
  cancel(handle) {
    window.cancelAnimationFrame(handle);
  }

};

/**
 * Async interface wrapper around `requestIdleCallback`.  Falls back to
 * `setTimeout` on browsers that do not support `requestIdleCallback`.
 *
 * @namespace
 * @summary Async interface wrapper around `requestIdleCallback`.
 */

const idlePeriod = {
  /**
   * Enqueues a function called at `requestIdleCallback` timing.
   *
   * @memberof idlePeriod
   * @param {function(!IdleDeadline):void} fn Callback to run
   * @return {number} Handle used for canceling task
   */
  run(fn) {
    return window.requestIdleCallback ? window.requestIdleCallback(fn) : window.setTimeout(fn, 16);
  },

  /**
   * Cancels a previously enqueued `idlePeriod` callback.
   *
   * @memberof idlePeriod
   * @param {number} handle Handle returned from `run` of callback to cancel
   * @return {void}
   */
  cancel(handle) {
    window.cancelIdleCallback ? window.cancelIdleCallback(handle) : window.clearTimeout(handle);
  }

};

/**
 * Async interface for enqueuing callbacks that run at microtask timing.
 *
 * Note that microtask timing is achieved via a single `MutationObserver`,
 * and thus callbacks enqueued with this API will all run in a single
 * batch, and not interleaved with other microtasks such as promises.
 * Promises are avoided as an implementation choice for the time being
 * due to Safari bugs that cause Promises to lack microtask guarantees.
 *
 * @namespace
 * @summary Async interface for enqueuing callbacks that run at microtask
 *   timing.
 */

const microTask = {
  /**
   * Enqueues a function called at microtask timing.
   *
   * @memberof microTask
   * @param {!Function=} callback Callback to run
   * @return {number} Handle used for canceling task
   */
  run(callback) {
    if (!microtaskScheduled) {
      microtaskScheduled = true;
      microtaskNode.textContent = microtaskNodeContent++;
    }

    microtaskCallbacks.push(callback);
    return microtaskCurrHandle++;
  },

  /**
   * Cancels a previously enqueued `microTask` callback.
   *
   * @memberof microTask
   * @param {number} handle Handle returned from `run` of callback to cancel
   * @return {void}
   */
  cancel(handle) {
    const idx = handle - microtaskLastHandle;

    if (idx >= 0) {
      if (!microtaskCallbacks[idx]) {
        throw new Error('invalid async handle: ' + handle);
      }

      microtaskCallbacks[idx] = null;
    }
  }

};


/***/ }),

/***/ "./node_modules/@polymer/polymer/lib/utils/boot.js":
/*!*********************************************************!*\
  !*** ./node_modules/@polymer/polymer/lib/utils/boot.js ***!
  \*********************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

/* eslint-disable no-unused-vars */

/**
 * When using Closure Compiler, JSCompiler_renameProperty(property, object) is replaced by the munged name for object[property]
 * We cannot alias this function, so we have to use a small shim that has the same behavior when not compiling.
 *
 * @param {?} prop Property name
 * @param {*} obj Reference object
 * @return {string} Potentially renamed property name
 */
window.JSCompiler_renameProperty = function (prop, obj) {
  return prop;
};
/* eslint-enable */




/***/ }),

/***/ "./node_modules/@polymer/polymer/lib/utils/case-map.js":
/*!*************************************************************!*\
  !*** ./node_modules/@polymer/polymer/lib/utils/case-map.js ***!
  \*************************************************************/
/*! exports provided: dashToCamelCase, camelToDashCase */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dashToCamelCase", function() { return dashToCamelCase; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "camelToDashCase", function() { return camelToDashCase; });
/* harmony import */ var _boot_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./boot.js */ "./node_modules/@polymer/polymer/lib/utils/boot.js");
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

const caseMap = {};
const DASH_TO_CAMEL = /-[a-z]/g;
const CAMEL_TO_DASH = /([A-Z])/g;
/**
 * @fileoverview Module with utilities for converting between "dash-case" and
 * "camelCase" identifiers.
 */

/**
 * Converts "dash-case" identifier (e.g. `foo-bar-baz`) to "camelCase"
 * (e.g. `fooBarBaz`).
 *
 * @param {string} dash Dash-case identifier
 * @return {string} Camel-case representation of the identifier
 */

function dashToCamelCase(dash) {
  return caseMap[dash] || (caseMap[dash] = dash.indexOf('-') < 0 ? dash : dash.replace(DASH_TO_CAMEL, m => m[1].toUpperCase()));
}
/**
 * Converts "camelCase" identifier (e.g. `fooBarBaz`) to "dash-case"
 * (e.g. `foo-bar-baz`).
 *
 * @param {string} camel Camel-case identifier
 * @return {string} Dash-case representation of the identifier
 */

function camelToDashCase(camel) {
  return caseMap[camel] || (caseMap[camel] = camel.replace(CAMEL_TO_DASH, '-$1').toLowerCase());
}

/***/ }),

/***/ "./node_modules/@polymer/polymer/lib/utils/debounce.js":
/*!*************************************************************!*\
  !*** ./node_modules/@polymer/polymer/lib/utils/debounce.js ***!
  \*************************************************************/
/*! exports provided: Debouncer, enqueueDebouncer, flushDebouncers */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Debouncer", function() { return Debouncer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "enqueueDebouncer", function() { return enqueueDebouncer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "flushDebouncers", function() { return flushDebouncers; });
/* harmony import */ var _boot_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./boot.js */ "./node_modules/@polymer/polymer/lib/utils/boot.js");
/* harmony import */ var _mixin_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mixin.js */ "./node_modules/@polymer/polymer/lib/utils/mixin.js");
/* harmony import */ var _async_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./async.js */ "./node_modules/@polymer/polymer/lib/utils/async.js");
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/



/**
 * @summary Collapse multiple callbacks into one invocation after a timer.
 */

class Debouncer {
  constructor() {
    this._asyncModule = null;
    this._callback = null;
    this._timer = null;
  }
  /**
   * Sets the scheduler; that is, a module with the Async interface,
   * a callback and optional arguments to be passed to the run function
   * from the async module.
   *
   * @param {!AsyncInterface} asyncModule Object with Async interface.
   * @param {function()} callback Callback to run.
   * @return {void}
   */


  setConfig(asyncModule, callback) {
    this._asyncModule = asyncModule;
    this._callback = callback;
    this._timer = this._asyncModule.run(() => {
      this._timer = null;
      debouncerQueue.delete(this);

      this._callback();
    });
  }
  /**
   * Cancels an active debouncer and returns a reference to itself.
   *
   * @return {void}
   */


  cancel() {
    if (this.isActive()) {
      this._cancelAsync(); // Canceling a debouncer removes its spot from the flush queue,
      // so if a debouncer is manually canceled and re-debounced, it
      // will reset its flush order (this is a very minor difference from 1.x)
      // Re-debouncing via the `debounce` API retains the 1.x FIFO flush order


      debouncerQueue.delete(this);
    }
  }
  /**
   * Cancels a debouncer's async callback.
   *
   * @return {void}
   */


  _cancelAsync() {
    if (this.isActive()) {
      this._asyncModule.cancel(
      /** @type {number} */
      this._timer);

      this._timer = null;
    }
  }
  /**
   * Flushes an active debouncer and returns a reference to itself.
   *
   * @return {void}
   */


  flush() {
    if (this.isActive()) {
      this.cancel();

      this._callback();
    }
  }
  /**
   * Returns true if the debouncer is active.
   *
   * @return {boolean} True if active.
   */


  isActive() {
    return this._timer != null;
  }
  /**
   * Creates a debouncer if no debouncer is passed as a parameter
   * or it cancels an active debouncer otherwise. The following
   * example shows how a debouncer can be called multiple times within a
   * microtask and "debounced" such that the provided callback function is
   * called once. Add this method to a custom element:
   *
   * ```js
   * import {microTask} from '@polymer/polymer/lib/utils/async.js';
   * import {Debouncer} from '@polymer/polymer/lib/utils/debounce.js';
   * // ...
   *
   * _debounceWork() {
   *   this._debounceJob = Debouncer.debounce(this._debounceJob,
   *       microTask, () => this._doWork());
   * }
   * ```
   *
   * If the `_debounceWork` method is called multiple times within the same
   * microtask, the `_doWork` function will be called only once at the next
   * microtask checkpoint.
   *
   * Note: In testing it is often convenient to avoid asynchrony. To accomplish
   * this with a debouncer, you can use `enqueueDebouncer` and
   * `flush`. For example, extend the above example by adding
   * `enqueueDebouncer(this._debounceJob)` at the end of the
   * `_debounceWork` method. Then in a test, call `flush` to ensure
   * the debouncer has completed.
   *
   * @param {Debouncer?} debouncer Debouncer object.
   * @param {!AsyncInterface} asyncModule Object with Async interface
   * @param {function()} callback Callback to run.
   * @return {!Debouncer} Returns a debouncer object.
   */


  static debounce(debouncer, asyncModule, callback) {
    if (debouncer instanceof Debouncer) {
      // Cancel the async callback, but leave in debouncerQueue if it was
      // enqueued, to maintain 1.x flush order
      debouncer._cancelAsync();
    } else {
      debouncer = new Debouncer();
    }

    debouncer.setConfig(asyncModule, callback);
    return debouncer;
  }

}
let debouncerQueue = new Set();
/**
 * Adds a `Debouncer` to a list of globally flushable tasks.
 *
 * @param {!Debouncer} debouncer Debouncer to enqueue
 * @return {void}
 */

const enqueueDebouncer = function (debouncer) {
  debouncerQueue.add(debouncer);
};
/**
 * Flushes any enqueued debouncers
 *
 * @return {boolean} Returns whether any debouncers were flushed
 */

const flushDebouncers = function () {
  const didFlush = Boolean(debouncerQueue.size); // If new debouncers are added while flushing, Set.forEach will ensure
  // newly added ones are also flushed

  debouncerQueue.forEach(debouncer => {
    try {
      debouncer.flush();
    } catch (e) {
      setTimeout(() => {
        throw e;
      });
    }
  });
  return didFlush;
};

/***/ }),

/***/ "./node_modules/@polymer/polymer/lib/utils/flush.js":
/*!**********************************************************!*\
  !*** ./node_modules/@polymer/polymer/lib/utils/flush.js ***!
  \**********************************************************/
/*! exports provided: enqueueDebouncer, flush */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "flush", function() { return flush; });
/* harmony import */ var _boot_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./boot.js */ "./node_modules/@polymer/polymer/lib/utils/boot.js");
/* harmony import */ var _utils_debounce_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/debounce.js */ "./node_modules/@polymer/polymer/lib/utils/debounce.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "enqueueDebouncer", function() { return _utils_debounce_js__WEBPACK_IMPORTED_MODULE_1__["enqueueDebouncer"]; });

/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/



/**
 * Forces several classes of asynchronously queued tasks to flush:
 * - Debouncers added via `enqueueDebouncer`
 * - ShadyDOM distribution
 *
 * @return {void}
 */

const flush = function () {
  let shadyDOM, debouncers;

  do {
    shadyDOM = window.ShadyDOM && ShadyDOM.flush();

    if (window.ShadyCSS && window.ShadyCSS.ScopingShim) {
      window.ShadyCSS.ScopingShim.flush();
    }

    debouncers = Object(_utils_debounce_js__WEBPACK_IMPORTED_MODULE_1__["flushDebouncers"])();
  } while (shadyDOM || debouncers);
};

/***/ }),

/***/ "./node_modules/@polymer/polymer/lib/utils/gestures.js":
/*!*************************************************************!*\
  !*** ./node_modules/@polymer/polymer/lib/utils/gestures.js ***!
  \*************************************************************/
/*! exports provided: gestures, recognizers, deepTargetFind, addListener, removeListener, register, setTouchAction, prevent, resetMouseCanceller, findOriginalTarget, add, remove */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "gestures", function() { return gestures; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "recognizers", function() { return recognizers; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "deepTargetFind", function() { return deepTargetFind; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addListener", function() { return addListener; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "removeListener", function() { return removeListener; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "register", function() { return register; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setTouchAction", function() { return setTouchAction; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "prevent", function() { return prevent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resetMouseCanceller", function() { return resetMouseCanceller; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "findOriginalTarget", function() { return findOriginalTarget; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "remove", function() { return remove; });
/* harmony import */ var _boot_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./boot.js */ "./node_modules/@polymer/polymer/lib/utils/boot.js");
/* harmony import */ var _async_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./async.js */ "./node_modules/@polymer/polymer/lib/utils/async.js");
/* harmony import */ var _debounce_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./debounce.js */ "./node_modules/@polymer/polymer/lib/utils/debounce.js");
/* harmony import */ var _settings_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./settings.js */ "./node_modules/@polymer/polymer/lib/utils/settings.js");
/* harmony import */ var _wrap_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./wrap.js */ "./node_modules/@polymer/polymer/lib/utils/wrap.js");
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

/**
 * @fileoverview
 *
 * Module for adding listeners to a node for the following normalized
 * cross-platform "gesture" events:
 * - `down` - mouse or touch went down
 * - `up` - mouse or touch went up
 * - `tap` - mouse click or finger tap
 * - `track` - mouse drag or touch move
 *
 * @summary Module for adding cross-platform gesture event listeners.
 */




 // detect native touch action support

let HAS_NATIVE_TA = typeof document.head.style.touchAction === 'string';
let GESTURE_KEY = '__polymerGestures';
let HANDLED_OBJ = '__polymerGesturesHandled';
let TOUCH_ACTION = '__polymerGesturesTouchAction'; // radius for tap and track

let TAP_DISTANCE = 25;
let TRACK_DISTANCE = 5; // number of last N track positions to keep

let TRACK_LENGTH = 2; // Disabling "mouse" handlers for 2500ms is enough

let MOUSE_TIMEOUT = 2500;
let MOUSE_EVENTS = ['mousedown', 'mousemove', 'mouseup', 'click']; // an array of bitmask values for mapping MouseEvent.which to MouseEvent.buttons

let MOUSE_WHICH_TO_BUTTONS = [0, 1, 4, 2];

let MOUSE_HAS_BUTTONS = function () {
  try {
    return new MouseEvent('test', {
      buttons: 1
    }).buttons === 1;
  } catch (e) {
    return false;
  }
}();
/**
 * @param {string} name Possible mouse event name
 * @return {boolean} true if mouse event, false if not
 */


function isMouseEvent(name) {
  return MOUSE_EVENTS.indexOf(name) > -1;
}
/* eslint no-empty: ["error", { "allowEmptyCatch": true }] */
// check for passive event listeners


let supportsPassive = false;

(function () {
  try {
    let opts = Object.defineProperty({}, 'passive', {
      get() {
        supportsPassive = true;
      }

    });
    window.addEventListener('test', null, opts);
    window.removeEventListener('test', null, opts);
  } catch (e) {}
})();
/**
 * Generate settings for event listeners, dependant on `passiveTouchGestures`
 *
 * @param {string} eventName Event name to determine if `{passive}` option is
 *   needed
 * @return {{passive: boolean} | undefined} Options to use for addEventListener
 *   and removeEventListener
 */


function PASSIVE_TOUCH(eventName) {
  if (isMouseEvent(eventName) || eventName === 'touchend') {
    return;
  }

  if (HAS_NATIVE_TA && supportsPassive && _settings_js__WEBPACK_IMPORTED_MODULE_3__["passiveTouchGestures"]) {
    return {
      passive: true
    };
  } else {
    return;
  }
} // Check for touch-only devices


let IS_TOUCH_ONLY = navigator.userAgent.match(/iP(?:[oa]d|hone)|Android/); // keep track of any labels hit by the mouseCanceller

/** @type {!Array<!HTMLLabelElement>} */

const clickedLabels = [];
/** @type {!Object<boolean>} */

const labellable = {
  'button': true,
  'input': true,
  'keygen': true,
  'meter': true,
  'output': true,
  'textarea': true,
  'progress': true,
  'select': true
}; // Defined at https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#enabling-and-disabling-form-controls:-the-disabled-attribute

/** @type {!Object<boolean>} */

const canBeDisabled = {
  'button': true,
  'command': true,
  'fieldset': true,
  'input': true,
  'keygen': true,
  'optgroup': true,
  'option': true,
  'select': true,
  'textarea': true
};
/**
 * @param {HTMLElement} el Element to check labelling status
 * @return {boolean} element can have labels
 */

function canBeLabelled(el) {
  return labellable[el.localName] || false;
}
/**
 * @param {HTMLElement} el Element that may be labelled.
 * @return {!Array<!HTMLLabelElement>} Relevant label for `el`
 */


function matchingLabels(el) {
  let labels = Array.prototype.slice.call(
  /** @type {HTMLInputElement} */
  el.labels || []); // IE doesn't have `labels` and Safari doesn't populate `labels`
  // if element is in a shadowroot.
  // In this instance, finding the non-ancestor labels is enough,
  // as the mouseCancellor code will handle ancstor labels

  if (!labels.length) {
    labels = [];
    let root = el.getRootNode(); // if there is an id on `el`, check for all labels with a matching `for` attribute

    if (el.id) {
      let matching = root.querySelectorAll(`label[for = ${el.id}]`);

      for (let i = 0; i < matching.length; i++) {
        labels.push(
        /** @type {!HTMLLabelElement} */
        matching[i]);
      }
    }
  }

  return labels;
} // touch will make synthetic mouse events
// `preventDefault` on touchend will cancel them,
// but this breaks `<input>` focus and link clicks
// disable mouse handlers for MOUSE_TIMEOUT ms after
// a touchend to ignore synthetic mouse events


let mouseCanceller = function (mouseEvent) {
  // Check for sourceCapabilities, used to distinguish synthetic events
  // if mouseEvent did not come from a device that fires touch events,
  // it was made by a real mouse and should be counted
  // http://wicg.github.io/InputDeviceCapabilities/#dom-inputdevicecapabilities-firestouchevents
  let sc = mouseEvent.sourceCapabilities;

  if (sc && !sc.firesTouchEvents) {
    return;
  } // skip synthetic mouse events


  mouseEvent[HANDLED_OBJ] = {
    skip: true
  }; // disable "ghost clicks"

  if (mouseEvent.type === 'click') {
    let clickFromLabel = false;
    let path = getComposedPath(mouseEvent);

    for (let i = 0; i < path.length; i++) {
      if (path[i].nodeType === Node.ELEMENT_NODE) {
        if (path[i].localName === 'label') {
          clickedLabels.push(
          /** @type {!HTMLLabelElement} */
          path[i]);
        } else if (canBeLabelled(
        /** @type {!HTMLElement} */
        path[i])) {
          let ownerLabels = matchingLabels(
          /** @type {!HTMLElement} */
          path[i]); // check if one of the clicked labels is labelling this element

          for (let j = 0; j < ownerLabels.length; j++) {
            clickFromLabel = clickFromLabel || clickedLabels.indexOf(ownerLabels[j]) > -1;
          }
        }
      }

      if (path[i] === POINTERSTATE.mouse.target) {
        return;
      }
    } // if one of the clicked labels was labelling the target element,
    // this is not a ghost click


    if (clickFromLabel) {
      return;
    }

    mouseEvent.preventDefault();
    mouseEvent.stopPropagation();
  }
};
/**
 * @param {boolean=} setup True to add, false to remove.
 * @return {void}
 */


function setupTeardownMouseCanceller(setup) {
  let events = IS_TOUCH_ONLY ? ['click'] : MOUSE_EVENTS;

  for (let i = 0, en; i < events.length; i++) {
    en = events[i];

    if (setup) {
      // reset clickLabels array
      clickedLabels.length = 0;
      document.addEventListener(en, mouseCanceller, true);
    } else {
      document.removeEventListener(en, mouseCanceller, true);
    }
  }
}

function ignoreMouse(e) {
  if (!_settings_js__WEBPACK_IMPORTED_MODULE_3__["cancelSyntheticClickEvents"]) {
    return;
  }

  if (!POINTERSTATE.mouse.mouseIgnoreJob) {
    setupTeardownMouseCanceller(true);
  }

  let unset = function () {
    setupTeardownMouseCanceller();
    POINTERSTATE.mouse.target = null;
    POINTERSTATE.mouse.mouseIgnoreJob = null;
  };

  POINTERSTATE.mouse.target = getComposedPath(e)[0];
  POINTERSTATE.mouse.mouseIgnoreJob = _debounce_js__WEBPACK_IMPORTED_MODULE_2__["Debouncer"].debounce(POINTERSTATE.mouse.mouseIgnoreJob, _async_js__WEBPACK_IMPORTED_MODULE_1__["timeOut"].after(MOUSE_TIMEOUT), unset);
}
/**
 * @param {MouseEvent} ev event to test for left mouse button down
 * @return {boolean} has left mouse button down
 */


function hasLeftMouseButton(ev) {
  let type = ev.type; // exit early if the event is not a mouse event

  if (!isMouseEvent(type)) {
    return false;
  } // ev.button is not reliable for mousemove (0 is overloaded as both left button and no buttons)
  // instead we use ev.buttons (bitmask of buttons) or fall back to ev.which (deprecated, 0 for no buttons, 1 for left button)


  if (type === 'mousemove') {
    // allow undefined for testing events
    let buttons = ev.buttons === undefined ? 1 : ev.buttons;

    if (ev instanceof window.MouseEvent && !MOUSE_HAS_BUTTONS) {
      buttons = MOUSE_WHICH_TO_BUTTONS[ev.which] || 0;
    } // buttons is a bitmask, check that the left button bit is set (1)


    return Boolean(buttons & 1);
  } else {
    // allow undefined for testing events
    let button = ev.button === undefined ? 0 : ev.button; // ev.button is 0 in mousedown/mouseup/click for left button activation

    return button === 0;
  }
}

function isSyntheticClick(ev) {
  if (ev.type === 'click') {
    // ev.detail is 0 for HTMLElement.click in most browsers
    if (ev.detail === 0) {
      return true;
    } // in the worst case, check that the x/y position of the click is within
    // the bounding box of the target of the event
    // Thanks IE 10 >:(


    let t = _findOriginalTarget(ev); // make sure the target of the event is an element so we can use getBoundingClientRect,
    // if not, just assume it is a synthetic click


    if (!t.nodeType ||
    /** @type {Element} */
    t.nodeType !== Node.ELEMENT_NODE) {
      return true;
    }

    let bcr =
    /** @type {Element} */
    t.getBoundingClientRect(); // use page x/y to account for scrolling

    let x = ev.pageX,
        y = ev.pageY; // ev is a synthetic click if the position is outside the bounding box of the target

    return !(x >= bcr.left && x <= bcr.right && y >= bcr.top && y <= bcr.bottom);
  }

  return false;
}

let POINTERSTATE = {
  mouse: {
    target: null,
    mouseIgnoreJob: null
  },
  touch: {
    x: 0,
    y: 0,
    id: -1,
    scrollDecided: false
  }
};

function firstTouchAction(ev) {
  let ta = 'auto';
  let path = getComposedPath(ev);

  for (let i = 0, n; i < path.length; i++) {
    n = path[i];

    if (n[TOUCH_ACTION]) {
      ta = n[TOUCH_ACTION];
      break;
    }
  }

  return ta;
}

function trackDocument(stateObj, movefn, upfn) {
  stateObj.movefn = movefn;
  stateObj.upfn = upfn;
  document.addEventListener('mousemove', movefn);
  document.addEventListener('mouseup', upfn);
}

function untrackDocument(stateObj) {
  document.removeEventListener('mousemove', stateObj.movefn);
  document.removeEventListener('mouseup', stateObj.upfn);
  stateObj.movefn = null;
  stateObj.upfn = null;
}

if (_settings_js__WEBPACK_IMPORTED_MODULE_3__["cancelSyntheticClickEvents"]) {
  // use a document-wide touchend listener to start the ghost-click prevention mechanism
  // Use passive event listeners, if supported, to not affect scrolling performance
  document.addEventListener('touchend', ignoreMouse, supportsPassive ? {
    passive: true
  } : false);
}
/**
 * Returns the composedPath for the given event.
 * @param {Event} event to process
 * @return {!Array<!EventTarget>} Path of the event
 */


const getComposedPath = window.ShadyDOM && window.ShadyDOM.noPatch ? window.ShadyDOM.composedPath : event => event.composedPath && event.composedPath() || [];
/** @type {!Object<string, !GestureRecognizer>} */

const gestures = {};
/** @type {!Array<!GestureRecognizer>} */

const recognizers = [];
/**
 * Finds the element rendered on the screen at the provided coordinates.
 *
 * Similar to `document.elementFromPoint`, but pierces through
 * shadow roots.
 *
 * @param {number} x Horizontal pixel coordinate
 * @param {number} y Vertical pixel coordinate
 * @return {Element} Returns the deepest shadowRoot inclusive element
 * found at the screen position given.
 */

function deepTargetFind(x, y) {
  let node = document.elementFromPoint(x, y);
  let next = node; // this code path is only taken when native ShadowDOM is used
  // if there is a shadowroot, it may have a node at x/y
  // if there is not a shadowroot, exit the loop

  while (next && next.shadowRoot && !window.ShadyDOM) {
    // if there is a node at x/y in the shadowroot, look deeper
    let oldNext = next;
    next = next.shadowRoot.elementFromPoint(x, y); // on Safari, elementFromPoint may return the shadowRoot host

    if (oldNext === next) {
      break;
    }

    if (next) {
      node = next;
    }
  }

  return node;
}
/**
 * a cheaper check than ev.composedPath()[0];
 *
 * @private
 * @param {Event|Touch} ev Event.
 * @return {EventTarget} Returns the event target.
 */

function _findOriginalTarget(ev) {
  const path = getComposedPath(
  /** @type {?Event} */
  ev); // It shouldn't be, but sometimes path is empty (window on Safari).

  return path.length > 0 ? path[0] : ev.target;
}
/**
 * @private
 * @param {Event} ev Event.
 * @return {void}
 */


function _handleNative(ev) {
  let handled;
  let type = ev.type;
  let node = ev.currentTarget;
  let gobj = node[GESTURE_KEY];

  if (!gobj) {
    return;
  }

  let gs = gobj[type];

  if (!gs) {
    return;
  }

  if (!ev[HANDLED_OBJ]) {
    ev[HANDLED_OBJ] = {};

    if (type.slice(0, 5) === 'touch') {
      ev =
      /** @type {TouchEvent} */
      ev; // eslint-disable-line no-self-assign

      let t = ev.changedTouches[0];

      if (type === 'touchstart') {
        // only handle the first finger
        if (ev.touches.length === 1) {
          POINTERSTATE.touch.id = t.identifier;
        }
      }

      if (POINTERSTATE.touch.id !== t.identifier) {
        return;
      }

      if (!HAS_NATIVE_TA) {
        if (type === 'touchstart' || type === 'touchmove') {
          _handleTouchAction(ev);
        }
      }
    }
  }

  handled = ev[HANDLED_OBJ]; // used to ignore synthetic mouse events

  if (handled.skip) {
    return;
  } // reset recognizer state


  for (let i = 0, r; i < recognizers.length; i++) {
    r = recognizers[i];

    if (gs[r.name] && !handled[r.name]) {
      if (r.flow && r.flow.start.indexOf(ev.type) > -1 && r.reset) {
        r.reset();
      }
    }
  } // enforce gesture recognizer order


  for (let i = 0, r; i < recognizers.length; i++) {
    r = recognizers[i];

    if (gs[r.name] && !handled[r.name]) {
      handled[r.name] = true;
      r[type](ev);
    }
  }
}
/**
 * @private
 * @param {TouchEvent} ev Event.
 * @return {void}
 */


function _handleTouchAction(ev) {
  let t = ev.changedTouches[0];
  let type = ev.type;

  if (type === 'touchstart') {
    POINTERSTATE.touch.x = t.clientX;
    POINTERSTATE.touch.y = t.clientY;
    POINTERSTATE.touch.scrollDecided = false;
  } else if (type === 'touchmove') {
    if (POINTERSTATE.touch.scrollDecided) {
      return;
    }

    POINTERSTATE.touch.scrollDecided = true;
    let ta = firstTouchAction(ev);
    let shouldPrevent = false;
    let dx = Math.abs(POINTERSTATE.touch.x - t.clientX);
    let dy = Math.abs(POINTERSTATE.touch.y - t.clientY);

    if (!ev.cancelable) {// scrolling is happening
    } else if (ta === 'none') {
      shouldPrevent = true;
    } else if (ta === 'pan-x') {
      shouldPrevent = dy > dx;
    } else if (ta === 'pan-y') {
      shouldPrevent = dx > dy;
    }

    if (shouldPrevent) {
      ev.preventDefault();
    } else {
      prevent('track');
    }
  }
}
/**
 * Adds an event listener to a node for the given gesture type.
 *
 * @param {!EventTarget} node Node to add listener on
 * @param {string} evType Gesture type: `down`, `up`, `track`, or `tap`
 * @param {!function(!Event):void} handler Event listener function to call
 * @return {boolean} Returns true if a gesture event listener was added.
 */


function addListener(node, evType, handler) {
  if (gestures[evType]) {
    _add(node, evType, handler);

    return true;
  }

  return false;
}
/**
 * Removes an event listener from a node for the given gesture type.
 *
 * @param {!EventTarget} node Node to remove listener from
 * @param {string} evType Gesture type: `down`, `up`, `track`, or `tap`
 * @param {!function(!Event):void} handler Event listener function previously passed to
 *  `addListener`.
 * @return {boolean} Returns true if a gesture event listener was removed.
 */

function removeListener(node, evType, handler) {
  if (gestures[evType]) {
    _remove(node, evType, handler);

    return true;
  }

  return false;
}
/**
 * automate the event listeners for the native events
 *
 * @private
 * @param {!EventTarget} node Node on which to add the event.
 * @param {string} evType Event type to add.
 * @param {function(!Event)} handler Event handler function.
 * @return {void}
 */

function _add(node, evType, handler) {
  let recognizer = gestures[evType];
  let deps = recognizer.deps;
  let name = recognizer.name;
  let gobj = node[GESTURE_KEY];

  if (!gobj) {
    node[GESTURE_KEY] = gobj = {};
  }

  for (let i = 0, dep, gd; i < deps.length; i++) {
    dep = deps[i]; // don't add mouse handlers on iOS because they cause gray selection overlays

    if (IS_TOUCH_ONLY && isMouseEvent(dep) && dep !== 'click') {
      continue;
    }

    gd = gobj[dep];

    if (!gd) {
      gobj[dep] = gd = {
        _count: 0
      };
    }

    if (gd._count === 0) {
      node.addEventListener(dep, _handleNative, PASSIVE_TOUCH(dep));
    }

    gd[name] = (gd[name] || 0) + 1;
    gd._count = (gd._count || 0) + 1;
  }

  node.addEventListener(evType, handler);

  if (recognizer.touchAction) {
    setTouchAction(node, recognizer.touchAction);
  }
}
/**
 * automate event listener removal for native events
 *
 * @private
 * @param {!EventTarget} node Node on which to remove the event.
 * @param {string} evType Event type to remove.
 * @param {function(!Event): void} handler Event handler function.
 * @return {void}
 */


function _remove(node, evType, handler) {
  let recognizer = gestures[evType];
  let deps = recognizer.deps;
  let name = recognizer.name;
  let gobj = node[GESTURE_KEY];

  if (gobj) {
    for (let i = 0, dep, gd; i < deps.length; i++) {
      dep = deps[i];
      gd = gobj[dep];

      if (gd && gd[name]) {
        gd[name] = (gd[name] || 1) - 1;
        gd._count = (gd._count || 1) - 1;

        if (gd._count === 0) {
          node.removeEventListener(dep, _handleNative, PASSIVE_TOUCH(dep));
        }
      }
    }
  }

  node.removeEventListener(evType, handler);
}
/**
 * Registers a new gesture event recognizer for adding new custom
 * gesture event types.
 *
 * @param {!GestureRecognizer} recog Gesture recognizer descriptor
 * @return {void}
 */


function register(recog) {
  recognizers.push(recog);

  for (let i = 0; i < recog.emits.length; i++) {
    gestures[recog.emits[i]] = recog;
  }
}
/**
 * @private
 * @param {string} evName Event name.
 * @return {Object} Returns the gesture for the given event name.
 */

function _findRecognizerByEvent(evName) {
  for (let i = 0, r; i < recognizers.length; i++) {
    r = recognizers[i];

    for (let j = 0, n; j < r.emits.length; j++) {
      n = r.emits[j];

      if (n === evName) {
        return r;
      }
    }
  }

  return null;
}
/**
 * Sets scrolling direction on node.
 *
 * This value is checked on first move, thus it should be called prior to
 * adding event listeners.
 *
 * @param {!EventTarget} node Node to set touch action setting on
 * @param {string} value Touch action value
 * @return {void}
 */


function setTouchAction(node, value) {
  if (HAS_NATIVE_TA && node instanceof HTMLElement) {
    // NOTE: add touchAction async so that events can be added in
    // custom element constructors. Otherwise we run afoul of custom
    // elements restriction against settings attributes (style) in the
    // constructor.
    _async_js__WEBPACK_IMPORTED_MODULE_1__["microTask"].run(() => {
      node.style.touchAction = value;
    });
  }

  node[TOUCH_ACTION] = value;
}
/**
 * Dispatches an event on the `target` element of `type` with the given
 * `detail`.
 * @private
 * @param {!EventTarget} target The element on which to fire an event.
 * @param {string} type The type of event to fire.
 * @param {!Object=} detail The detail object to populate on the event.
 * @return {void}
 */

function _fire(target, type, detail) {
  let ev = new Event(type, {
    bubbles: true,
    cancelable: true,
    composed: true
  });
  ev.detail = detail;
  Object(_wrap_js__WEBPACK_IMPORTED_MODULE_4__["wrap"])(
  /** @type {!Node} */
  target).dispatchEvent(ev); // forward `preventDefault` in a clean way

  if (ev.defaultPrevented) {
    let preventer = detail.preventer || detail.sourceEvent;

    if (preventer && preventer.preventDefault) {
      preventer.preventDefault();
    }
  }
}
/**
 * Prevents the dispatch and default action of the given event name.
 *
 * @param {string} evName Event name.
 * @return {void}
 */


function prevent(evName) {
  let recognizer = _findRecognizerByEvent(evName);

  if (recognizer.info) {
    recognizer.info.prevent = true;
  }
}
/**
 * Reset the 2500ms timeout on processing mouse input after detecting touch input.
 *
 * Touch inputs create synthesized mouse inputs anywhere from 0 to 2000ms after the touch.
 * This method should only be called during testing with simulated touch inputs.
 * Calling this method in production may cause duplicate taps or other Gestures.
 *
 * @return {void}
 */

function resetMouseCanceller() {
  if (POINTERSTATE.mouse.mouseIgnoreJob) {
    POINTERSTATE.mouse.mouseIgnoreJob.flush();
  }
}
/* eslint-disable valid-jsdoc */

register({
  name: 'downup',
  deps: ['mousedown', 'touchstart', 'touchend'],
  flow: {
    start: ['mousedown', 'touchstart'],
    end: ['mouseup', 'touchend']
  },
  emits: ['down', 'up'],
  info: {
    movefn: null,
    upfn: null
  },

  /**
   * @this {GestureRecognizer}
   * @return {void}
   */
  reset: function () {
    untrackDocument(this.info);
  },

  /**
   * @this {GestureRecognizer}
   * @param {MouseEvent} e
   * @return {void}
   */
  mousedown: function (e) {
    if (!hasLeftMouseButton(e)) {
      return;
    }

    let t = _findOriginalTarget(e);

    let self = this;

    let movefn = function movefn(e) {
      if (!hasLeftMouseButton(e)) {
        downupFire('up', t, e);
        untrackDocument(self.info);
      }
    };

    let upfn = function upfn(e) {
      if (hasLeftMouseButton(e)) {
        downupFire('up', t, e);
      }

      untrackDocument(self.info);
    };

    trackDocument(this.info, movefn, upfn);
    downupFire('down', t, e);
  },

  /**
   * @this {GestureRecognizer}
   * @param {TouchEvent} e
   * @return {void}
   */
  touchstart: function (e) {
    downupFire('down', _findOriginalTarget(e), e.changedTouches[0], e);
  },

  /**
   * @this {GestureRecognizer}
   * @param {TouchEvent} e
   * @return {void}
   */
  touchend: function (e) {
    downupFire('up', _findOriginalTarget(e), e.changedTouches[0], e);
  }
});
/**
 * @param {string} type
 * @param {EventTarget} target
 * @param {Event|Touch} event
 * @param {Event=} preventer
 * @return {void}
 */

function downupFire(type, target, event, preventer) {
  if (!target) {
    return;
  }

  _fire(target, type, {
    x: event.clientX,
    y: event.clientY,
    sourceEvent: event,
    preventer: preventer,
    prevent: function (e) {
      return prevent(e);
    }
  });
}

register({
  name: 'track',
  touchAction: 'none',
  deps: ['mousedown', 'touchstart', 'touchmove', 'touchend'],
  flow: {
    start: ['mousedown', 'touchstart'],
    end: ['mouseup', 'touchend']
  },
  emits: ['track'],
  info: {
    x: 0,
    y: 0,
    state: 'start',
    started: false,
    moves: [],

    /** @this {GestureInfo} */
    addMove: function (move) {
      if (this.moves.length > TRACK_LENGTH) {
        this.moves.shift();
      }

      this.moves.push(move);
    },
    movefn: null,
    upfn: null,
    prevent: false
  },

  /**
   * @this {GestureRecognizer}
   * @return {void}
   */
  reset: function () {
    this.info.state = 'start';
    this.info.started = false;
    this.info.moves = [];
    this.info.x = 0;
    this.info.y = 0;
    this.info.prevent = false;
    untrackDocument(this.info);
  },

  /**
   * @this {GestureRecognizer}
   * @param {MouseEvent} e
   * @return {void}
   */
  mousedown: function (e) {
    if (!hasLeftMouseButton(e)) {
      return;
    }

    let t = _findOriginalTarget(e);

    let self = this;

    let movefn = function movefn(e) {
      let x = e.clientX,
          y = e.clientY;

      if (trackHasMovedEnough(self.info, x, y)) {
        // first move is 'start', subsequent moves are 'move', mouseup is 'end'
        self.info.state = self.info.started ? e.type === 'mouseup' ? 'end' : 'track' : 'start';

        if (self.info.state === 'start') {
          // if and only if tracking, always prevent tap
          prevent('tap');
        }

        self.info.addMove({
          x: x,
          y: y
        });

        if (!hasLeftMouseButton(e)) {
          // always fire "end"
          self.info.state = 'end';
          untrackDocument(self.info);
        }

        if (t) {
          trackFire(self.info, t, e);
        }

        self.info.started = true;
      }
    };

    let upfn = function upfn(e) {
      if (self.info.started) {
        movefn(e);
      } // remove the temporary listeners


      untrackDocument(self.info);
    }; // add temporary document listeners as mouse retargets


    trackDocument(this.info, movefn, upfn);
    this.info.x = e.clientX;
    this.info.y = e.clientY;
  },

  /**
   * @this {GestureRecognizer}
   * @param {TouchEvent} e
   * @return {void}
   */
  touchstart: function (e) {
    let ct = e.changedTouches[0];
    this.info.x = ct.clientX;
    this.info.y = ct.clientY;
  },

  /**
   * @this {GestureRecognizer}
   * @param {TouchEvent} e
   * @return {void}
   */
  touchmove: function (e) {
    let t = _findOriginalTarget(e);

    let ct = e.changedTouches[0];
    let x = ct.clientX,
        y = ct.clientY;

    if (trackHasMovedEnough(this.info, x, y)) {
      if (this.info.state === 'start') {
        // if and only if tracking, always prevent tap
        prevent('tap');
      }

      this.info.addMove({
        x: x,
        y: y
      });
      trackFire(this.info, t, ct);
      this.info.state = 'track';
      this.info.started = true;
    }
  },

  /**
   * @this {GestureRecognizer}
   * @param {TouchEvent} e
   * @return {void}
   */
  touchend: function (e) {
    let t = _findOriginalTarget(e);

    let ct = e.changedTouches[0]; // only trackend if track was started and not aborted

    if (this.info.started) {
      // reset started state on up
      this.info.state = 'end';
      this.info.addMove({
        x: ct.clientX,
        y: ct.clientY
      });
      trackFire(this.info, t, ct);
    }
  }
});
/**
 * @param {!GestureInfo} info
 * @param {number} x
 * @param {number} y
 * @return {boolean}
 */

function trackHasMovedEnough(info, x, y) {
  if (info.prevent) {
    return false;
  }

  if (info.started) {
    return true;
  }

  let dx = Math.abs(info.x - x);
  let dy = Math.abs(info.y - y);
  return dx >= TRACK_DISTANCE || dy >= TRACK_DISTANCE;
}
/**
 * @param {!GestureInfo} info
 * @param {?EventTarget} target
 * @param {Touch} touch
 * @return {void}
 */


function trackFire(info, target, touch) {
  if (!target) {
    return;
  }

  let secondlast = info.moves[info.moves.length - 2];
  let lastmove = info.moves[info.moves.length - 1];
  let dx = lastmove.x - info.x;
  let dy = lastmove.y - info.y;
  let ddx,
      ddy = 0;

  if (secondlast) {
    ddx = lastmove.x - secondlast.x;
    ddy = lastmove.y - secondlast.y;
  }

  _fire(target, 'track', {
    state: info.state,
    x: touch.clientX,
    y: touch.clientY,
    dx: dx,
    dy: dy,
    ddx: ddx,
    ddy: ddy,
    sourceEvent: touch,
    hover: function () {
      return deepTargetFind(touch.clientX, touch.clientY);
    }
  });
}

register({
  name: 'tap',
  deps: ['mousedown', 'click', 'touchstart', 'touchend'],
  flow: {
    start: ['mousedown', 'touchstart'],
    end: ['click', 'touchend']
  },
  emits: ['tap'],
  info: {
    x: NaN,
    y: NaN,
    prevent: false
  },

  /**
   * @this {GestureRecognizer}
   * @return {void}
   */
  reset: function () {
    this.info.x = NaN;
    this.info.y = NaN;
    this.info.prevent = false;
  },

  /**
   * @this {GestureRecognizer}
   * @param {MouseEvent} e
   * @return {void}
   */
  mousedown: function (e) {
    if (hasLeftMouseButton(e)) {
      this.info.x = e.clientX;
      this.info.y = e.clientY;
    }
  },

  /**
   * @this {GestureRecognizer}
   * @param {MouseEvent} e
   * @return {void}
   */
  click: function (e) {
    if (hasLeftMouseButton(e)) {
      trackForward(this.info, e);
    }
  },

  /**
   * @this {GestureRecognizer}
   * @param {TouchEvent} e
   * @return {void}
   */
  touchstart: function (e) {
    const touch = e.changedTouches[0];
    this.info.x = touch.clientX;
    this.info.y = touch.clientY;
  },

  /**
   * @this {GestureRecognizer}
   * @param {TouchEvent} e
   * @return {void}
   */
  touchend: function (e) {
    trackForward(this.info, e.changedTouches[0], e);
  }
});
/**
 * @param {!GestureInfo} info
 * @param {Event | Touch} e
 * @param {Event=} preventer
 * @return {void}
 */

function trackForward(info, e, preventer) {
  let dx = Math.abs(e.clientX - info.x);
  let dy = Math.abs(e.clientY - info.y); // find original target from `preventer` for TouchEvents, or `e` for MouseEvents

  let t = _findOriginalTarget(preventer || e);

  if (!t || canBeDisabled[
  /** @type {!HTMLElement} */
  t.localName] && t.hasAttribute('disabled')) {
    return;
  } // dx,dy can be NaN if `click` has been simulated and there was no `down` for `start`


  if (isNaN(dx) || isNaN(dy) || dx <= TAP_DISTANCE && dy <= TAP_DISTANCE || isSyntheticClick(e)) {
    // prevent taps from being generated if an event has canceled them
    if (!info.prevent) {
      _fire(t, 'tap', {
        x: e.clientX,
        y: e.clientY,
        sourceEvent: e,
        preventer: preventer
      });
    }
  }
}
/* eslint-enable valid-jsdoc */

/** @deprecated */


const findOriginalTarget = _findOriginalTarget;
/** @deprecated */

const add = addListener;
/** @deprecated */

const remove = removeListener;

/***/ }),

/***/ "./node_modules/@polymer/polymer/lib/utils/hide-template-controls.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@polymer/polymer/lib/utils/hide-template-controls.js ***!
  \***************************************************************************/
/*! exports provided: hideElementsGlobally */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hideElementsGlobally", function() { return hideElementsGlobally; });
/* harmony import */ var _settings_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./settings.js */ "./node_modules/@polymer/polymer/lib/utils/settings.js");
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

/**
 * @fileoverview
 *
 * Module to hide `<dom-bind>`, `<dom-if>`, and `<dom-repeat>` elements
 * optimally in ShadyDOM
 */

let elementsHidden = false;
/**
 * @return {boolean} True if elements will be hidden globally
 */

function hideElementsGlobally() {
  if (_settings_js__WEBPACK_IMPORTED_MODULE_0__["legacyOptimizations"] && !_settings_js__WEBPACK_IMPORTED_MODULE_0__["useShadow"]) {
    if (!elementsHidden) {
      elementsHidden = true;
      const style = document.createElement('style');
      style.textContent = 'dom-bind,dom-if,dom-repeat{display:none;}';
      document.head.appendChild(style);
    }

    return true;
  }

  return false;
}

/***/ }),

/***/ "./node_modules/@polymer/polymer/lib/utils/html-tag.js":
/*!*************************************************************!*\
  !*** ./node_modules/@polymer/polymer/lib/utils/html-tag.js ***!
  \*************************************************************/
/*! exports provided: html, htmlLiteral */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "html", function() { return html; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "htmlLiteral", function() { return htmlLiteral; });
/* harmony import */ var _boot_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./boot.js */ "./node_modules/@polymer/polymer/lib/utils/boot.js");
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

/**
 * Class representing a static string value which can be used to filter
 * strings by asseting that they have been created via this class. The
 * `value` property returns the string passed to the constructor.
 */

class LiteralString {
  constructor(string) {
    /** @type {string} */
    this.value = string.toString();
  }
  /**
   * @return {string} LiteralString string value
   * @override
   */


  toString() {
    return this.value;
  }

}
/**
 * @param {*} value Object to stringify into HTML
 * @return {string} HTML stringified form of `obj`
 */


function literalValue(value) {
  if (value instanceof LiteralString) {
    return (
      /** @type {!LiteralString} */
      value.value
    );
  } else {
    throw new Error(`non-literal value passed to Polymer's htmlLiteral function: ${value}`);
  }
}
/**
 * @param {*} value Object to stringify into HTML
 * @return {string} HTML stringified form of `obj`
 */


function htmlValue(value) {
  if (value instanceof HTMLTemplateElement) {
    return (
      /** @type {!HTMLTemplateElement } */
      value.innerHTML
    );
  } else if (value instanceof LiteralString) {
    return literalValue(value);
  } else {
    throw new Error(`non-template value passed to Polymer's html function: ${value}`);
  }
}
/**
 * A template literal tag that creates an HTML <template> element from the
 * contents of the string.
 *
 * This allows you to write a Polymer Template in JavaScript.
 *
 * Templates can be composed by interpolating `HTMLTemplateElement`s in
 * expressions in the JavaScript template literal. The nested template's
 * `innerHTML` is included in the containing template.  The only other
 * values allowed in expressions are those returned from `htmlLiteral`
 * which ensures only literal values from JS source ever reach the HTML, to
 * guard against XSS risks.
 *
 * All other values are disallowed in expressions to help prevent XSS
 * attacks; however, `htmlLiteral` can be used to compose static
 * string values into templates. This is useful to compose strings into
 * places that do not accept html, like the css text of a `style`
 * element.
 *
 * Example:
 *
 *     static get template() {
 *       return html`
 *         <style>:host{ content:"..." }</style>
 *         <div class="shadowed">${this.partialTemplate}</div>
 *         ${super.template}
 *       `;
 *     }
 *     static get partialTemplate() { return html`<span>Partial!</span>`; }
 *
 * @param {!ITemplateArray} strings Constant parts of tagged template literal
 * @param {...*} values Variable parts of tagged template literal
 * @return {!HTMLTemplateElement} Constructed HTMLTemplateElement
 */


const html = function html(strings, ...values) {
  const template =
  /** @type {!HTMLTemplateElement} */
  document.createElement('template');
  template.innerHTML = values.reduce((acc, v, idx) => acc + htmlValue(v) + strings[idx + 1], strings[0]);
  return template;
};
/**
 * An html literal tag that can be used with `html` to compose.
 * a literal string.
 *
 * Example:
 *
 *     static get template() {
 *       return html`
 *         <style>
 *           :host { display: block; }
 *           ${this.styleTemplate()}
 *         </style>
 *         <div class="shadowed">${staticValue}</div>
 *         ${super.template}
 *       `;
 *     }
 *     static get styleTemplate() {
 *        return htmlLiteral`.shadowed { background: gray; }`;
 *     }
 *
 * @param {!ITemplateArray} strings Constant parts of tagged template literal
 * @param {...*} values Variable parts of tagged template literal
 * @return {!LiteralString} Constructed literal string
 */

const htmlLiteral = function (strings, ...values) {
  return new LiteralString(values.reduce((acc, v, idx) => acc + literalValue(v) + strings[idx + 1], strings[0]));
};

/***/ }),

/***/ "./node_modules/@polymer/polymer/lib/utils/mixin.js":
/*!**********************************************************!*\
  !*** ./node_modules/@polymer/polymer/lib/utils/mixin.js ***!
  \**********************************************************/
/*! exports provided: dedupingMixin */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dedupingMixin", function() { return dedupingMixin; });
/* harmony import */ var _boot_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./boot.js */ "./node_modules/@polymer/polymer/lib/utils/boot.js");
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
 // unique global id for deduping mixins.

let dedupeId = 0;
/**
 * @constructor
 * @extends {Function}
 * @private
 */

function MixinFunction() {}
/** @type {(WeakMap | undefined)} */


MixinFunction.prototype.__mixinApplications;
/** @type {(Object | undefined)} */

MixinFunction.prototype.__mixinSet;
/* eslint-disable valid-jsdoc */

/**
 * Wraps an ES6 class expression mixin such that the mixin is only applied
 * if it has not already been applied its base argument. Also memoizes mixin
 * applications.
 *
 * @template T
 * @param {T} mixin ES6 class expression mixin to wrap
 * @return {T}
 * @suppress {invalidCasts}
 */

const dedupingMixin = function (mixin) {
  let mixinApplications =
  /** @type {!MixinFunction} */
  mixin.__mixinApplications;

  if (!mixinApplications) {
    mixinApplications = new WeakMap();
    /** @type {!MixinFunction} */

    mixin.__mixinApplications = mixinApplications;
  } // maintain a unique id for each mixin


  let mixinDedupeId = dedupeId++;

  function dedupingMixin(base) {
    let baseSet =
    /** @type {!MixinFunction} */
    base.__mixinSet;

    if (baseSet && baseSet[mixinDedupeId]) {
      return base;
    }

    let map = mixinApplications;
    let extended = map.get(base);

    if (!extended) {
      extended =
      /** @type {!Function} */
      mixin(base);
      map.set(base, extended); // copy inherited mixin set from the extended class, or the base class
      // NOTE: we avoid use of Set here because some browser (IE11)
      // cannot extend a base Set via the constructor.

      let mixinSet = Object.create(
      /** @type {!MixinFunction} */
      extended.__mixinSet || baseSet || null);
      mixinSet[mixinDedupeId] = true;
      /** @type {!MixinFunction} */

      extended.__mixinSet = mixinSet;
    }

    return extended;
  }

  return dedupingMixin;
};
/* eslint-enable valid-jsdoc */

/***/ }),

/***/ "./node_modules/@polymer/polymer/lib/utils/path.js":
/*!*********************************************************!*\
  !*** ./node_modules/@polymer/polymer/lib/utils/path.js ***!
  \*********************************************************/
/*! exports provided: isPath, root, isAncestor, isDescendant, translate, matches, normalize, split, get, set, isDeep */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isPath", function() { return isPath; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "root", function() { return root; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isAncestor", function() { return isAncestor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isDescendant", function() { return isDescendant; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "translate", function() { return translate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "matches", function() { return matches; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalize", function() { return normalize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "split", function() { return split; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "get", function() { return get; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isDeep", function() { return isDeep; });
/* harmony import */ var _boot_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./boot.js */ "./node_modules/@polymer/polymer/lib/utils/boot.js");
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

/**
 * Module with utilities for manipulating structured data path strings.
 *
 * @summary Module with utilities for manipulating structured data path strings.
 */

/**
 * Returns true if the given string is a structured data path (has dots).
 *
 * Example:
 *
 * ```
 * isPath('foo.bar.baz') // true
 * isPath('foo')         // false
 * ```
 *
 * @param {string} path Path string
 * @return {boolean} True if the string contained one or more dots
 */

function isPath(path) {
  return path.indexOf('.') >= 0;
}
/**
 * Returns the root property name for the given path.
 *
 * Example:
 *
 * ```
 * root('foo.bar.baz') // 'foo'
 * root('foo')         // 'foo'
 * ```
 *
 * @param {string} path Path string
 * @return {string} Root property name
 */

function root(path) {
  let dotIndex = path.indexOf('.');

  if (dotIndex === -1) {
    return path;
  }

  return path.slice(0, dotIndex);
}
/**
 * Given `base` is `foo.bar`, `foo` is an ancestor, `foo.bar` is not
 * Returns true if the given path is an ancestor of the base path.
 *
 * Example:
 *
 * ```
 * isAncestor('foo.bar', 'foo')         // true
 * isAncestor('foo.bar', 'foo.bar')     // false
 * isAncestor('foo.bar', 'foo.bar.baz') // false
 * ```
 *
 * @param {string} base Path string to test against.
 * @param {string} path Path string to test.
 * @return {boolean} True if `path` is an ancestor of `base`.
 */

function isAncestor(base, path) {
  //     base.startsWith(path + '.');
  return base.indexOf(path + '.') === 0;
}
/**
 * Given `base` is `foo.bar`, `foo.bar.baz` is an descendant
 *
 * Example:
 *
 * ```
 * isDescendant('foo.bar', 'foo.bar.baz') // true
 * isDescendant('foo.bar', 'foo.bar')     // false
 * isDescendant('foo.bar', 'foo')         // false
 * ```
 *
 * @param {string} base Path string to test against.
 * @param {string} path Path string to test.
 * @return {boolean} True if `path` is a descendant of `base`.
 */

function isDescendant(base, path) {
  //     path.startsWith(base + '.');
  return path.indexOf(base + '.') === 0;
}
/**
 * Replaces a previous base path with a new base path, preserving the
 * remainder of the path.
 *
 * User must ensure `path` has a prefix of `base`.
 *
 * Example:
 *
 * ```
 * translate('foo.bar', 'zot', 'foo.bar.baz') // 'zot.baz'
 * ```
 *
 * @param {string} base Current base string to remove
 * @param {string} newBase New base string to replace with
 * @param {string} path Path to translate
 * @return {string} Translated string
 */

function translate(base, newBase, path) {
  return newBase + path.slice(base.length);
}
/**
 * @param {string} base Path string to test against
 * @param {string} path Path string to test
 * @return {boolean} True if `path` is equal to `base`
 */

function matches(base, path) {
  return base === path || isAncestor(base, path) || isDescendant(base, path);
}
/**
 * Converts array-based paths to flattened path.  String-based paths
 * are returned as-is.
 *
 * Example:
 *
 * ```
 * normalize(['foo.bar', 0, 'baz'])  // 'foo.bar.0.baz'
 * normalize('foo.bar.0.baz')        // 'foo.bar.0.baz'
 * ```
 *
 * @param {string | !Array<string|number>} path Input path
 * @return {string} Flattened path
 */

function normalize(path) {
  if (Array.isArray(path)) {
    let parts = [];

    for (let i = 0; i < path.length; i++) {
      let args = path[i].toString().split('.');

      for (let j = 0; j < args.length; j++) {
        parts.push(args[j]);
      }
    }

    return parts.join('.');
  } else {
    return path;
  }
}
/**
 * Splits a path into an array of property names. Accepts either arrays
 * of path parts or strings.
 *
 * Example:
 *
 * ```
 * split(['foo.bar', 0, 'baz'])  // ['foo', 'bar', '0', 'baz']
 * split('foo.bar.0.baz')        // ['foo', 'bar', '0', 'baz']
 * ```
 *
 * @param {string | !Array<string|number>} path Input path
 * @return {!Array<string>} Array of path parts
 * @suppress {checkTypes}
 */

function split(path) {
  if (Array.isArray(path)) {
    return normalize(path).split('.');
  }

  return path.toString().split('.');
}
/**
 * Reads a value from a path.  If any sub-property in the path is `undefined`,
 * this method returns `undefined` (will never throw.
 *
 * @param {Object} root Object from which to dereference path from
 * @param {string | !Array<string|number>} path Path to read
 * @param {Object=} info If an object is provided to `info`, the normalized
 *  (flattened) path will be set to `info.path`.
 * @return {*} Value at path, or `undefined` if the path could not be
 *  fully dereferenced.
 */

function get(root, path, info) {
  let prop = root;
  let parts = split(path); // Loop over path parts[0..n-1] and dereference

  for (let i = 0; i < parts.length; i++) {
    if (!prop) {
      return;
    }

    let part = parts[i];
    prop = prop[part];
  }

  if (info) {
    info.path = parts.join('.');
  }

  return prop;
}
/**
 * Sets a value to a path.  If any sub-property in the path is `undefined`,
 * this method will no-op.
 *
 * @param {Object} root Object from which to dereference path from
 * @param {string | !Array<string|number>} path Path to set
 * @param {*} value Value to set to path
 * @return {string | undefined} The normalized version of the input path
 */

function set(root, path, value) {
  let prop = root;
  let parts = split(path);
  let last = parts[parts.length - 1];

  if (parts.length > 1) {
    // Loop over path parts[0..n-2] and dereference
    for (let i = 0; i < parts.length - 1; i++) {
      let part = parts[i];
      prop = prop[part];

      if (!prop) {
        return;
      }
    } // Set value to object at end of path


    prop[last] = value;
  } else {
    // Simple property set
    prop[path] = value;
  }

  return parts.join('.');
}
/**
 * Returns true if the given string is a structured data path (has dots).
 *
 * This function is deprecated.  Use `isPath` instead.
 *
 * Example:
 *
 * ```
 * isDeep('foo.bar.baz') // true
 * isDeep('foo')         // false
 * ```
 *
 * @deprecated
 * @param {string} path Path string
 * @return {boolean} True if the string contained one or more dots
 */

const isDeep = isPath;

/***/ }),

/***/ "./node_modules/@polymer/polymer/lib/utils/resolve-url.js":
/*!****************************************************************!*\
  !*** ./node_modules/@polymer/polymer/lib/utils/resolve-url.js ***!
  \****************************************************************/
/*! exports provided: resolveUrl, resolveCss, pathFromUrl */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resolveUrl", function() { return resolveUrl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resolveCss", function() { return resolveCss; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pathFromUrl", function() { return pathFromUrl; });
/* harmony import */ var _boot_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./boot.js */ "./node_modules/@polymer/polymer/lib/utils/boot.js");
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

let CSS_URL_RX = /(url\()([^)]*)(\))/g;
let ABS_URL = /(^\/[^\/])|(^#)|(^[\w-\d]*:)/;
let workingURL;
let resolveDoc;
/**
 * Resolves the given URL against the provided `baseUri'.
 *
 * Note that this function performs no resolution for URLs that start
 * with `/` (absolute URLs) or `#` (hash identifiers).  For general purpose
 * URL resolution, use `window.URL`.
 *
 * @param {string} url Input URL to resolve
 * @param {?string=} baseURI Base URI to resolve the URL against
 * @return {string} resolved URL
 */

function resolveUrl(url, baseURI) {
  if (url && ABS_URL.test(url)) {
    return url;
  }

  if (url === '//') {
    return url;
  } // Lazy feature detection.


  if (workingURL === undefined) {
    workingURL = false;

    try {
      const u = new URL('b', 'http://a');
      u.pathname = 'c%20d';
      workingURL = u.href === 'http://a/c%20d';
    } catch (e) {// silently fail
    }
  }

  if (!baseURI) {
    baseURI = document.baseURI || window.location.href;
  }

  if (workingURL) {
    try {
      return new URL(url, baseURI).href;
    } catch (e) {
      // Bad url or baseURI structure. Do not attempt to resolve.
      return url;
    }
  } // Fallback to creating an anchor into a disconnected document.


  if (!resolveDoc) {
    resolveDoc = document.implementation.createHTMLDocument('temp');
    resolveDoc.base = resolveDoc.createElement('base');
    resolveDoc.head.appendChild(resolveDoc.base);
    resolveDoc.anchor = resolveDoc.createElement('a');
    resolveDoc.body.appendChild(resolveDoc.anchor);
  }

  resolveDoc.base.href = baseURI;
  resolveDoc.anchor.href = url;
  return resolveDoc.anchor.href || url;
}
/**
 * Resolves any relative URL's in the given CSS text against the provided
 * `ownerDocument`'s `baseURI`.
 *
 * @param {string} cssText CSS text to process
 * @param {string} baseURI Base URI to resolve the URL against
 * @return {string} Processed CSS text with resolved URL's
 */

function resolveCss(cssText, baseURI) {
  return cssText.replace(CSS_URL_RX, function (m, pre, url, post) {
    return pre + '\'' + resolveUrl(url.replace(/["']/g, ''), baseURI) + '\'' + post;
  });
}
/**
 * Returns a path from a given `url`. The path includes the trailing
 * `/` from the url.
 *
 * @param {string} url Input URL to transform
 * @return {string} resolved path
 */

function pathFromUrl(url) {
  return url.substring(0, url.lastIndexOf('/') + 1);
}

/***/ }),

/***/ "./node_modules/@polymer/polymer/lib/utils/settings.js":
/*!*************************************************************!*\
  !*** ./node_modules/@polymer/polymer/lib/utils/settings.js ***!
  \*************************************************************/
/*! exports provided: useShadow, useNativeCSSProperties, useNativeCustomElements, supportsAdoptingStyleSheets, rootPath, setRootPath, sanitizeDOMValue, setSanitizeDOMValue, getSanitizeDOMValue, passiveTouchGestures, setPassiveTouchGestures, strictTemplatePolicy, setStrictTemplatePolicy, allowTemplateFromDomModule, setAllowTemplateFromDomModule, legacyOptimizations, setLegacyOptimizations, legacyWarnings, setLegacyWarnings, syncInitialRender, setSyncInitialRender, legacyUndefined, setLegacyUndefined, orderedComputed, setOrderedComputed, cancelSyntheticClickEvents, setCancelSyntheticClickEvents, removeNestedTemplates, setRemoveNestedTemplates, fastDomIf, setFastDomIf, suppressTemplateNotifications, setSuppressTemplateNotifications, legacyNoObservedAttributes, setLegacyNoObservedAttributes, useAdoptedStyleSheetsWithBuiltCSS, setUseAdoptedStyleSheetsWithBuiltCSS */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useShadow", function() { return useShadow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useNativeCSSProperties", function() { return useNativeCSSProperties; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useNativeCustomElements", function() { return useNativeCustomElements; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "supportsAdoptingStyleSheets", function() { return supportsAdoptingStyleSheets; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rootPath", function() { return rootPath; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setRootPath", function() { return setRootPath; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sanitizeDOMValue", function() { return sanitizeDOMValue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setSanitizeDOMValue", function() { return setSanitizeDOMValue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSanitizeDOMValue", function() { return getSanitizeDOMValue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "passiveTouchGestures", function() { return passiveTouchGestures; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setPassiveTouchGestures", function() { return setPassiveTouchGestures; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "strictTemplatePolicy", function() { return strictTemplatePolicy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setStrictTemplatePolicy", function() { return setStrictTemplatePolicy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "allowTemplateFromDomModule", function() { return allowTemplateFromDomModule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setAllowTemplateFromDomModule", function() { return setAllowTemplateFromDomModule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "legacyOptimizations", function() { return legacyOptimizations; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setLegacyOptimizations", function() { return setLegacyOptimizations; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "legacyWarnings", function() { return legacyWarnings; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setLegacyWarnings", function() { return setLegacyWarnings; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "syncInitialRender", function() { return syncInitialRender; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setSyncInitialRender", function() { return setSyncInitialRender; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "legacyUndefined", function() { return legacyUndefined; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setLegacyUndefined", function() { return setLegacyUndefined; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "orderedComputed", function() { return orderedComputed; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setOrderedComputed", function() { return setOrderedComputed; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cancelSyntheticClickEvents", function() { return cancelSyntheticClickEvents; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setCancelSyntheticClickEvents", function() { return setCancelSyntheticClickEvents; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "removeNestedTemplates", function() { return removeNestedTemplates; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setRemoveNestedTemplates", function() { return setRemoveNestedTemplates; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fastDomIf", function() { return fastDomIf; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setFastDomIf", function() { return setFastDomIf; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "suppressTemplateNotifications", function() { return suppressTemplateNotifications; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setSuppressTemplateNotifications", function() { return setSuppressTemplateNotifications; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "legacyNoObservedAttributes", function() { return legacyNoObservedAttributes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setLegacyNoObservedAttributes", function() { return setLegacyNoObservedAttributes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useAdoptedStyleSheetsWithBuiltCSS", function() { return useAdoptedStyleSheetsWithBuiltCSS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setUseAdoptedStyleSheetsWithBuiltCSS", function() { return setUseAdoptedStyleSheetsWithBuiltCSS; });
/* harmony import */ var _boot_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./boot.js */ "./node_modules/@polymer/polymer/lib/utils/boot.js");
/* harmony import */ var _resolve_url_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./resolve-url.js */ "./node_modules/@polymer/polymer/lib/utils/resolve-url.js");
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/


const useShadow = !window.ShadyDOM || !window.ShadyDOM.inUse;
const useNativeCSSProperties = Boolean(!window.ShadyCSS || window.ShadyCSS.nativeCss);
const useNativeCustomElements = !window.customElements.polyfillWrapFlushCallback;
const supportsAdoptingStyleSheets = useShadow && 'adoptedStyleSheets' in Document.prototype && 'replaceSync' in CSSStyleSheet.prototype && // Since spec may change, feature detect exact API we need
(() => {
  try {
    const sheet = new CSSStyleSheet();
    sheet.replaceSync('');
    const host = document.createElement('div');
    host.attachShadow({
      mode: 'open'
    });
    host.shadowRoot.adoptedStyleSheets = [sheet];
    return host.shadowRoot.adoptedStyleSheets[0] === sheet;
  } catch (e) {
    return false;
  }
})();
/**
 * Globally settable property that is automatically assigned to
 * `ElementMixin` instances, useful for binding in templates to
 * make URL's relative to an application's root.  Defaults to the main
 * document URL, but can be overridden by users.  It may be useful to set
 * `rootPath` to provide a stable application mount path when
 * using client side routing.
 */

let rootPath = window.Polymer && window.Polymer.rootPath || Object(_resolve_url_js__WEBPACK_IMPORTED_MODULE_1__["pathFromUrl"])(document.baseURI || window.location.href);
/**
 * Sets the global rootPath property used by `ElementMixin` and
 * available via `rootPath`.
 *
 * @param {string} path The new root path
 * @return {void}
 */

const setRootPath = function (path) {
  rootPath = path;
};
/**
 * A global callback used to sanitize any value before inserting it into the DOM.
 * The callback signature is:
 *
 *  function sanitizeDOMValue(value, name, type, node) { ... }
 *
 * Where:
 *
 * `value` is the value to sanitize.
 * `name` is the name of an attribute or property (for example, href).
 * `type` indicates where the value is being inserted: one of property, attribute, or text.
 * `node` is the node where the value is being inserted.
 *
 * @type {(function(*,string,string,?Node):*)|undefined}
 */

let sanitizeDOMValue = window.Polymer && window.Polymer.sanitizeDOMValue || undefined;
/**
 * Sets the global sanitizeDOMValue available via this module's exported
 * `sanitizeDOMValue` variable.
 *
 * @param {(function(*,string,string,?Node):*)|undefined} newSanitizeDOMValue the global sanitizeDOMValue callback
 * @return {void}
 */

const setSanitizeDOMValue = function (newSanitizeDOMValue) {
  sanitizeDOMValue = newSanitizeDOMValue;
};
/**
 * Gets sanitizeDOMValue, for environments that don't well support `export let`.
 *
 * @return {(function(*,string,string,?Node):*)|undefined} sanitizeDOMValue
 */

const getSanitizeDOMValue = function () {
  return sanitizeDOMValue;
};
/**
 * Globally settable property to make Polymer Gestures use passive TouchEvent listeners when recognizing gestures.
 * When set to `true`, gestures made from touch will not be able to prevent scrolling, allowing for smoother
 * scrolling performance.
 * Defaults to `false` for backwards compatibility.
 */

let passiveTouchGestures = window.Polymer && window.Polymer.setPassiveTouchGestures || false;
/**
 * Sets `passiveTouchGestures` globally for all elements using Polymer Gestures.
 *
 * @param {boolean} usePassive enable or disable passive touch gestures globally
 * @return {void}
 */

const setPassiveTouchGestures = function (usePassive) {
  passiveTouchGestures = usePassive;
};
/**
 * Setting to ensure Polymer template evaluation only occurs based on tempates
 * defined in trusted script.  When true, `<dom-module>` re-registration is
 * disallowed, `<dom-bind>` is disabled, and `<dom-if>`/`<dom-repeat>`
 * templates will only evaluate in the context of a trusted element template.
 */

let strictTemplatePolicy = window.Polymer && window.Polymer.strictTemplatePolicy || false;
/**
 * Sets `strictTemplatePolicy` globally for all elements
 *
 * @param {boolean} useStrictPolicy enable or disable strict template policy
 *   globally
 * @return {void}
 */

const setStrictTemplatePolicy = function (useStrictPolicy) {
  strictTemplatePolicy = useStrictPolicy;
};
/**
 * Setting to enable dom-module lookup from Polymer.Element.  By default,
 * templates must be defined in script using the `static get template()`
 * getter and the `html` tag function.  To enable legacy loading of templates
 * via dom-module, set this flag to true.
 */

let allowTemplateFromDomModule = window.Polymer && window.Polymer.allowTemplateFromDomModule || false;
/**
 * Sets `lookupTemplateFromDomModule` globally for all elements
 *
 * @param {boolean} allowDomModule enable or disable template lookup
 *   globally
 * @return {void}
 */

const setAllowTemplateFromDomModule = function (allowDomModule) {
  allowTemplateFromDomModule = allowDomModule;
};
/**
 * Setting to skip processing style includes and re-writing urls in css styles.
 * Normally "included" styles are pulled into the element and all urls in styles
 * are re-written to be relative to the containing script url.
 * If no includes or relative urls are used in styles, these steps can be
 * skipped as an optimization.
 */

let legacyOptimizations = window.Polymer && window.Polymer.legacyOptimizations || false;
/**
 * Sets `legacyOptimizations` globally for all elements to enable optimizations
 * when only legacy based elements are used.
 *
 * @param {boolean} useLegacyOptimizations enable or disable legacy optimizations
 * includes and url rewriting
 * @return {void}
 */

const setLegacyOptimizations = function (useLegacyOptimizations) {
  legacyOptimizations = useLegacyOptimizations;
};
/**
 * Setting to add warnings useful when migrating from Polymer 1.x to 2.x.
 */

let legacyWarnings = window.Polymer && window.Polymer.legacyWarnings || false;
/**
 * Sets `legacyWarnings` globally for all elements to migration warnings.
 *
 * @param {boolean} useLegacyWarnings enable or disable warnings
 * @return {void}
 */

const setLegacyWarnings = function (useLegacyWarnings) {
  legacyWarnings = useLegacyWarnings;
};
/**
 * Setting to perform initial rendering synchronously when running under ShadyDOM.
 * This matches the behavior of Polymer 1.
 */

let syncInitialRender = window.Polymer && window.Polymer.syncInitialRender || false;
/**
 * Sets `syncInitialRender` globally for all elements to enable synchronous
 * initial rendering.
 *
 * @param {boolean} useSyncInitialRender enable or disable synchronous initial
 * rendering globally.
 * @return {void}
 */

const setSyncInitialRender = function (useSyncInitialRender) {
  syncInitialRender = useSyncInitialRender;
};
/**
 * Setting to retain the legacy Polymer 1 behavior for multi-property
 * observers around undefined values. Observers and computed property methods
 * are not called until no argument is undefined.
 */

let legacyUndefined = window.Polymer && window.Polymer.legacyUndefined || false;
/**
 * Sets `legacyUndefined` globally for all elements to enable legacy
 * multi-property behavior for undefined values.
 *
 * @param {boolean} useLegacyUndefined enable or disable legacy
 * multi-property behavior for undefined.
 * @return {void}
 */

const setLegacyUndefined = function (useLegacyUndefined) {
  legacyUndefined = useLegacyUndefined;
};
/**
 * Setting to ensure computed properties are computed in order to ensure
 * re-computation never occurs in a given turn.
 */

let orderedComputed = window.Polymer && window.Polymer.orderedComputed || false;
/**
 * Sets `orderedComputed` globally for all elements to enable ordered computed
 * property computation.
 *
 * @param {boolean} useOrderedComputed enable or disable ordered computed effects
 * @return {void}
 */

const setOrderedComputed = function (useOrderedComputed) {
  orderedComputed = useOrderedComputed;
};
/**
 * Setting to cancel synthetic click events fired by older mobile browsers. Modern browsers
 * no longer fire synthetic click events, and the cancellation behavior can interfere
 * when programmatically clicking on elements.
 */

let cancelSyntheticClickEvents = true;
/**
 * Sets `setCancelSyntheticEvents` globally for all elements to cancel synthetic click events.
 *
 * @param {boolean} useCancelSyntheticClickEvents enable or disable cancelling synthetic
 * events
 * @return {void}
 */

const setCancelSyntheticClickEvents = function (useCancelSyntheticClickEvents) {
  cancelSyntheticClickEvents = useCancelSyntheticClickEvents;
};
/**
 * Setting to remove nested templates inside `dom-if` and `dom-repeat` as
 * part of element template parsing.  This is a performance optimization that
 * eliminates most of the tax of needing two elements due to the loss of
 * type-extended templates as a result of the V1 specification changes.
 */

let removeNestedTemplates = window.Polymer && window.Polymer.removeNestedTemplates || false;
/**
 * Sets `removeNestedTemplates` globally, to eliminate nested templates
 * inside `dom-if` and `dom-repeat` as part of template parsing.
 *
 * @param {boolean} useRemoveNestedTemplates enable or disable removing nested
 *   templates during parsing
 * @return {void}
 */

const setRemoveNestedTemplates = function (useRemoveNestedTemplates) {
  removeNestedTemplates = useRemoveNestedTemplates;
};
/**
 * Setting to place `dom-if` elements in a performance-optimized mode that takes
 * advantage of lighter-weight host runtime template stamping to eliminate the
 * need for an intermediate Templatizer `TemplateInstance` to mange the nodes
 * stamped by `dom-if`.  Under this setting, any Templatizer-provided API's
 * such as `modelForElement` will not be available for nodes stamped by
 * `dom-if`.
 */

let fastDomIf = window.Polymer && window.Polymer.fastDomIf || false;
/**
 * Sets `fastDomIf` globally, to put `dom-if` in a performance-optimized mode.
 *
 * @param {boolean} useFastDomIf enable or disable `dom-if` fast-mode
 * @return {void}
 */

const setFastDomIf = function (useFastDomIf) {
  fastDomIf = useFastDomIf;
};
/**
 * Setting to disable `dom-change` and `rendered-item-count` events from
 * `dom-if` and `dom-repeat`. Users can opt back into `dom-change` events by
 * setting the `notify-dom-change` attribute (`notifyDomChange: true` property)
 * to `dom-if`/`don-repeat` instances.
 */

let suppressTemplateNotifications = window.Polymer && window.Polymer.suppressTemplateNotifications || false;
/**
 * Sets `suppressTemplateNotifications` globally, to disable `dom-change` and
 * `rendered-item-count` events from `dom-if` and `dom-repeat`.
 *
 * @param {boolean} suppress enable or disable `suppressTemplateNotifications`
 * @return {void}
 */

const setSuppressTemplateNotifications = function (suppress) {
  suppressTemplateNotifications = suppress;
};
/**
 * Setting to disable use of dynamic attributes. This is an optimization
 * to avoid setting `observedAttributes`. Instead attributes are read
 * once at create time and set/removeAttribute are patched.
 */

let legacyNoObservedAttributes = window.Polymer && window.Polymer.legacyNoObservedAttributes || false;
/**
 * Sets `legacyNoObservedAttributes` globally, to disable `observedAttributes`.
 *
 * @param {boolean} noObservedAttributes enable or disable `legacyNoObservedAttributes`
 * @return {void}
 */

const setLegacyNoObservedAttributes = function (noObservedAttributes) {
  legacyNoObservedAttributes = noObservedAttributes;
};
/**
 * Setting to enable use of `adoptedStyleSheets` for sharing style sheets
 * between component instances' shadow roots, if the app uses built Shady CSS
 * styles.
 */

let useAdoptedStyleSheetsWithBuiltCSS = window.Polymer && window.Polymer.useAdoptedStyleSheetsWithBuiltCSS || false;
/**
 * Sets `useAdoptedStyleSheetsWithBuiltCSS` globally.
 *
 * @param {boolean} value enable or disable `useAdoptedStyleSheetsWithBuiltCSS`
 * @return {void}
 */

const setUseAdoptedStyleSheetsWithBuiltCSS = function (value) {
  useAdoptedStyleSheetsWithBuiltCSS = value;
};

/***/ }),

/***/ "./node_modules/@polymer/polymer/lib/utils/style-gather.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@polymer/polymer/lib/utils/style-gather.js ***!
  \*****************************************************************/
/*! exports provided: stylesFromModules, stylesFromModule, stylesFromTemplate, stylesFromModuleImports, cssFromModules, cssFromModule, cssFromTemplate, cssFromModuleImports */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "stylesFromModules", function() { return stylesFromModules; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "stylesFromModule", function() { return stylesFromModule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "stylesFromTemplate", function() { return stylesFromTemplate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "stylesFromModuleImports", function() { return stylesFromModuleImports; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cssFromModules", function() { return cssFromModules; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cssFromModule", function() { return cssFromModule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cssFromTemplate", function() { return cssFromTemplate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cssFromModuleImports", function() { return cssFromModuleImports; });
/* harmony import */ var _elements_dom_module_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../elements/dom-module.js */ "./node_modules/@polymer/polymer/lib/elements/dom-module.js");
/* harmony import */ var _resolve_url_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./resolve-url.js */ "./node_modules/@polymer/polymer/lib/utils/resolve-url.js");
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

/**
 * Module with utilities for collection CSS text from `<templates>`, external
 * stylesheets, and `dom-module`s.
 *
 * @summary Module with utilities for collection CSS text from various sources.
 */


const MODULE_STYLE_LINK_SELECTOR = 'link[rel=import][type~=css]';
const INCLUDE_ATTR = 'include';
const SHADY_UNSCOPED_ATTR = 'shady-unscoped';
/**
 * @param {string} moduleId .
 * @return {?DomModule} .
 */

function importModule(moduleId) {
  return (
    /** @type {?DomModule} */
    _elements_dom_module_js__WEBPACK_IMPORTED_MODULE_0__["DomModule"].import(moduleId)
  );
}

function styleForImport(importDoc) {
  // NOTE: polyfill affordance.
  // under the HTMLImports polyfill, there will be no 'body',
  // but the import pseudo-doc can be used directly.
  let container = importDoc.body ? importDoc.body : importDoc;
  const importCss = Object(_resolve_url_js__WEBPACK_IMPORTED_MODULE_1__["resolveCss"])(container.textContent, importDoc.baseURI);
  const style = document.createElement('style');
  style.textContent = importCss;
  return style;
}
/** @typedef {{assetpath: string}} */


let templateWithAssetPath; // eslint-disable-line no-unused-vars

/**
 * Returns a list of <style> elements in a space-separated list of `dom-module`s.
 *
 * @function
 * @param {string} moduleIds List of dom-module id's within which to
 * search for css.
 * @return {!Array<!HTMLStyleElement>} Array of contained <style> elements
 */

function stylesFromModules(moduleIds) {
  const modules = moduleIds.trim().split(/\s+/);
  const styles = [];

  for (let i = 0; i < modules.length; i++) {
    styles.push(...stylesFromModule(modules[i]));
  }

  return styles;
}
/**
 * Returns a list of <style> elements in a given `dom-module`.
 * Styles in a `dom-module` can come either from `<style>`s within the
 * first `<template>`, or else from one or more
 * `<link rel="import" type="css">` links outside the template.
 *
 * @param {string} moduleId dom-module id to gather styles from
 * @return {!Array<!HTMLStyleElement>} Array of contained styles.
 */

function stylesFromModule(moduleId) {
  const m = importModule(moduleId);

  if (!m) {
    console.warn('Could not find style data in module named', moduleId);
    return [];
  }

  if (m._styles === undefined) {
    const styles = []; // module imports: <link rel="import" type="css">

    styles.push(..._stylesFromModuleImports(m)); // include css from the first template in the module

    const template =
    /** @type {?HTMLTemplateElement} */
    m.querySelector('template');

    if (template) {
      styles.push(...stylesFromTemplate(template,
      /** @type {templateWithAssetPath} */
      m.assetpath));
    }

    m._styles = styles;
  }

  return m._styles;
}
/**
 * Returns the `<style>` elements within a given template.
 *
 * @param {!HTMLTemplateElement} template Template to gather styles from
 * @param {string=} baseURI baseURI for style content
 * @return {!Array<!HTMLStyleElement>} Array of styles
 */

function stylesFromTemplate(template, baseURI) {
  if (!template._styles) {
    const styles = []; // if element is a template, get content from its .content

    const e$ = template.content.querySelectorAll('style');

    for (let i = 0; i < e$.length; i++) {
      let e = e$[i]; // support style sharing by allowing styles to "include"
      // other dom-modules that contain styling

      let include = e.getAttribute(INCLUDE_ATTR);

      if (include) {
        styles.push(...stylesFromModules(include).filter(function (item, index, self) {
          return self.indexOf(item) === index;
        }));
      }

      if (baseURI) {
        e.textContent = Object(_resolve_url_js__WEBPACK_IMPORTED_MODULE_1__["resolveCss"])(e.textContent,
        /** @type {string} */
        baseURI);
      }

      styles.push(e);
    }

    template._styles = styles;
  }

  return template._styles;
}
/**
 * Returns a list of <style> elements  from stylesheets loaded via `<link rel="import" type="css">` links within the specified `dom-module`.
 *
 * @param {string} moduleId Id of `dom-module` to gather CSS from
 * @return {!Array<!HTMLStyleElement>} Array of contained styles.
 */

function stylesFromModuleImports(moduleId) {
  let m = importModule(moduleId);
  return m ? _stylesFromModuleImports(m) : [];
}
/**
 * @param {!HTMLElement} module dom-module element that could contain `<link rel="import" type="css">` styles
 * @return {!Array<!HTMLStyleElement>} Array of contained styles
 */

function _stylesFromModuleImports(module) {
  const styles = [];
  const p$ = module.querySelectorAll(MODULE_STYLE_LINK_SELECTOR);

  for (let i = 0; i < p$.length; i++) {
    let p = p$[i];

    if (p.import) {
      const importDoc = p.import;
      const unscoped = p.hasAttribute(SHADY_UNSCOPED_ATTR);

      if (unscoped && !importDoc._unscopedStyle) {
        const style = styleForImport(importDoc);
        style.setAttribute(SHADY_UNSCOPED_ATTR, '');
        importDoc._unscopedStyle = style;
      } else if (!importDoc._style) {
        importDoc._style = styleForImport(importDoc);
      }

      styles.push(unscoped ? importDoc._unscopedStyle : importDoc._style);
    }
  }

  return styles;
}
/**
 *
 * Returns CSS text of styles in a space-separated list of `dom-module`s.
 * Note: This method is deprecated, use `stylesFromModules` instead.
 *
 * @deprecated
 * @param {string} moduleIds List of dom-module id's within which to
 * search for css.
 * @return {string} Concatenated CSS content from specified `dom-module`s
 */


function cssFromModules(moduleIds) {
  let modules = moduleIds.trim().split(/\s+/);
  let cssText = '';

  for (let i = 0; i < modules.length; i++) {
    cssText += cssFromModule(modules[i]);
  }

  return cssText;
}
/**
 * Returns CSS text of styles in a given `dom-module`.  CSS in a `dom-module`
 * can come either from `<style>`s within the first `<template>`, or else
 * from one or more `<link rel="import" type="css">` links outside the
 * template.
 *
 * Any `<styles>` processed are removed from their original location.
 * Note: This method is deprecated, use `styleFromModule` instead.
 *
 * @deprecated
 * @param {string} moduleId dom-module id to gather styles from
 * @return {string} Concatenated CSS content from specified `dom-module`
 */

function cssFromModule(moduleId) {
  let m = importModule(moduleId);

  if (m && m._cssText === undefined) {
    // module imports: <link rel="import" type="css">
    let cssText = _cssFromModuleImports(m); // include css from the first template in the module


    let t =
    /** @type {?HTMLTemplateElement} */
    m.querySelector('template');

    if (t) {
      cssText += cssFromTemplate(t,
      /** @type {templateWithAssetPath} */
      m.assetpath);
    }

    m._cssText = cssText || null;
  }

  if (!m) {
    console.warn('Could not find style data in module named', moduleId);
  }

  return m && m._cssText || '';
}
/**
 * Returns CSS text of `<styles>` within a given template.
 *
 * Any `<styles>` processed are removed from their original location.
 * Note: This method is deprecated, use `styleFromTemplate` instead.
 *
 * @deprecated
 * @param {!HTMLTemplateElement} template Template to gather styles from
 * @param {string} baseURI Base URI to resolve the URL against
 * @return {string} Concatenated CSS content from specified template
 */

function cssFromTemplate(template, baseURI) {
  let cssText = '';
  const e$ = stylesFromTemplate(template, baseURI); // if element is a template, get content from its .content

  for (let i = 0; i < e$.length; i++) {
    let e = e$[i];

    if (e.parentNode) {
      e.parentNode.removeChild(e);
    }

    cssText += e.textContent;
  }

  return cssText;
}
/**
 * Returns CSS text from stylesheets loaded via `<link rel="import" type="css">`
 * links within the specified `dom-module`.
 *
 * Note: This method is deprecated, use `stylesFromModuleImports` instead.
 *
 * @deprecated
 *
 * @param {string} moduleId Id of `dom-module` to gather CSS from
 * @return {string} Concatenated CSS content from links in specified `dom-module`
 */

function cssFromModuleImports(moduleId) {
  let m = importModule(moduleId);
  return m ? _cssFromModuleImports(m) : '';
}
/**
 * @deprecated
 * @param {!HTMLElement} module dom-module element that could contain `<link rel="import" type="css">` styles
 * @return {string} Concatenated CSS content from links in the dom-module
 */

function _cssFromModuleImports(module) {
  let cssText = '';

  let styles = _stylesFromModuleImports(module);

  for (let i = 0; i < styles.length; i++) {
    cssText += styles[i].textContent;
  }

  return cssText;
}

/***/ }),

/***/ "./node_modules/@polymer/polymer/lib/utils/telemetry.js":
/*!**************************************************************!*\
  !*** ./node_modules/@polymer/polymer/lib/utils/telemetry.js ***!
  \**************************************************************/
/*! exports provided: instanceCount, incrementInstanceCount, registrations, register, dumpRegistrations */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "instanceCount", function() { return instanceCount; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "incrementInstanceCount", function() { return incrementInstanceCount; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "registrations", function() { return registrations; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "register", function() { return register; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dumpRegistrations", function() { return dumpRegistrations; });
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

/**
 * Total number of Polymer element instances created.
 * @type {number}
 */
let instanceCount = 0;
function incrementInstanceCount() {
  instanceCount++;
}
/**
 * Array of Polymer element classes that have been finalized.
 * @type {!Array<!PolymerElementConstructor>}
 */

const registrations = [];
/**
 * @param {!PolymerElementConstructor} prototype Element prototype to log
 * @private
 */

function _regLog(prototype) {
  console.log('[' +
  /** @type {?} */
  prototype.is + ']: registered');
}
/**
 * Registers a class prototype for telemetry purposes.
 * @param {!PolymerElementConstructor} prototype Element prototype to register
 * @protected
 */


function register(prototype) {
  registrations.push(prototype);
}
/**
 * Logs all elements registered with an `is` to the console.
 * @public
 */

function dumpRegistrations() {
  registrations.forEach(_regLog);
}

/***/ }),

/***/ "./node_modules/@polymer/polymer/lib/utils/templatize.js":
/*!***************************************************************!*\
  !*** ./node_modules/@polymer/polymer/lib/utils/templatize.js ***!
  \***************************************************************/
/*! exports provided: showHideChildren, templatize, modelForElement, TemplateInstanceBase */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "showHideChildren", function() { return showHideChildren; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "templatize", function() { return templatize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "modelForElement", function() { return modelForElement; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TemplateInstanceBase", function() { return TemplateInstanceBase; });
/* harmony import */ var _boot_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./boot.js */ "./node_modules/@polymer/polymer/lib/utils/boot.js");
/* harmony import */ var _mixins_property_effects_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../mixins/property-effects.js */ "./node_modules/@polymer/polymer/lib/mixins/property-effects.js");
/* harmony import */ var _mixins_mutable_data_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../mixins/mutable-data.js */ "./node_modules/@polymer/polymer/lib/mixins/mutable-data.js");
/* harmony import */ var _settings_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./settings.js */ "./node_modules/@polymer/polymer/lib/utils/settings.js");
/* harmony import */ var _wrap_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./wrap.js */ "./node_modules/@polymer/polymer/lib/utils/wrap.js");
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

/**
 * Module for preparing and stamping instances of templates that utilize
 * Polymer's data-binding and declarative event listener features.
 *
 * Example:
 *
 *     // Get a template from somewhere, e.g. light DOM
 *     let template = this.querySelector('template');
 *     // Prepare the template
 *     let TemplateClass = Templatize.templatize(template);
 *     // Instance the template with an initial data model
 *     let instance = new TemplateClass({myProp: 'initial'});
 *     // Insert the instance's DOM somewhere, e.g. element's shadow DOM
 *     this.shadowRoot.appendChild(instance.root);
 *     // Changing a property on the instance will propagate to bindings
 *     // in the template
 *     instance.myProp = 'new value';
 *
 * The `options` dictionary passed to `templatize` allows for customizing
 * features of the generated template class, including how outer-scope host
 * properties should be forwarded into template instances, how any instance
 * properties added into the template's scope should be notified out to
 * the host, and whether the instance should be decorated as a "parent model"
 * of any event handlers.
 *
 *     // Customize property forwarding and event model decoration
 *     let TemplateClass = Templatize.templatize(template, this, {
 *       parentModel: true,
 *       forwardHostProp(property, value) {...},
 *       instanceProps: {...},
 *       notifyInstanceProp(instance, property, value) {...},
 *     });
 *
 * @summary Module for preparing and stamping instances of templates
 *   utilizing Polymer templating features.
 */




 // Base class for HTMLTemplateElement extension that has property effects
// machinery for propagating host properties to children. This is an ES5
// class only because Babel (incorrectly) requires super() in the class
// constructor even though no `this` is used and it returns an instance.

let newInstance = null;
/**
 * @constructor
 * @extends {HTMLTemplateElement}
 * @private
 */

function HTMLTemplateElementExtension() {
  return newInstance;
}

HTMLTemplateElementExtension.prototype = Object.create(HTMLTemplateElement.prototype, {
  constructor: {
    value: HTMLTemplateElementExtension,
    writable: true
  }
});
/**
 * @constructor
 * @implements {Polymer_PropertyEffects}
 * @extends {HTMLTemplateElementExtension}
 * @private
 */

const DataTemplate = Object(_mixins_property_effects_js__WEBPACK_IMPORTED_MODULE_1__["PropertyEffects"])(HTMLTemplateElementExtension);
/**
 * @constructor
 * @implements {Polymer_MutableData}
 * @extends {DataTemplate}
 * @private
 */

const MutableDataTemplate = Object(_mixins_mutable_data_js__WEBPACK_IMPORTED_MODULE_2__["MutableData"])(DataTemplate); // Applies a DataTemplate subclass to a <template> instance

function upgradeTemplate(template, constructor) {
  newInstance = template;
  Object.setPrototypeOf(template, constructor.prototype);
  new constructor();
  newInstance = null;
}
/**
 * Base class for TemplateInstance.
 * @constructor
 * @extends {HTMLElement}
 * @implements {Polymer_PropertyEffects}
 * @private
 */


const templateInstanceBase = Object(_mixins_property_effects_js__WEBPACK_IMPORTED_MODULE_1__["PropertyEffects"])(class {});
function showHideChildren(hide, children) {
  for (let i = 0; i < children.length; i++) {
    let n = children[i]; // Ignore non-changes

    if (Boolean(hide) != Boolean(n.__hideTemplateChildren__)) {
      // clear and restore text
      if (n.nodeType === Node.TEXT_NODE) {
        if (hide) {
          n.__polymerTextContent__ = n.textContent;
          n.textContent = '';
        } else {
          n.textContent = n.__polymerTextContent__;
        } // remove and replace slot

      } else if (n.localName === 'slot') {
        if (hide) {
          n.__polymerReplaced__ = document.createComment('hidden-slot');
          Object(_wrap_js__WEBPACK_IMPORTED_MODULE_4__["wrap"])(Object(_wrap_js__WEBPACK_IMPORTED_MODULE_4__["wrap"])(n).parentNode).replaceChild(n.__polymerReplaced__, n);
        } else {
          const replace = n.__polymerReplaced__;

          if (replace) {
            Object(_wrap_js__WEBPACK_IMPORTED_MODULE_4__["wrap"])(Object(_wrap_js__WEBPACK_IMPORTED_MODULE_4__["wrap"])(replace).parentNode).replaceChild(n, replace);
          }
        }
      } // hide and show nodes
      else if (n.style) {
          if (hide) {
            n.__polymerDisplay__ = n.style.display;
            n.style.display = 'none';
          } else {
            n.style.display = n.__polymerDisplay__;
          }
        }
    }

    n.__hideTemplateChildren__ = hide;

    if (n._showHideChildren) {
      n._showHideChildren(hide);
    }
  }
}
/**
 * @polymer
 * @customElement
 * @appliesMixin PropertyEffects
 * @unrestricted
 */

class TemplateInstanceBase extends templateInstanceBase {
  constructor(props) {
    super();

    this._configureProperties(props);
    /** @type {!StampedTemplate} */


    this.root = this._stampTemplate(this.__dataHost); // Save list of stamped children

    let children = [];
    /** @suppress {invalidCasts} */

    this.children =
    /** @type {!NodeList} */
    children; // Polymer 1.x did not use `Polymer.dom` here so not bothering.

    for (let n = this.root.firstChild; n; n = n.nextSibling) {
      children.push(n);
      n.__templatizeInstance = this;
    }

    if (this.__templatizeOwner && this.__templatizeOwner.__hideTemplateChildren__) {
      this._showHideChildren(true);
    } // Flush props only when props are passed if instance props exist
    // or when there isn't instance props.


    let options = this.__templatizeOptions;

    if (props && options.instanceProps || !options.instanceProps) {
      this._enableProperties();
    }
  }
  /**
   * Configure the given `props` by calling `_setPendingProperty`. Also
   * sets any properties stored in `__hostProps`.
   * @private
   * @param {Object} props Object of property name-value pairs to set.
   * @return {void}
   */


  _configureProperties(props) {
    let options = this.__templatizeOptions;

    if (options.forwardHostProp) {
      for (let hprop in this.__hostProps) {
        this._setPendingProperty(hprop, this.__dataHost['_host_' + hprop]);
      }
    } // Any instance props passed in the constructor will overwrite host props;
    // normally this would be a user error but we don't specifically filter them


    for (let iprop in props) {
      this._setPendingProperty(iprop, props[iprop]);
    }
  }
  /**
   * Forwards a host property to this instance.  This method should be
   * called on instances from the `options.forwardHostProp` callback
   * to propagate changes of host properties to each instance.
   *
   * Note this method enqueues the change, which are flushed as a batch.
   *
   * @param {string} prop Property or path name
   * @param {*} value Value of the property to forward
   * @return {void}
   */


  forwardHostProp(prop, value) {
    if (this._setPendingPropertyOrPath(prop, value, false, true)) {
      this.__dataHost._enqueueClient(this);
    }
  }
  /**
   * Override point for adding custom or simulated event handling.
   *
   * @override
   * @param {!Node} node Node to add event listener to
   * @param {string} eventName Name of event
   * @param {function(!Event):void} handler Listener function to add
   * @return {void}
   */


  _addEventListenerToNode(node, eventName, handler) {
    if (this._methodHost && this.__templatizeOptions.parentModel) {
      // If this instance should be considered a parent model, decorate
      // events this template instance as `model`
      this._methodHost._addEventListenerToNode(node, eventName, e => {
        e.model = this;
        handler(e);
      });
    } else {
      // Otherwise delegate to the template's host (which could be)
      // another template instance
      let templateHost = this.__dataHost.__dataHost;

      if (templateHost) {
        templateHost._addEventListenerToNode(node, eventName, handler);
      }
    }
  }
  /**
   * Shows or hides the template instance top level child elements. For
   * text nodes, `textContent` is removed while "hidden" and replaced when
   * "shown."
   * @param {boolean} hide Set to true to hide the children;
   * set to false to show them.
   * @return {void}
   * @protected
   */


  _showHideChildren(hide) {
    showHideChildren(hide, this.children);
  }
  /**
   * Overrides default property-effects implementation to intercept
   * textContent bindings while children are "hidden" and cache in
   * private storage for later retrieval.
   *
   * @override
   * @param {!Node} node The node to set a property on
   * @param {string} prop The property to set
   * @param {*} value The value to set
   * @return {void}
   * @protected
   */


  _setUnmanagedPropertyToNode(node, prop, value) {
    if (node.__hideTemplateChildren__ && node.nodeType == Node.TEXT_NODE && prop == 'textContent') {
      node.__polymerTextContent__ = value;
    } else {
      super._setUnmanagedPropertyToNode(node, prop, value);
    }
  }
  /**
   * Find the parent model of this template instance.  The parent model
   * is either another templatize instance that had option `parentModel: true`,
   * or else the host element.
   *
   * @return {!Polymer_PropertyEffects} The parent model of this instance
   */


  get parentModel() {
    let model = this.__parentModel;

    if (!model) {
      let options;
      model = this;

      do {
        // A template instance's `__dataHost` is a <template>
        // `model.__dataHost.__dataHost` is the template's host
        model = model.__dataHost.__dataHost;
      } while ((options = model.__templatizeOptions) && !options.parentModel);

      this.__parentModel = model;
    }

    return model;
  }
  /**
   * Stub of HTMLElement's `dispatchEvent`, so that effects that may
   * dispatch events safely no-op.
   *
   * @param {Event} event Event to dispatch
   * @return {boolean} Always true.
   * @override
   */


  dispatchEvent(event) {
    // eslint-disable-line no-unused-vars
    return true;
  }

}
/** @type {!DataTemplate} */


TemplateInstanceBase.prototype.__dataHost;
/** @type {!TemplatizeOptions} */

TemplateInstanceBase.prototype.__templatizeOptions;
/** @type {!Polymer_PropertyEffects} */

TemplateInstanceBase.prototype._methodHost;
/** @type {!Object} */

TemplateInstanceBase.prototype.__templatizeOwner;
/** @type {!Object} */

TemplateInstanceBase.prototype.__hostProps;
/**
 * @constructor
 * @extends {TemplateInstanceBase}
 * @implements {Polymer_MutableData}
 * @private
 */

const MutableTemplateInstanceBase = Object(_mixins_mutable_data_js__WEBPACK_IMPORTED_MODULE_2__["MutableData"])( // This cast shouldn't be neccessary, but Closure doesn't understand that
// TemplateInstanceBase is a constructor function.

/** @type {function(new:TemplateInstanceBase)} */
TemplateInstanceBase);

function findMethodHost(template) {
  // Technically this should be the owner of the outermost template.
  // In shadow dom, this is always getRootNode().host, but we can
  // approximate this via cooperation with our dataHost always setting
  // `_methodHost` as long as there were bindings (or id's) on this
  // instance causing it to get a dataHost.
  let templateHost = template.__dataHost;
  return templateHost && templateHost._methodHost || templateHost;
}
/* eslint-disable valid-jsdoc */

/**
 * @suppress {missingProperties} class.prototype is not defined for some reason
 */


function createTemplatizerClass(template, templateInfo, options) {
  /**
   * @constructor
   * @extends {TemplateInstanceBase}
   */
  let templatizerBase = options.mutableData ? MutableTemplateInstanceBase : TemplateInstanceBase; // Affordance for global mixins onto TemplatizeInstance

  if (templatize.mixin) {
    templatizerBase = templatize.mixin(templatizerBase);
  }
  /**
   * Anonymous class created by the templatize
   * @constructor
   * @private
   */


  let klass = class extends templatizerBase {};
  /** @override */

  klass.prototype.__templatizeOptions = options;

  klass.prototype._bindTemplate(template);

  addNotifyEffects(klass, template, templateInfo, options);
  return klass;
}
/**
 * Adds propagate effects from the template to the template instance for
 * properties that the host binds to the template using the `_host_` prefix.
 *
 * @suppress {missingProperties} class.prototype is not defined for some reason
 */


function addPropagateEffects(target, templateInfo, options, methodHost) {
  let userForwardHostProp = options.forwardHostProp;

  if (userForwardHostProp && templateInfo.hasHostProps) {
    // Under the `removeNestedTemplates` optimization, a custom element like
    // `dom-if` or `dom-repeat` can itself be treated as the "template"; this
    // flag is used to switch between upgrading a `<template>` to be a property
    // effects client vs. adding the effects directly to the custom element
    const isTemplate = target.localName == 'template'; // Provide data API and property effects on memoized template class

    let klass = templateInfo.templatizeTemplateClass;

    if (!klass) {
      if (isTemplate) {
        /**
         * @constructor
         * @extends {DataTemplate}
         */
        let templatizedBase = options.mutableData ? MutableDataTemplate : DataTemplate; // NOTE: due to https://github.com/google/closure-compiler/issues/2928,
        // combining the next two lines into one assignment causes a spurious
        // type error.

        /** @private */

        class TemplatizedTemplate extends templatizedBase {}

        klass = templateInfo.templatizeTemplateClass = TemplatizedTemplate;
      } else {
        /**
         * @constructor
         * @extends {PolymerElement}
         */
        const templatizedBase = target.constructor; // Create a cached subclass of the base custom element class onto which
        // to put the template-specific propagate effects
        // NOTE: due to https://github.com/google/closure-compiler/issues/2928,
        // combining the next two lines into one assignment causes a spurious
        // type error.

        /** @private */

        class TemplatizedTemplateExtension extends templatizedBase {}

        klass = templateInfo.templatizeTemplateClass = TemplatizedTemplateExtension;
      } // Add template - >instances effects
      // and host <- template effects


      let hostProps = templateInfo.hostProps;

      for (let prop in hostProps) {
        klass.prototype._addPropertyEffect('_host_' + prop, klass.prototype.PROPERTY_EFFECT_TYPES.PROPAGATE, {
          fn: createForwardHostPropEffect(prop, userForwardHostProp)
        });

        klass.prototype._createNotifyingProperty('_host_' + prop);
      }

      if (_settings_js__WEBPACK_IMPORTED_MODULE_3__["legacyWarnings"] && methodHost) {
        warnOnUndeclaredProperties(templateInfo, options, methodHost);
      }
    } // Mix any pre-bound data into __data; no need to flush this to
    // instances since they pull from the template at instance-time


    if (target.__dataProto) {
      // Note, generally `__dataProto` could be chained, but it's guaranteed
      // to not be since this is a vanilla template we just added effects to
      Object.assign(target.__data, target.__dataProto);
    }

    if (isTemplate) {
      upgradeTemplate(target, klass); // Clear any pending data for performance

      target.__dataTemp = {};
      target.__dataPending = null;
      target.__dataOld = null;

      target._enableProperties();
    } else {
      // Swizzle the cached subclass prototype onto the custom element
      Object.setPrototypeOf(target, klass.prototype); // Check for any pre-bound instance host properties, and do the
      // instance property delete/assign dance for those (directly into data;
      // not need to go through accessor since they are pulled at instance time)

      const hostProps = templateInfo.hostProps;

      for (let prop in hostProps) {
        prop = '_host_' + prop;

        if (prop in target) {
          const val = target[prop];
          delete target[prop];
          target.__data[prop] = val;
        }
      }
    }
  }
}
/* eslint-enable valid-jsdoc */


function createForwardHostPropEffect(hostProp, userForwardHostProp) {
  return function forwardHostProp(template, prop, props) {
    userForwardHostProp.call(template.__templatizeOwner, prop.substring('_host_'.length), props[prop]);
  };
}

function addNotifyEffects(klass, template, templateInfo, options) {
  let hostProps = templateInfo.hostProps || {};

  for (let iprop in options.instanceProps) {
    delete hostProps[iprop];
    let userNotifyInstanceProp = options.notifyInstanceProp;

    if (userNotifyInstanceProp) {
      klass.prototype._addPropertyEffect(iprop, klass.prototype.PROPERTY_EFFECT_TYPES.NOTIFY, {
        fn: createNotifyInstancePropEffect(iprop, userNotifyInstanceProp)
      });
    }
  }

  if (options.forwardHostProp && template.__dataHost) {
    for (let hprop in hostProps) {
      // As we're iterating hostProps in this function, note whether
      // there were any, for an optimization in addPropagateEffects
      if (!templateInfo.hasHostProps) {
        templateInfo.hasHostProps = true;
      }

      klass.prototype._addPropertyEffect(hprop, klass.prototype.PROPERTY_EFFECT_TYPES.NOTIFY, {
        fn: createNotifyHostPropEffect()
      });
    }
  }
}

function createNotifyInstancePropEffect(instProp, userNotifyInstanceProp) {
  return function notifyInstanceProp(inst, prop, props) {
    userNotifyInstanceProp.call(inst.__templatizeOwner, inst, prop, props[prop]);
  };
}

function createNotifyHostPropEffect() {
  return function notifyHostProp(inst, prop, props) {
    inst.__dataHost._setPendingPropertyOrPath('_host_' + prop, props[prop], true, true);
  };
}
/**
 * Returns an anonymous `PropertyEffects` class bound to the
 * `<template>` provided.  Instancing the class will result in the
 * template being stamped into a document fragment stored as the instance's
 * `root` property, after which it can be appended to the DOM.
 *
 * Templates may utilize all Polymer data-binding features as well as
 * declarative event listeners.  Event listeners and inline computing
 * functions in the template will be called on the host of the template.
 *
 * The constructor returned takes a single argument dictionary of initial
 * property values to propagate into template bindings.  Additionally
 * host properties can be forwarded in, and instance properties can be
 * notified out by providing optional callbacks in the `options` dictionary.
 *
 * Valid configuration in `options` are as follows:
 *
 * - `forwardHostProp(property, value)`: Called when a property referenced
 *   in the template changed on the template's host. As this library does
 *   not retain references to templates instanced by the user, it is the
 *   templatize owner's responsibility to forward host property changes into
 *   user-stamped instances.  The `instance.forwardHostProp(property, value)`
 *    method on the generated class should be called to forward host
 *   properties into the template to prevent unnecessary property-changed
 *   notifications. Any properties referenced in the template that are not
 *   defined in `instanceProps` will be notified up to the template's host
 *   automatically.
 * - `instanceProps`: Dictionary of property names that will be added
 *   to the instance by the templatize owner.  These properties shadow any
 *   host properties, and changes within the template to these properties
 *   will result in `notifyInstanceProp` being called.
 * - `mutableData`: When `true`, the generated class will skip strict
 *   dirty-checking for objects and arrays (always consider them to be
 *   "dirty").
 * - `notifyInstanceProp(instance, property, value)`: Called when
 *   an instance property changes.  Users may choose to call `notifyPath`
 *   on e.g. the owner to notify the change.
 * - `parentModel`: When `true`, events handled by declarative event listeners
 *   (`on-event="handler"`) will be decorated with a `model` property pointing
 *   to the template instance that stamped it.  It will also be returned
 *   from `instance.parentModel` in cases where template instance nesting
 *   causes an inner model to shadow an outer model.
 *
 * All callbacks are called bound to the `owner`. Any context
 * needed for the callbacks (such as references to `instances` stamped)
 * should be stored on the `owner` such that they can be retrieved via
 * `this`.
 *
 * When `options.forwardHostProp` is declared as an option, any properties
 * referenced in the template will be automatically forwarded from the host of
 * the `<template>` to instances, with the exception of any properties listed in
 * the `options.instanceProps` object.  `instanceProps` are assumed to be
 * managed by the owner of the instances, either passed into the constructor
 * or set after the fact.  Note, any properties passed into the constructor will
 * always be set to the instance (regardless of whether they would normally
 * be forwarded from the host).
 *
 * Note that `templatize()` can be run only once for a given `<template>`.
 * Further calls will result in an error. Also, there is a special
 * behavior if the template was duplicated through a mechanism such as
 * `<dom-repeat>` or `<test-fixture>`. In this case, all calls to
 * `templatize()` return the same class for all duplicates of a template.
 * The class returned from `templatize()` is generated only once using
 * the `options` from the first call. This means that any `options`
 * provided to subsequent calls will be ignored. Therefore, it is very
 * important not to close over any variables inside the callbacks. Also,
 * arrow functions must be avoided because they bind the outer `this`.
 * Inside the callbacks, any contextual information can be accessed
 * through `this`, which points to the `owner`.
 *
 * @param {!HTMLTemplateElement} template Template to templatize
 * @param {Polymer_PropertyEffects=} owner Owner of the template instances;
 *   any optional callbacks will be bound to this owner.
 * @param {Object=} options Options dictionary (see summary for details)
 * @return {function(new:TemplateInstanceBase, Object=)} Generated class bound
 *   to the template provided
 * @suppress {invalidCasts}
 */


function templatize(template, owner, options) {
  // Under strictTemplatePolicy, the templatized element must be owned
  // by a (trusted) Polymer element, indicated by existence of _methodHost;
  // e.g. for dom-if & dom-repeat in main document, _methodHost is null
  if (_settings_js__WEBPACK_IMPORTED_MODULE_3__["strictTemplatePolicy"] && !findMethodHost(template)) {
    throw new Error('strictTemplatePolicy: template owner not trusted');
  }

  options =
  /** @type {!TemplatizeOptions} */
  options || {};

  if (template.__templatizeOwner) {
    throw new Error('A <template> can only be templatized once');
  }

  template.__templatizeOwner = owner;
  const ctor = owner ? owner.constructor : TemplateInstanceBase;

  let templateInfo = ctor._parseTemplate(template); // Get memoized base class for the prototypical template, which
  // includes property effects for binding template & forwarding

  /**
   * @constructor
   * @extends {TemplateInstanceBase}
   */


  let baseClass = templateInfo.templatizeInstanceClass;

  if (!baseClass) {
    baseClass = createTemplatizerClass(template, templateInfo, options);
    templateInfo.templatizeInstanceClass = baseClass;
  }

  const methodHost = findMethodHost(template); // Host property forwarding must be installed onto template instance

  addPropagateEffects(template, templateInfo, options, methodHost); // Subclass base class and add reference for this specific template

  /** @private */

  let klass = class TemplateInstance extends baseClass {};
  /** @override */

  klass.prototype._methodHost = methodHost;
  /** @override */

  klass.prototype.__dataHost =
  /** @type {!DataTemplate} */
  template;
  /** @override */

  klass.prototype.__templatizeOwner =
  /** @type {!Object} */
  owner;
  /** @override */

  klass.prototype.__hostProps = templateInfo.hostProps;
  klass =
  /** @type {function(new:TemplateInstanceBase)} */
  klass; //eslint-disable-line no-self-assign

  return klass;
}

function warnOnUndeclaredProperties(templateInfo, options, methodHost) {
  const declaredProps = methodHost.constructor._properties;
  const {
    propertyEffects
  } = templateInfo;
  const {
    instanceProps
  } = options;

  for (let prop in propertyEffects) {
    // Ensure properties with template effects are declared on the outermost
    // host (`methodHost`), unless they are instance props or static functions
    if (!declaredProps[prop] && !(instanceProps && instanceProps[prop])) {
      const effects = propertyEffects[prop];

      for (let i = 0; i < effects.length; i++) {
        const {
          part
        } = effects[i].info;

        if (!(part.signature && part.signature.static)) {
          console.warn(`Property '${prop}' used in template but not ` + `declared in 'properties'; attribute will not be observed.`);
          break;
        }
      }
    }
  }
}
/**
 * Returns the template "model" associated with a given element, which
 * serves as the binding scope for the template instance the element is
 * contained in. A template model is an instance of
 * `TemplateInstanceBase`, and should be used to manipulate data
 * associated with this template instance.
 *
 * Example:
 *
 *   let model = modelForElement(el);
 *   if (model.index < 10) {
 *     model.set('item.checked', true);
 *   }
 *
 * @param {HTMLElement} template The model will be returned for
 *   elements stamped from this template (accepts either an HTMLTemplateElement)
 *   or a `<dom-if>`/`<dom-repeat>` element when using `removeNestedTemplates`
 *   optimization.
 * @param {Node=} node Node for which to return a template model.
 * @return {TemplateInstanceBase} Template instance representing the
 *   binding scope for the element
 */


function modelForElement(template, node) {
  let model;

  while (node) {
    // An element with a __templatizeInstance marks the top boundary
    // of a scope; walk up until we find one, and then ensure that
    // its __dataHost matches `this`, meaning this dom-repeat stamped it
    if (model = node.__dataHost ? node : node.__templatizeInstance) {
      // Found an element stamped by another template; keep walking up
      // from its __dataHost
      if (model.__dataHost != template) {
        node = model.__dataHost;
      } else {
        return model;
      }
    } else {
      // Still in a template scope, keep going up until
      // a __templatizeInstance is found
      node = Object(_wrap_js__WEBPACK_IMPORTED_MODULE_4__["wrap"])(node).parentNode;
    }
  }

  return null;
}


/***/ }),

/***/ "./node_modules/@polymer/polymer/lib/utils/wrap.js":
/*!*********************************************************!*\
  !*** ./node_modules/@polymer/polymer/lib/utils/wrap.js ***!
  \*********************************************************/
/*! exports provided: wrap */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "wrap", function() { return wrap; });
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

/* eslint-disable valid-jsdoc */

/**
 * Node wrapper to ensure ShadowDOM safe operation regardless of polyfill
 * presence or mode. Note that with the introduction of `ShadyDOM.noPatch`,
 * a node wrapper must be used to access ShadowDOM API.
 * This is similar to using `Polymer.dom` but relies exclusively
 * on the presence of the ShadyDOM polyfill rather than requiring the loading
 * of legacy (Polymer.dom) API.
 * @type {function(Node):Node}
 */
const wrap = window['ShadyDOM'] && window['ShadyDOM']['noPatch'] && window['ShadyDOM']['wrap'] ? window['ShadyDOM']['wrap'] : window['ShadyDOM'] ? n => ShadyDOM['patch'](n) : n => n;

/***/ }),

/***/ "./node_modules/@polymer/polymer/polymer-element.js":
/*!**********************************************************!*\
  !*** ./node_modules/@polymer/polymer/polymer-element.js ***!
  \**********************************************************/
/*! exports provided: html, version, PolymerElement */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PolymerElement", function() { return PolymerElement; });
/* harmony import */ var _lib_mixins_element_mixin_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/mixins/element-mixin.js */ "./node_modules/@polymer/polymer/lib/mixins/element-mixin.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "version", function() { return _lib_mixins_element_mixin_js__WEBPACK_IMPORTED_MODULE_0__["version"]; });

/* harmony import */ var _lib_utils_html_tag_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/utils/html-tag.js */ "./node_modules/@polymer/polymer/lib/utils/html-tag.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "html", function() { return _lib_utils_html_tag_js__WEBPACK_IMPORTED_MODULE_1__["html"]; });

/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/



/**
 * Base class that provides the core API for Polymer's meta-programming
 * features including template stamping, data-binding, attribute deserialization,
 * and property change observation.
 *
 * @customElement
 * @polymer
 * @constructor
 * @implements {Polymer_ElementMixin}
 * @extends HTMLElement
 * @appliesMixin ElementMixin
 * @summary Custom element base class that provides the core API for Polymer's
 *   key meta-programming features including template stamping, data-binding,
 *   attribute deserialization, and property change observation
 */

const PolymerElement = Object(_lib_mixins_element_mixin_js__WEBPACK_IMPORTED_MODULE_0__["ElementMixin"])(HTMLElement);

/***/ }),

/***/ "./node_modules/css-vendor/dist/css-vendor.esm.js":
/*!********************************************************!*\
  !*** ./node_modules/css-vendor/dist/css-vendor.esm.js ***!
  \********************************************************/
/*! exports provided: prefix, supportedKeyframes, supportedProperty, supportedValue */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "prefix", function() { return prefix; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "supportedKeyframes", function() { return supportedKeyframes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "supportedProperty", function() { return supportedProperty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "supportedValue", function() { return supportedValue; });
/* harmony import */ var is_in_browser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! is-in-browser */ "./node_modules/is-in-browser/dist/module.js");
/* harmony import */ var _babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/toConsumableArray */ "./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js");

 // Export javascript style and css style vendor prefixes.

var js = '';
var css = '';
var vendor = '';
var browser = '';
var isTouch = is_in_browser__WEBPACK_IMPORTED_MODULE_0__["default"] && 'ontouchstart' in document.documentElement; // We should not do anything if required serverside.

if (is_in_browser__WEBPACK_IMPORTED_MODULE_0__["default"]) {
  // Order matters. We need to check Webkit the last one because
  // other vendors use to add Webkit prefixes to some properties
  var jsCssMap = {
    Moz: '-moz-',
    ms: '-ms-',
    O: '-o-',
    Webkit: '-webkit-'
  };

  var _document$createEleme = document.createElement('p'),
      style = _document$createEleme.style;

  var testProp = 'Transform';

  for (var key in jsCssMap) {
    if (key + testProp in style) {
      js = key;
      css = jsCssMap[key];
      break;
    }
  } // Correctly detect the Edge browser.


  if (js === 'Webkit' && 'msHyphens' in style) {
    js = 'ms';
    css = jsCssMap.ms;
    browser = 'edge';
  } // Correctly detect the Safari browser.


  if (js === 'Webkit' && '-apple-trailing-word' in style) {
    vendor = 'apple';
  }
}
/**
 * Vendor prefix string for the current browser.
 *
 * @type {{js: String, css: String, vendor: String, browser: String}}
 * @api public
 */


var prefix = {
  js: js,
  css: css,
  vendor: vendor,
  browser: browser,
  isTouch: isTouch
};
/**
 * Test if a keyframe at-rule should be prefixed or not
 *
 * @param {String} vendor prefix string for the current browser.
 * @return {String}
 * @api public
 */

function supportedKeyframes(key) {
  // Keyframes is already prefixed. e.g. key = '@-webkit-keyframes a'
  if (key[1] === '-') return key; // No need to prefix IE/Edge. Older browsers will ignore unsupported rules.
  // https://caniuse.com/#search=keyframes

  if (prefix.js === 'ms') return key;
  return "@" + prefix.css + "keyframes" + key.substr(10);
} // https://caniuse.com/#search=appearance


var appearence = {
  noPrefill: ['appearance'],
  supportedProperty: function supportedProperty(prop) {
    if (prop !== 'appearance') return false;
    if (prefix.js === 'ms') return "-webkit-" + prop;
    return prefix.css + prop;
  }
}; // https://caniuse.com/#search=color-adjust

var colorAdjust = {
  noPrefill: ['color-adjust'],
  supportedProperty: function supportedProperty(prop) {
    if (prop !== 'color-adjust') return false;
    if (prefix.js === 'Webkit') return prefix.css + "print-" + prop;
    return prop;
  }
};
var regExp = /[-\s]+(.)?/g;
/**
 * Replaces the letter with the capital letter
 *
 * @param {String} match
 * @param {String} c
 * @return {String}
 * @api private
 */

function toUpper(match, c) {
  return c ? c.toUpperCase() : '';
}
/**
 * Convert dash separated strings to camel-cased.
 *
 * @param {String} str
 * @return {String}
 * @api private
 */


function camelize(str) {
  return str.replace(regExp, toUpper);
}
/**
 * Convert dash separated strings to pascal cased.
 *
 * @param {String} str
 * @return {String}
 * @api private
 */


function pascalize(str) {
  return camelize("-" + str);
} // but we can use a longhand property instead.
// https://caniuse.com/#search=mask


var mask = {
  noPrefill: ['mask'],
  supportedProperty: function supportedProperty(prop, style) {
    if (!/^mask/.test(prop)) return false;

    if (prefix.js === 'Webkit') {
      var longhand = 'mask-image';

      if (camelize(longhand) in style) {
        return prop;
      }

      if (prefix.js + pascalize(longhand) in style) {
        return prefix.css + prop;
      }
    }

    return prop;
  }
}; // https://caniuse.com/#search=text-orientation

var textOrientation = {
  noPrefill: ['text-orientation'],
  supportedProperty: function supportedProperty(prop) {
    if (prop !== 'text-orientation') return false;

    if (prefix.vendor === 'apple' && !prefix.isTouch) {
      return prefix.css + prop;
    }

    return prop;
  }
}; // https://caniuse.com/#search=transform

var transform = {
  noPrefill: ['transform'],
  supportedProperty: function supportedProperty(prop, style, options) {
    if (prop !== 'transform') return false;

    if (options.transform) {
      return prop;
    }

    return prefix.css + prop;
  }
}; // https://caniuse.com/#search=transition

var transition = {
  noPrefill: ['transition'],
  supportedProperty: function supportedProperty(prop, style, options) {
    if (prop !== 'transition') return false;

    if (options.transition) {
      return prop;
    }

    return prefix.css + prop;
  }
}; // https://caniuse.com/#search=writing-mode

var writingMode = {
  noPrefill: ['writing-mode'],
  supportedProperty: function supportedProperty(prop) {
    if (prop !== 'writing-mode') return false;

    if (prefix.js === 'Webkit' || prefix.js === 'ms' && prefix.browser !== 'edge') {
      return prefix.css + prop;
    }

    return prop;
  }
}; // https://caniuse.com/#search=user-select

var userSelect = {
  noPrefill: ['user-select'],
  supportedProperty: function supportedProperty(prop) {
    if (prop !== 'user-select') return false;

    if (prefix.js === 'Moz' || prefix.js === 'ms' || prefix.vendor === 'apple') {
      return prefix.css + prop;
    }

    return prop;
  }
}; // https://caniuse.com/#search=multicolumn
// https://github.com/postcss/autoprefixer/issues/491
// https://github.com/postcss/autoprefixer/issues/177

var breakPropsOld = {
  supportedProperty: function supportedProperty(prop, style) {
    if (!/^break-/.test(prop)) return false;

    if (prefix.js === 'Webkit') {
      var jsProp = "WebkitColumn" + pascalize(prop);
      return jsProp in style ? prefix.css + "column-" + prop : false;
    }

    if (prefix.js === 'Moz') {
      var _jsProp = "page" + pascalize(prop);

      return _jsProp in style ? "page-" + prop : false;
    }

    return false;
  }
}; // See https://github.com/postcss/autoprefixer/issues/324.

var inlineLogicalOld = {
  supportedProperty: function supportedProperty(prop, style) {
    if (!/^(border|margin|padding)-inline/.test(prop)) return false;
    if (prefix.js === 'Moz') return prop;
    var newProp = prop.replace('-inline', '');
    return prefix.js + pascalize(newProp) in style ? prefix.css + newProp : false;
  }
}; // Camelization is required because we can't test using.
// CSS syntax for e.g. in FF.

var unprefixed = {
  supportedProperty: function supportedProperty(prop, style) {
    return camelize(prop) in style ? prop : false;
  }
};
var prefixed = {
  supportedProperty: function supportedProperty(prop, style) {
    var pascalized = pascalize(prop); // Return custom CSS variable without prefixing.

    if (prop[0] === '-') return prop; // Return already prefixed value without prefixing.

    if (prop[0] === '-' && prop[1] === '-') return prop;
    if (prefix.js + pascalized in style) return prefix.css + prop; // Try webkit fallback.

    if (prefix.js !== 'Webkit' && "Webkit" + pascalized in style) return "-webkit-" + prop;
    return false;
  }
}; // https://caniuse.com/#search=scroll-snap

var scrollSnap = {
  supportedProperty: function supportedProperty(prop) {
    if (prop.substring(0, 11) !== 'scroll-snap') return false;

    if (prefix.js === 'ms') {
      return "" + prefix.css + prop;
    }

    return prop;
  }
}; // https://caniuse.com/#search=overscroll-behavior

var overscrollBehavior = {
  supportedProperty: function supportedProperty(prop) {
    if (prop !== 'overscroll-behavior') return false;

    if (prefix.js === 'ms') {
      return prefix.css + "scroll-chaining";
    }

    return prop;
  }
};
var propMap = {
  'flex-grow': 'flex-positive',
  'flex-shrink': 'flex-negative',
  'flex-basis': 'flex-preferred-size',
  'justify-content': 'flex-pack',
  order: 'flex-order',
  'align-items': 'flex-align',
  'align-content': 'flex-line-pack' // 'align-self' is handled by 'align-self' plugin.

}; // Support old flex spec from 2012.

var flex2012 = {
  supportedProperty: function supportedProperty(prop, style) {
    var newProp = propMap[prop];
    if (!newProp) return false;
    return prefix.js + pascalize(newProp) in style ? prefix.css + newProp : false;
  }
};
var propMap$1 = {
  flex: 'box-flex',
  'flex-grow': 'box-flex',
  'flex-direction': ['box-orient', 'box-direction'],
  order: 'box-ordinal-group',
  'align-items': 'box-align',
  'flex-flow': ['box-orient', 'box-direction'],
  'justify-content': 'box-pack'
};
var propKeys = Object.keys(propMap$1);

var prefixCss = function prefixCss(p) {
  return prefix.css + p;
}; // Support old flex spec from 2009.


var flex2009 = {
  supportedProperty: function supportedProperty(prop, style, _ref) {
    var multiple = _ref.multiple;

    if (propKeys.indexOf(prop) > -1) {
      var newProp = propMap$1[prop];

      if (!Array.isArray(newProp)) {
        return prefix.js + pascalize(newProp) in style ? prefix.css + newProp : false;
      }

      if (!multiple) return false;

      for (var i = 0; i < newProp.length; i++) {
        if (!(prefix.js + pascalize(newProp[0]) in style)) {
          return false;
        }
      }

      return newProp.map(prefixCss);
    }

    return false;
  }
}; // plugins = [
//   ...plugins,
//    breakPropsOld,
//    inlineLogicalOld,
//    unprefixed,
//    prefixed,
//    scrollSnap,
//    flex2012,
//    flex2009
// ]
// Plugins without 'noPrefill' value, going last.
// 'flex-*' plugins should be at the bottom.
// 'flex2009' going after 'flex2012'.
// 'prefixed' going after 'unprefixed'

var plugins = [appearence, colorAdjust, mask, textOrientation, transform, transition, writingMode, userSelect, breakPropsOld, inlineLogicalOld, unprefixed, prefixed, scrollSnap, overscrollBehavior, flex2012, flex2009];
var propertyDetectors = plugins.filter(function (p) {
  return p.supportedProperty;
}).map(function (p) {
  return p.supportedProperty;
});
var noPrefill = plugins.filter(function (p) {
  return p.noPrefill;
}).reduce(function (a, p) {
  a.push.apply(a, Object(_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__["default"])(p.noPrefill));
  return a;
}, []);
var el;
var cache = {};

if (is_in_browser__WEBPACK_IMPORTED_MODULE_0__["default"]) {
  el = document.createElement('p'); // We test every property on vendor prefix requirement.
  // Once tested, result is cached. It gives us up to 70% perf boost.
  // http://jsperf.com/element-style-object-access-vs-plain-object
  //
  // Prefill cache with known css properties to reduce amount of
  // properties we need to feature test at runtime.
  // http://davidwalsh.name/vendor-prefix

  var computed = window.getComputedStyle(document.documentElement, '');

  for (var key$1 in computed) {
    // eslint-disable-next-line no-restricted-globals
    if (!isNaN(key$1)) cache[computed[key$1]] = computed[key$1];
  } // Properties that cannot be correctly detected using the
  // cache prefill method.


  noPrefill.forEach(function (x) {
    return delete cache[x];
  });
}
/**
 * Test if a property is supported, returns supported property with vendor
 * prefix if required. Returns `false` if not supported.
 *
 * @param {String} prop dash separated
 * @param {Object} [options]
 * @return {String|Boolean}
 * @api public
 */


function supportedProperty(prop, options) {
  if (options === void 0) {
    options = {};
  } // For server-side rendering.


  if (!el) return prop; // Remove cache for benchmark tests or return property from the cache.

  if ( true && cache[prop] != null) {
    return cache[prop];
  } // Check if 'transition' or 'transform' natively supported in browser.


  if (prop === 'transition' || prop === 'transform') {
    options[prop] = prop in el.style;
  } // Find a plugin for current prefix property.


  for (var i = 0; i < propertyDetectors.length; i++) {
    cache[prop] = propertyDetectors[i](prop, el.style, options); // Break loop, if value found.

    if (cache[prop]) break;
  } // Reset styles for current property.
  // Firefox can even throw an error for invalid properties, e.g., "0".


  try {
    el.style[prop] = '';
  } catch (err) {
    return false;
  }

  return cache[prop];
}

var cache$1 = {};
var transitionProperties = {
  transition: 1,
  'transition-property': 1,
  '-webkit-transition': 1,
  '-webkit-transition-property': 1
};
var transPropsRegExp = /(^\s*[\w-]+)|, (\s*[\w-]+)(?![^()]*\))/g;
var el$1;
/**
 * Returns prefixed value transition/transform if needed.
 *
 * @param {String} match
 * @param {String} p1
 * @param {String} p2
 * @return {String}
 * @api private
 */

function prefixTransitionCallback(match, p1, p2) {
  if (p1 === 'var') return 'var';
  if (p1 === 'all') return 'all';
  if (p2 === 'all') return ', all';
  var prefixedValue = p1 ? supportedProperty(p1) : ", " + supportedProperty(p2);
  if (!prefixedValue) return p1 || p2;
  return prefixedValue;
}

if (is_in_browser__WEBPACK_IMPORTED_MODULE_0__["default"]) el$1 = document.createElement('p');
/**
 * Returns prefixed value if needed. Returns `false` if value is not supported.
 *
 * @param {String} property
 * @param {String} value
 * @return {String|Boolean}
 * @api public
 */

function supportedValue(property, value) {
  // For server-side rendering.
  var prefixedValue = value;
  if (!el$1 || property === 'content') return value; // It is a string or a number as a string like '1'.
  // We want only prefixable values here.
  // eslint-disable-next-line no-restricted-globals

  if (typeof prefixedValue !== 'string' || !isNaN(parseInt(prefixedValue, 10))) {
    return prefixedValue;
  } // Create cache key for current value.


  var cacheKey = property + prefixedValue; // Remove cache for benchmark tests or return value from cache.

  if ( true && cache$1[cacheKey] != null) {
    return cache$1[cacheKey];
  } // IE can even throw an error in some cases, for e.g. style.content = 'bar'.


  try {
    // Test value as it is.
    el$1.style[property] = prefixedValue;
  } catch (err) {
    // Return false if value not supported.
    cache$1[cacheKey] = false;
    return false;
  } // If 'transition' or 'transition-property' property.


  if (transitionProperties[property]) {
    prefixedValue = prefixedValue.replace(transPropsRegExp, prefixTransitionCallback);
  } else if (el$1.style[property] === '') {
    // Value with a vendor prefix.
    prefixedValue = prefix.css + prefixedValue; // Hardcode test to convert "flex" to "-ms-flexbox" for IE10.

    if (prefixedValue === '-ms-flex') el$1.style[property] = '-ms-flexbox'; // Test prefixed value.

    el$1.style[property] = prefixedValue; // Return false if value not supported.

    if (el$1.style[property] === '') {
      cache$1[cacheKey] = false;
      return false;
    }
  } // Reset styles for current property.


  el$1.style[property] = ''; // Write current value to cache.

  cache$1[cacheKey] = prefixedValue;
  return cache$1[cacheKey];
}



/***/ }),

/***/ "./node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var reactIs = __webpack_require__(/*! react-is */ "./node_modules/react-is/index.js");
/**
 * Copyright 2015, Yahoo! Inc.
 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */


var REACT_STATICS = {
  childContextTypes: true,
  contextType: true,
  contextTypes: true,
  defaultProps: true,
  displayName: true,
  getDefaultProps: true,
  getDerivedStateFromError: true,
  getDerivedStateFromProps: true,
  mixins: true,
  propTypes: true,
  type: true
};
var KNOWN_STATICS = {
  name: true,
  length: true,
  prototype: true,
  caller: true,
  callee: true,
  arguments: true,
  arity: true
};
var FORWARD_REF_STATICS = {
  '$$typeof': true,
  render: true,
  defaultProps: true,
  displayName: true,
  propTypes: true
};
var MEMO_STATICS = {
  '$$typeof': true,
  compare: true,
  defaultProps: true,
  displayName: true,
  propTypes: true,
  type: true
};
var TYPE_STATICS = {};
TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;

function getStatics(component) {
  // React v16.11 and below
  if (reactIs.isMemo(component)) {
    return MEMO_STATICS;
  } // React v16.12 and above


  return TYPE_STATICS[component['$$typeof']] || REACT_STATICS;
}

var defineProperty = Object.defineProperty;
var getOwnPropertyNames = Object.getOwnPropertyNames;
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var getPrototypeOf = Object.getPrototypeOf;
var objectPrototype = Object.prototype;

function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
  if (typeof sourceComponent !== 'string') {
    // don't hoist over string (html) components
    if (objectPrototype) {
      var inheritedComponent = getPrototypeOf(sourceComponent);

      if (inheritedComponent && inheritedComponent !== objectPrototype) {
        hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
      }
    }

    var keys = getOwnPropertyNames(sourceComponent);

    if (getOwnPropertySymbols) {
      keys = keys.concat(getOwnPropertySymbols(sourceComponent));
    }

    var targetStatics = getStatics(targetComponent);
    var sourceStatics = getStatics(sourceComponent);

    for (var i = 0; i < keys.length; ++i) {
      var key = keys[i];

      if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
        var descriptor = getOwnPropertyDescriptor(sourceComponent, key);

        try {
          // Avoid failures from read-only properties
          defineProperty(targetComponent, key, descriptor);
        } catch (e) {}
      }
    }
  }

  return targetComponent;
}

module.exports = hoistNonReactStatics;

/***/ }),

/***/ "./node_modules/is-in-browser/dist/module.js":
/*!***************************************************!*\
  !*** ./node_modules/is-in-browser/dist/module.js ***!
  \***************************************************/
/*! exports provided: isBrowser, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isBrowser", function() { return isBrowser; });
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};

var isBrowser = (typeof window === "undefined" ? "undefined" : _typeof(window)) === "object" && (typeof document === "undefined" ? "undefined" : _typeof(document)) === 'object' && document.nodeType === 9;
/* harmony default export */ __webpack_exports__["default"] = (isBrowser);

/***/ }),

/***/ "./node_modules/react-is/cjs/react-is.development.js":
/*!***********************************************************!*\
  !*** ./node_modules/react-is/cjs/react-is.development.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


if (true) {
  (function () {
    'use strict'; // The Symbol used to tag the ReactElement-like types. If there is no native Symbol
    // nor polyfill, then a plain number is used for performance.

    var hasSymbol = typeof Symbol === 'function' && Symbol.for;
    var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
    var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
    var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
    var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
    var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
    var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
    var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary
    // (unstable) APIs that have been removed. Can we remove the symbols?

    var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;
    var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;
    var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
    var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;
    var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;
    var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
    var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;
    var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for('react.block') : 0xead9;
    var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;
    var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;
    var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;

    function isValidElementType(type) {
      return typeof type === 'string' || typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
    }

    function typeOf(object) {
      if (typeof object === 'object' && object !== null) {
        var $$typeof = object.$$typeof;

        switch ($$typeof) {
          case REACT_ELEMENT_TYPE:
            var type = object.type;

            switch (type) {
              case REACT_ASYNC_MODE_TYPE:
              case REACT_CONCURRENT_MODE_TYPE:
              case REACT_FRAGMENT_TYPE:
              case REACT_PROFILER_TYPE:
              case REACT_STRICT_MODE_TYPE:
              case REACT_SUSPENSE_TYPE:
                return type;

              default:
                var $$typeofType = type && type.$$typeof;

                switch ($$typeofType) {
                  case REACT_CONTEXT_TYPE:
                  case REACT_FORWARD_REF_TYPE:
                  case REACT_LAZY_TYPE:
                  case REACT_MEMO_TYPE:
                  case REACT_PROVIDER_TYPE:
                    return $$typeofType;

                  default:
                    return $$typeof;
                }

            }

          case REACT_PORTAL_TYPE:
            return $$typeof;
        }
      }

      return undefined;
    } // AsyncMode is deprecated along with isAsyncMode


    var AsyncMode = REACT_ASYNC_MODE_TYPE;
    var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
    var ContextConsumer = REACT_CONTEXT_TYPE;
    var ContextProvider = REACT_PROVIDER_TYPE;
    var Element = REACT_ELEMENT_TYPE;
    var ForwardRef = REACT_FORWARD_REF_TYPE;
    var Fragment = REACT_FRAGMENT_TYPE;
    var Lazy = REACT_LAZY_TYPE;
    var Memo = REACT_MEMO_TYPE;
    var Portal = REACT_PORTAL_TYPE;
    var Profiler = REACT_PROFILER_TYPE;
    var StrictMode = REACT_STRICT_MODE_TYPE;
    var Suspense = REACT_SUSPENSE_TYPE;
    var hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated

    function isAsyncMode(object) {
      {
        if (!hasWarnedAboutDeprecatedIsAsyncMode) {
          hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint

          console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');
        }
      }
      return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
    }

    function isConcurrentMode(object) {
      return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
    }

    function isContextConsumer(object) {
      return typeOf(object) === REACT_CONTEXT_TYPE;
    }

    function isContextProvider(object) {
      return typeOf(object) === REACT_PROVIDER_TYPE;
    }

    function isElement(object) {
      return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
    }

    function isForwardRef(object) {
      return typeOf(object) === REACT_FORWARD_REF_TYPE;
    }

    function isFragment(object) {
      return typeOf(object) === REACT_FRAGMENT_TYPE;
    }

    function isLazy(object) {
      return typeOf(object) === REACT_LAZY_TYPE;
    }

    function isMemo(object) {
      return typeOf(object) === REACT_MEMO_TYPE;
    }

    function isPortal(object) {
      return typeOf(object) === REACT_PORTAL_TYPE;
    }

    function isProfiler(object) {
      return typeOf(object) === REACT_PROFILER_TYPE;
    }

    function isStrictMode(object) {
      return typeOf(object) === REACT_STRICT_MODE_TYPE;
    }

    function isSuspense(object) {
      return typeOf(object) === REACT_SUSPENSE_TYPE;
    }

    exports.AsyncMode = AsyncMode;
    exports.ConcurrentMode = ConcurrentMode;
    exports.ContextConsumer = ContextConsumer;
    exports.ContextProvider = ContextProvider;
    exports.Element = Element;
    exports.ForwardRef = ForwardRef;
    exports.Fragment = Fragment;
    exports.Lazy = Lazy;
    exports.Memo = Memo;
    exports.Portal = Portal;
    exports.Profiler = Profiler;
    exports.StrictMode = StrictMode;
    exports.Suspense = Suspense;
    exports.isAsyncMode = isAsyncMode;
    exports.isConcurrentMode = isConcurrentMode;
    exports.isContextConsumer = isContextConsumer;
    exports.isContextProvider = isContextProvider;
    exports.isElement = isElement;
    exports.isForwardRef = isForwardRef;
    exports.isFragment = isFragment;
    exports.isLazy = isLazy;
    exports.isMemo = isMemo;
    exports.isPortal = isPortal;
    exports.isProfiler = isProfiler;
    exports.isStrictMode = isStrictMode;
    exports.isSuspense = isSuspense;
    exports.isValidElementType = isValidElementType;
    exports.typeOf = typeOf;
  })();
}

/***/ }),

/***/ "./node_modules/react-is/index.js":
/*!****************************************!*\
  !*** ./node_modules/react-is/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react-is.development.js */ "./node_modules/react-is/cjs/react-is.development.js");
}

/***/ }),

/***/ "./node_modules/regenerator-runtime/runtime.js":
/*!*****************************************************!*\
  !*** ./node_modules/regenerator-runtime/runtime.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var runtime = function (exports) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.

  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function define(obj, key, value) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
    return obj[key];
  }

  try {
    // IE 8 has a broken Object.defineProperty that only works on DOM objects.
    define({}, "");
  } catch (err) {
    define = function (obj, key, value) {
      return obj[key] = value;
    };
  }

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []); // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.

    generator._invoke = makeInvokeMethod(innerFn, self, context);
    return generator;
  }

  exports.wrap = wrap; // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.

  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err) {
      return {
        type: "throw",
        arg: err
      };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed"; // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.

  var ContinueSentinel = {}; // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.

  function Generator() {}

  function GeneratorFunction() {}

  function GeneratorFunctionPrototype() {} // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.


  var IteratorPrototype = {};

  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));

  if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"); // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.

  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function (method) {
      define(prototype, method, function (arg) {
        return this._invoke(method, arg);
      });
    });
  }

  exports.isGeneratorFunction = function (genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can
    // do is to check its .name property.
    (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
  };

  exports.mark = function (genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      define(genFun, toStringTagSymbol, "GeneratorFunction");
    }

    genFun.prototype = Object.create(Gp);
    return genFun;
  }; // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.


  exports.awrap = function (arg) {
    return {
      __await: arg
    };
  };

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);

      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;

        if (value && typeof value === "object" && hasOwn.call(value, "__await")) {
          return PromiseImpl.resolve(value.__await).then(function (value) {
            invoke("next", value, resolve, reject);
          }, function (err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return PromiseImpl.resolve(value).then(function (unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function (error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function (resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise = // If enqueue has been called before, then we want to wait until
      // all previous Promises have been resolved before calling invoke,
      // so that results are always delivered in the correct order. If
      // enqueue has not been called before, then it is important to
      // call invoke immediately, without waiting on a callback to fire,
      // so that the async generator function has the opportunity to do
      // any necessary setup in a predictable way. This predictability
      // is why the Promise constructor synchronously invokes its
      // executor callback, and why async functions synchronously
      // execute code before the first await. Since we implement simple
      // async functions in terms of async generators, it is especially
      // important to get this right, even though it requires care.
      previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, // Avoid propagating failures to Promises returned by later
      // invocations of the iterator.
      callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
    } // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).


    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);

  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };

  exports.AsyncIterator = AsyncIterator; // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.

  exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    if (PromiseImpl === void 0) PromiseImpl = Promise;
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
    return exports.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.
    : iter.next().then(function (result) {
      return result.done ? result.value : iter.next();
    });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;
    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        } // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume


        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;

        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);

          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;
        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);
        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;
        var record = tryCatch(innerFn, self, context);

        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done ? GenStateCompleted : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };
        } else if (record.type === "throw") {
          state = GenStateCompleted; // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.

          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  } // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.


  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];

    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError("The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (!info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value; // Resume execution at the desired location (see delegateYield).

      context.next = delegate.nextLoc; // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.

      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }
    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    } // The delegate iterator is finished, so forget it and continue with
    // the outer generator.


    context.delegate = null;
    return ContinueSentinel;
  } // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.


  defineIteratorMethods(Gp);
  define(Gp, toStringTagSymbol, "Generator"); // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.

  Gp[iteratorSymbol] = function () {
    return this;
  };

  Gp.toString = function () {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{
      tryLoc: "root"
    }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function (object) {
    var keys = [];

    for (var key in object) {
      keys.push(key);
    }

    keys.reverse(); // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.

    return function next() {
      while (keys.length) {
        var key = keys.pop();

        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      } // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.


      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];

      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1,
            next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;
          return next;
        };

        return next.next = next;
      }
    } // Return an iterator with no values.


    return {
      next: doneResult
    };
  }

  exports.values = values;

  function doneResult() {
    return {
      value: undefined,
      done: true
    };
  }

  Context.prototype = {
    constructor: Context,
    reset: function (skipTempReset) {
      this.prev = 0;
      this.next = 0; // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.

      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;
      this.method = "next";
      this.arg = undefined;
      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },
    stop: function () {
      this.done = true;
      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;

      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },
    dispatchException: function (exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;

      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !!caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }
          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }
          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },
    abrupt: function (type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },
    complete: function (record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" || record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },
    finish: function (finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },
    "catch": function (tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;

          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }

          return thrown;
        }
      } // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.


      throw new Error("illegal catch attempt");
    },
    delegateYield: function (iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  }; // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.

  return exports;
}( // If this script is executing as a CommonJS module, use module.exports
// as the regeneratorRuntime namespace. Otherwise create a new empty
// object. Either way, the resulting object will be used to initialize
// the regeneratorRuntime variable at the top of this file.
 true ? module.exports : undefined);

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  Function("r", "regeneratorRuntime = r")(runtime);
}

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g; // This works in non-strict mode

g = function () {
  return this;
}();

try {
  // This works if eval is allowed (see CSP)
  g = g || new Function("return this")();
} catch (e) {
  // This works if the window reference is available
  if (typeof window === "object") g = window;
} // g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}


module.exports = g;

/***/ }),

/***/ "./src/apis/index.js":
/*!***************************!*\
  !*** ./src/apis/index.js ***!
  \***************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _framework___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/framework/ */ "./src/framework/index.js");
/* harmony import */ var _utils_callBridge__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/utils/callBridge */ "./src/utils/callBridge.js");
/* harmony import */ var _utils_callInternalAPI__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/utils/callInternalAPI */ "./src/utils/callInternalAPI.js");
/* harmony import */ var _utils_reportError__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/utils/reportError */ "./src/utils/reportError.js");
/* harmony import */ var _utils_system__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/utils/system */ "./src/utils/system.js");
/* harmony import */ var _utils_addEvents__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/utils/addEvents */ "./src/utils/addEvents.js");
/* harmony import */ var _web_TrackerAPI__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./web/TrackerAPI */ "./src/apis/web/TrackerAPI.js");
/* harmony import */ var _web_loadFontFace__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./web/loadFontFace */ "./src/apis/web/loadFontFace.js");
/* harmony import */ var _web_createSelectorQuery__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./web/createSelectorQuery */ "./src/apis/web/createSelectorQuery.js");
/* harmony import */ var _web_IntersectionObserver__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./web/IntersectionObserver */ "./src/apis/web/IntersectionObserver.js");


function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }











var g = self;
var messageQueue = [];

var bridge = _objectSpread(_objectSpread(_objectSpread({
  // for internal call render
  fireMessage: function fireMessage(data) {
    messageQueue.forEach(function (f) {
      return f(data);
    });
  },
  onMessage: function onMessage(fn) {
    messageQueue.push(fn);
    return function () {
      var index = messageQueue.indexOf(fn);

      if (index !== -1) {
        messageQueue.splice(index, 1);
      }
    };
  },
  reLaunch: function reLaunch(options) {
    var url = options.url;

    if (url.charAt(0) === '/') {
      url = url.slice(1);
    }

    var launchParamsTag = url;
    var queryIndex = url.indexOf('?');

    if (queryIndex !== -1) {
      launchParamsTag = url.slice(0, queryIndex);
    }

    var isTab = !!_framework___WEBPACK_IMPORTED_MODULE_1__["$global"].tabsConfig[url]; // init tabs config

    if (isTab) {
      bridge.call('switchTab', {
        tag: url,
        recreate: true
      });
    } else {
      bridge.call('pushWindow', {
        url: "#".concat(url),
        launchParamsTag: launchParamsTag,
        param: {
          closeAllWindow: true,
          animationType: 'none'
        }
      });
    }
  },
  pageScrollTo: function pageScrollTo() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        scrollTop = _ref.scrollTop;

    window.scrollTo(window.pageXOffset, scrollTop);
  },
  SDKVersion: _utils_system__WEBPACK_IMPORTED_MODULE_5__["SDKVersion"]
}, _web_TrackerAPI__WEBPACK_IMPORTED_MODULE_7__["default"]), _web_loadFontFace__WEBPACK_IMPORTED_MODULE_8__["default"]), {}, {
  createSelectorQuery: _web_createSelectorQuery__WEBPACK_IMPORTED_MODULE_9__["default"],
  addIntersectionObserver: _web_IntersectionObserver__WEBPACK_IMPORTED_MODULE_10__["addIntersectionObserver"],
  removeIntersectionObserver: _web_IntersectionObserver__WEBPACK_IMPORTED_MODULE_10__["removeIntersectionObserver"],
  reportError: _utils_reportError__WEBPACK_IMPORTED_MODULE_4__["default"],
  call: _utils_callBridge__WEBPACK_IMPORTED_MODULE_2__["default"],
  callInternalAPI: _utils_callInternalAPI__WEBPACK_IMPORTED_MODULE_3__["default"],
  console: function (_console) {
    function console() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _console.apply(this, args);
    }

    console.toString = function () {
      return _console.toString();
    };

    return console;
  }(function (type) {
    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }

    console[type].apply(console, args.slice(0, -2));
  }),
  hideKeyboard: function hideKeyboard() {
    var _document = document,
        activeElement = _document.activeElement;

    if (activeElement && activeElement.blur) {
      activeElement.blur();
    }

    if (window._MpActiveNativeElement !== undefined) {
      Object(_utils_callBridge__WEBPACK_IMPORTED_MODULE_2__["default"])('NBComponent.sendMessage', {
        actionType: 'blur',
        element: window._MpActiveNativeElement
      });
    }
  }
});

var dispatchPageReRenderEvent = function dispatchPageReRenderEvent() {
  document.dispatchEvent(new CustomEvent('pageReRender', {}));
};

Object(_utils_addEvents__WEBPACK_IMPORTED_MODULE_6__["default"])(document, {
  onShare: function onShare(e) {
    var page = Object(_framework___WEBPACK_IMPORTED_MODULE_1__["getCurrentPageImpl"])();

    if (page && page.publicInstance.onShareAppMessage) {
      e.preventDefault();
    }
  },
  firePullToRefresh: function firePullToRefresh(e) {
    e.preventDefault();
  },
  pullIntercept: function pullIntercept(e) {
    e.preventDefault();
  },
  pageReRender: function pageReRender() {
    Object(_web_IntersectionObserver__WEBPACK_IMPORTED_MODULE_10__["scheduleIntersectionUpdate"])();
  }
});
Object(_utils_addEvents__WEBPACK_IMPORTED_MODULE_6__["default"])(window, {
  resize: dispatchPageReRenderEvent,
  animationstart: dispatchPageReRenderEvent,
  animationiteration: dispatchPageReRenderEvent,
  animationend: dispatchPageReRenderEvent,
  transitionend: dispatchPageReRenderEvent
});
window.addEventListener('scroll', function () {
  Object(_web_IntersectionObserver__WEBPACK_IMPORTED_MODULE_10__["scheduleIntersectionUpdate"])();
}, {
  capture: true,
  passive: true
});
_framework___WEBPACK_IMPORTED_MODULE_1__["EventHub"].addListener(['pageReady', 'pageUpdate'], function () {
  dispatchPageReRenderEvent();
});
Object(_utils_system__WEBPACK_IMPORTED_MODULE_5__["logSystemInfo"])();
_framework___WEBPACK_IMPORTED_MODULE_1__["$global"].bridge = bridge;
/* harmony default export */ __webpack_exports__["default"] = (bridge);

/***/ }),

/***/ "./src/apis/web/IntersectionObserver.js":
/*!**********************************************!*\
  !*** ./src/apis/web/IntersectionObserver.js ***!
  \**********************************************/
/*! exports provided: addIntersectionObserver, removeIntersectionObserver, scheduleIntersectionUpdate */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addIntersectionObserver", function() { return addIntersectionObserver; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "removeIntersectionObserver", function() { return removeIntersectionObserver; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scheduleIntersectionUpdate", function() { return scheduleIntersectionUpdate; });
/* harmony import */ var _framework___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/framework/ */ "./src/framework/index.js");
/* harmony import */ var _utils_requestAnimationFrame__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/utils/requestAnimationFrame */ "./src/utils/requestAnimationFrame.js");


var requestAnimationFrameing = false;
var intersectionObservers = {};
var subIntersectionObservers = {};

var formatMargins = function formatMargins() {
  var margins = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return {
    left: margins.left || 0,
    top: margins.top || 0,
    right: margins.right || 0,
    bottom: margins.bottom || 0
  };
};

var formatRect = function formatRect() {
  var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return {
    left: params.left,
    top: params.top,
    right: params.right,
    bottom: params.bottom,
    width: params.width,
    height: params.height
  };
}; // 矩阵相交计算


var getIntersectRect = function getIntersectRect(rect1, rect2) {
  var intersectRect = {
    left: rect1.left < rect2.left ? rect2.left : rect1.left,
    top: rect1.top < rect2.top ? rect2.top : rect1.top,
    right: rect1.right > rect2.right ? rect2.right : rect1.right,
    bottom: rect1.bottom > rect2.bottom ? rect2.bottom : rect1.bottom,
    width: 0,
    height: 0
  };

  if (intersectRect.right > intersectRect.left) {
    intersectRect.width = intersectRect.right - intersectRect.left;
  } else {
    intersectRect.right = intersectRect.left = intersectRect.bottom = intersectRect.top = 0;
  }

  if (intersectRect.bottom > intersectRect.top) {
    intersectRect.height = intersectRect.bottom - intersectRect.top;
  } else {
    intersectRect.right = intersectRect.left = intersectRect.bottom = intersectRect.top = 0;
  }

  return intersectRect;
}; // 返回所有参照节点的相交矩阵


var getRelativeIntersectRect = function getRelativeIntersectRect(relatives) {
  var _document$documentEle = document.documentElement;
  var clientWidth = _document$documentEle.clientWidth,
      clientHeight = _document$documentEle.clientHeight;
  var relativeIntersectRect = null;

  for (var i = 0; i < relatives.length; i++) {
    var _relatives$i = relatives[i];
    var node = _relatives$i.node;
    var margins = _relatives$i.margins;
    var relativeRect = node ? node.getBoundingClientRect() : {
      left: 0,
      top: 0,
      right: clientWidth,
      bottom: clientHeight,
      width: clientWidth,
      height: clientHeight
    };
    var relativeRectWithMargins = {
      left: relativeRect.left - margins.left,
      top: relativeRect.top - margins.top,
      right: relativeRect.right + margins.right,
      bottom: relativeRect.bottom + margins.bottom
    };
    relativeIntersectRect = relativeIntersectRect ? getIntersectRect(relativeIntersectRect, relativeRectWithMargins) : relativeRectWithMargins;
  }

  return relativeIntersectRect;
}; // 判断节点是否相交


var checkIntersection = function checkIntersection(params) {
  var targetNode = params.targetNode,
      relatives = params.relatives,
      thresholds = params.thresholds,
      currentRatio = params.currentRatio,
      intersectionObserverId = params.intersectionObserverId; // 执行检测的时候节点已经消失

  if (!targetNode) {
    return;
  }

  var relativeIntersectRect = getRelativeIntersectRect(relatives);
  var rect = formatRect(targetNode.getBoundingClientRect());
  var intersectRect = getIntersectRect(relativeIntersectRect, rect);
  var area = rect.width * rect.height;
  var latestCurrentRatio = area ? intersectRect.width * intersectRect.height / area : 0; // 有点绕，请注意

  params.currentRatio = latestCurrentRatio;
  var shouldFireIntersectionEvent = undefined === currentRatio;

  if (currentRatio !== latestCurrentRatio) {
    thresholds.forEach(function (threshold) {
      if (shouldFireIntersectionEvent) return false;

      if (latestCurrentRatio <= threshold && currentRatio >= threshold) {
        shouldFireIntersectionEvent = true;
      } else if (latestCurrentRatio >= threshold && currentRatio <= threshold) {
        shouldFireIntersectionEvent = true;
      }
    });
  }

  if (shouldFireIntersectionEvent) {
    Object(_framework___WEBPACK_IMPORTED_MODULE_0__["getCurrentPageImpl"])().callRemote('bridge', '_fireIntersectionObserver', {
      intersectionObserverId: intersectionObserverId,
      info: {
        id: targetNode.id,
        dataset: targetNode.dataset,
        time: Date.now(),
        boundingClientRect: rect,
        intersectionRatio: latestCurrentRatio,
        intersectionRect: formatRect(intersectRect),
        relativeRect: relativeIntersectRect
      }
    });
  }
};

var handleIntersectionObserver = function handleIntersectionObserver(targetNodeArr, relatives, thresholds, currentRatio, intersectionObserverId) {
  if (!targetNodeArr.length || !relatives.length) {
    return;
  }

  intersectionObservers[intersectionObserverId] = targetNodeArr.length;
  targetNodeArr.forEach(function (targetNode, index) {
    var subIntersectionObserverId = "".concat(intersectionObserverId, "@").concat(index);
    var IntersectionParams = {
      targetNode: targetNode,
      relatives: relatives,
      thresholds: thresholds,
      currentRatio: currentRatio,
      intersectionObserverId: intersectionObserverId
    }; // 当执行时目标已经已经移除

    if (!targetNode) {
      delete subIntersectionObservers[subIntersectionObserverId];
      --intersectionObservers[intersectionObserverId];
    } else {
      subIntersectionObservers[subIntersectionObserverId] = IntersectionParams;
      Object(_utils_requestAnimationFrame__WEBPACK_IMPORTED_MODULE_1__["default"])(function (_timestamp) {
        checkIntersection(IntersectionParams);
      });
    }
  });
};

function checkAllIntersection() {
  for (var subIntersectionObserverId in subIntersectionObservers) {
    checkIntersection(subIntersectionObservers[subIntersectionObserverId]);
  }

  requestAnimationFrameing = false;
} // 添加节点相交查询


function addIntersectionObserver(_ref) {
  var intersectionObserverId = _ref.intersectionObserverId,
      options = _ref.options,
      relativeInfo = _ref.relativeInfo,
      targetSelector = _ref.targetSelector;
  var targetNodeArr = [];

  if (options.selectAll) {
    targetNodeArr = document.querySelectorAll(targetSelector);
  } else {
    var targetNode = document.querySelector(targetSelector);
    targetNodeArr = targetNode ? [targetNode] : [];
  }

  if (!targetNodeArr.length) {
    console.warn("\u76EE\u6807\u8282\u70B9".concat(targetSelector, "\u672A\u627E\u5230\uFF0C\u5F53\u524D\u76D1\u542C\u672A\u751F\u6548"));
  }

  var relatives = [];
  relativeInfo.forEach(function (info) {
    var selector = info.selector;
    var margins = info.margins;
    var node;

    if (selector == null) {
      node = null;
    } else {
      node = document.querySelector(selector);
    }

    if (node || selector == null) {
      relatives.push({
        node: node,
        margins: formatMargins(margins)
      });
    } else {
      console.warn("\u53C2\u7167\u8282\u70B9".concat(selector, "\u672A\u627E\u5230\uFF0C\u6B64\u53C2\u7167\u8282\u70B9\u5C06\u4F1A\u88AB\u5FFD\u7565"));
    }
  });

  if (!relatives.length) {
    console.warn('未找到任何参照节点，当前监听未生效');
  }

  return handleIntersectionObserver(targetNodeArr, relatives, options.thresholds, options.initialRatio, intersectionObserverId);
}
function removeIntersectionObserver(intersectionObserverId) {
  var len = intersectionObservers[intersectionObserverId];

  for (var i = 0; i < len; i++) {
    var subIntersectionObserverId = "".concat(intersectionObserverId, "@").concat(i);
    delete subIntersectionObservers[subIntersectionObserverId];
  }

  delete intersectionObservers[intersectionObserverId];
}
function scheduleIntersectionUpdate() {
  if (!requestAnimationFrameing) {
    Object(_utils_requestAnimationFrame__WEBPACK_IMPORTED_MODULE_1__["default"])(function () {
      requestAnimationFrameing = true;
      checkAllIntersection();
    });
  }
}

/***/ }),

/***/ "./src/apis/web/TrackerAPI.js":
/*!************************************!*\
  !*** ./src/apis/web/TrackerAPI.js ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _framework___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/framework/ */ "./src/framework/index.js");
/* harmony import */ var _utils_trackerStore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/utils/trackerStore */ "./src/utils/trackerStore.js");


/* harmony default export */ __webpack_exports__["default"] = ({
  setTrackerConfig: function setTrackerConfig(trackerConfig) {
    _utils_trackerStore__WEBPACK_IMPORTED_MODULE_1__["default"].trackerConfig = trackerConfig;
  },
  collectRemoteTrackerData: function collectRemoteTrackerData(eventCode, payload) {
    Object(_framework___WEBPACK_IMPORTED_MODULE_0__["getCurrentPageImpl"])().callRemote('bridge.$trackerAPI', 'collectTrackerData', Object(_framework___WEBPACK_IMPORTED_MODULE_0__["getCurrentPageImpl"])().getId(), eventCode, payload);
  },
  reportRemoteTrackerData: function reportRemoteTrackerData(eventCode, payload) {
    Object(_framework___WEBPACK_IMPORTED_MODULE_0__["getCurrentPageImpl"])().callRemote('bridge.$trackerAPI', 'reportTrackerData', Object(_framework___WEBPACK_IMPORTED_MODULE_0__["getCurrentPageImpl"])().getId(), eventCode, payload);
  }
});

/***/ }),

/***/ "./src/apis/web/createSelectorQuery.js":
/*!*********************************************!*\
  !*** ./src/apis/web/createSelectorQuery.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return createSelectorQuery; });
var doc = document;
var win = window;

function getNodeQuery(node, type) {
  if (type === 'rect') {
    var clientRect = node.getBoundingClientRect();
    var rect = {}; // rect.left    // 节点的左边界坐标
    // rect.right   // 节点的右边界坐标
    // rect.top     // 节点的上边界坐标
    // rect.bottom  // 节点的下边界坐标
    // rect.width   // 节点的宽度
    // rect.height  // 节点的高度

    var rectProps = ['left', 'right', 'top', 'bottom', 'width', 'height'];

    for (var i = 0; i < rectProps.length; i++) {
      if (clientRect[rectProps[i]] !== undefined) {
        rect[rectProps[i]] = clientRect[rectProps[i]];
      }
    }

    return rect;
  } else if (type === 'scroll') {
    return {
      scrollTop: node.scrollTop,
      scrollLeft: node.scrollLeft
    };
  }
}

function createSelectorQuery(actions, callback) {
  var ret = [];
  actions.forEach(function (action) {
    var selector = action.selector,
        type = action.type;
    var value = selector.value;
    var selectorType = selector.type;

    if (value === 'viewport') {
      if (type === 'rect') {
        ret.push({
          width: win.innerWidth,
          height: win.innerHeight
        });
      } else if (type === 'scroll') {
        ret.push({
          scrollTop: win.pageYOffset,
          scrollLeft: win.pageXOffset
        });
      }
    } else if (selectorType === 'all') {
      var nodes = [].slice.call(doc.querySelectorAll(value), 0);

      if (nodes.length) {
        ret.push(nodes.map(function (node) {
          return getNodeQuery(node, type);
        }));
      } else {
        ret.push(null);
      }
    } else {
      var node = doc.querySelector(value);

      if (node) {
        ret.push(getNodeQuery(node, type));
      } else {
        ret.push(null);
      }
    }
  });
  callback(ret);
}

/***/ }),

/***/ "./src/apis/web/loadFontFace.js":
/*!**************************************!*\
  !*** ./src/apis/web/loadFontFace.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ({
  loadFontFace: function loadFontFace() {
    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var success = arguments.length > 1 ? arguments[1] : undefined;
    var fail = arguments.length > 2 ? arguments[2] : undefined;
    var _data$family = data.family,
        family = _data$family === void 0 ? '' : _data$family,
        _data$source = data.source,
        source = _data$source === void 0 ? '' : _data$source,
        _data$desc = data.desc,
        desc = _data$desc === void 0 ? {} : _data$desc;
    var _document = document,
        fonts = _document.fonts;

    if (fonts) {
      var fontFace = new FontFace(family, source, desc);
      fontFace.load().then(function (res) {
        success({
          status: res.status
        });
        fonts.add(fontFace);
      }, function () {
        fail({
          status: fontFace.status
        });
      });
    } else {
      if (!family || !source) {
        fail({
          status: 'error'
        });
        return;
      }

      var style = document.createElement('style');
      var node = "@font-face {font-family: \"".concat(family, "\"; src: ").concat(source, "; font-weight: ").concat(desc.weight, "; font-stretch: ").concat(desc.stretch, "; font-variant: ").concat(desc.variant, "; font-feature-setting:").concat(desc.featureSetting, "; unicode-range: ").concat(desc.unicodeRange, "; font-style: ").concat(desc.style, "; }");
      style.appendChild(document.createTextNode(node));
      document.head.appendChild(style);
      success({
        status: 'loaded'
      });
    }
  }
});

/***/ }),

/***/ "./src/framework/App/index.js":
/*!************************************!*\
  !*** ./src/framework/App/index.js ***!
  \************************************/
/*! exports provided: App, setCurrentPageImpl, getCurrentPageImpl, getCurrentPagesImpl, getApp, getAppImpl, getCurrentPages */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "App", function() { return App; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setCurrentPageImpl", function() { return setCurrentPageImpl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCurrentPageImpl", function() { return getCurrentPageImpl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCurrentPagesImpl", function() { return getCurrentPagesImpl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getApp", function() { return getApp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getAppImpl", function() { return getAppImpl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCurrentPages", function() { return getCurrentPages; });
var app = {
  getCurrentPageImpl: getCurrentPageImpl
};
var currentPage;

function App() {
  return app;
}

function setCurrentPageImpl(page) {
  currentPage = page;
}

function getCurrentPageImpl() {
  return currentPage;
}

function getCurrentPagesImpl() {
  return [currentPage];
}

function getApp() {
  return app;
}

function getAppImpl() {
  return app;
}

function getCurrentPages() {
  return null;
}



/***/ }),

/***/ "./src/framework/Component/index.js":
/*!******************************************!*\
  !*** ./src/framework/Component/index.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Component; });
/* harmony import */ var _ComponentRegistry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ComponentRegistry */ "./src/framework/ComponentRegistry/index.js");
/* harmony import */ var _common_global__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/global */ "./src/framework/common/global.js");
/* harmony import */ var _legacy_CustomComponent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../legacy/CustomComponent */ "./src/framework/legacy/CustomComponent.js");



function Component(setupConfig) {
  var is = setupConfig.is;
  _common_global__WEBPACK_IMPORTED_MODULE_1__["default"].componentsConfig[is] = {
    system: setupConfig
  };
  _ComponentRegistry__WEBPACK_IMPORTED_MODULE_0__["default"].registerComponent(is, function () {
    return Object(_legacy_CustomComponent__WEBPACK_IMPORTED_MODULE_2__["default"])(is);
  });
}

/***/ }),

/***/ "./src/framework/ComponentRegistry/getComponentClass.js":
/*!**************************************************************!*\
  !*** ./src/framework/ComponentRegistry/getComponentClass.js ***!
  \**************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index */ "./src/framework/ComponentRegistry/index.js");


function getComponentClass(is) {
  return _index__WEBPACK_IMPORTED_MODULE_0__["default"].getComponent(is);
}

/* harmony default export */ __webpack_exports__["default"] = (getComponentClass);

/***/ }),

/***/ "./src/framework/ComponentRegistry/index.js":
/*!**************************************************!*\
  !*** ./src/framework/ComponentRegistry/index.js ***!
  \**************************************************/
/*! exports provided: componentRegistry, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "componentRegistry", function() { return componentRegistry; });
var componentRegistry = {};
var ComponentRegistry = {
  registerComponent: function registerComponent(is, factory) {
    if (componentRegistry[is]) {
      return;
    }

    componentRegistry[is] = factory;
  },
  getComponent: function getComponent(is) {
    return componentRegistry[is] && componentRegistry[is]();
  }
};
/* harmony default export */ __webpack_exports__["default"] = (ComponentRegistry);

/***/ }),

/***/ "./src/framework/EventHub.js":
/*!***********************************!*\
  !*** ./src/framework/EventHub.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utils_EventEmitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/EventEmitter */ "./src/utils/EventEmitter.js");

/* harmony default export */ __webpack_exports__["default"] = (new _utils_EventEmitter__WEBPACK_IMPORTED_MODULE_0__["default"]());

/***/ }),

/***/ "./src/framework/Page/index.js":
/*!*************************************!*\
  !*** ./src/framework/Page/index.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Page; });
/* harmony import */ var _PageRegistry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../PageRegistry */ "./src/framework/PageRegistry/index.js");
/* harmony import */ var _common_global__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/global */ "./src/framework/common/global.js");
/* harmony import */ var _legacy_PageComponent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../legacy/PageComponent */ "./src/framework/legacy/PageComponent.js");



function Page(setupConfig) {
  var pagePath = setupConfig.pagePath,
      tabIndex = setupConfig.tabIndex;

  if (typeof tabIndex === 'number') {
    _common_global__WEBPACK_IMPORTED_MODULE_1__["default"].tabsConfig[pagePath] = tabIndex;
  }

  _common_global__WEBPACK_IMPORTED_MODULE_1__["default"].pagesConfig[pagePath] = {
    system: setupConfig
  };
  _PageRegistry__WEBPACK_IMPORTED_MODULE_0__["default"].registerComponent(pagePath, function () {
    return _legacy_PageComponent__WEBPACK_IMPORTED_MODULE_2__["default"];
  });
}

/***/ }),

/***/ "./src/framework/PageRegistry/index.js":
/*!*********************************************!*\
  !*** ./src/framework/PageRegistry/index.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// app注册page
var pageRegistry = {};
var PageRegistry = {
  registerComponent: function registerComponent(name, factory) {
    // name即pagePath
    // factory即() => RC
    pageRegistry[name] = factory;
  },
  getComponent: function getComponent(name) {
    return pageRegistry[name] && pageRegistry[name]();
  },
  getRunnable: function getRunnable(name) {
    return PageRegistry.getComponent(name);
  }
};
/* harmony default export */ __webpack_exports__["default"] = (PageRegistry);

/***/ }),

/***/ "./src/framework/Platform/index.js":
/*!*****************************************!*\
  !*** ./src/framework/Platform/index.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var ua = navigator.swuserAgent || navigator.userAgent;
var ios = /iPhone|iPad/i; // android can change ua?!

var Platform = {
  OS: 'web',
  ide: ua.indexOf('IDE') > -1,
  browser: ua.indexOf('Android') > -1 ? 'android' : ua.match(ios) ? 'ios' : 'unknown'
};
/* harmony default export */ __webpack_exports__["default"] = (Platform);

/***/ }),

/***/ "./src/framework/StyleSheet/index.web.js":
/*!***********************************************!*\
  !*** ./src/framework/StyleSheet/index.web.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utils_mergeArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/mergeArray */ "./src/utils/mergeArray.js");


function StyleSheet() {
  this.deps = [];
  this.style = '';
}

StyleSheet.prototype = {
  imports: function imports() {
    for (var _len = arguments.length, deps = new Array(_len), _key = 0; _key < _len; _key++) {
      deps[_key] = arguments[_key];
    }

    Object(_utils_mergeArray__WEBPACK_IMPORTED_MODULE_0__["default"])(this.deps, deps);
    return this;
  },
  exports: function exports(style) {
    this.style = style;
    return this;
  },
  toObjects: function toObjects() {
    if (this.objectArray) {
      return this.objectArray;
    } // incase recrursive


    this.objectArray = [];
    var all = [];
    this.deps.forEach(function (d) {
      var ds = d.toObjects();
      Object(_utils_mergeArray__WEBPACK_IMPORTED_MODULE_0__["default"])(all, ds);
    });
    all.push(this);
    this.objectArray = all;
    return all;
  },
  toString: function toString() {
    if (this.valueString) {
      return this.valueString;
    }

    this.valueString = this.toObjects().map(function (o) {
      return o.style;
    }).join('\n');
    return this.valueString;
  }
};
/* harmony default export */ __webpack_exports__["default"] = (StyleSheet);

/***/ }),

/***/ "./src/framework/SubPackage/index.js":
/*!*******************************************!*\
  !*** ./src/framework/SubPackage/index.js ***!
  \*******************************************/
/*! exports provided: loadPage */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadPage", function() { return loadPage; });
/* harmony import */ var _utils_startsWith__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/startsWith */ "./src/utils/startsWith.js");
/* harmony import */ var _utils_startupParams__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/utils/startupParams */ "./src/utils/startupParams/index.js");
/* harmony import */ var _common_global__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/global */ "./src/framework/common/global.js");



var g = self;

function getSubPackageByPage(page) {
  var mpAppJson = g.mpAppJson;

  if (!mpAppJson || !mpAppJson.app.subPackages) {
    return false;
  }

  var subPackages = mpAppJson.app.subPackages;

  for (var i = 0; i < subPackages.length; i++) {
    var p = subPackages[i];

    if (Object(_utils_startsWith__WEBPACK_IMPORTED_MODULE_0__["default"])(page, "".concat(p.root, "/"))) {
      return p.root;
    }
  }

  return false;
}

var packageMap = {};
var packageListeners = {};

g.bootstrapSubPackage = function (subPackage, _ref) {
  var success = _ref.success;
  packageMap[subPackage] = 1;
  success();

  if (packageListeners[subPackage]) {
    packageListeners[subPackage]();
    delete packageListeners[subPackage];
  }
};

var isWorker = typeof importScripts !== 'undefined';

function loadPackageScript(subPackage, callback) {
  var url = "/".concat(subPackage);

  if (isWorker) {
    importScripts("".concat(url, "/index.worker.js"));
    callback();
  } else {
    var script = document.createElement('script');
    script.src = "".concat(url, "/index.js");
    document.head.appendChild(script); // do not use script.onload

    packageListeners[subPackage] = callback;
  }
}

function loadPage(pagePath, doLoad) {
  var isCli = Object(_utils_startupParams__WEBPACK_IMPORTED_MODULE_1__["getStartupParams"])().mpCli;
  var subPackage = getSubPackageByPage(pagePath);

  if (subPackage) {
    var callBridge = _common_global__WEBPACK_IMPORTED_MODULE_2__["default"].bridge.call;

    if (packageMap[subPackage]) {
      doLoad();
    } else {
      var doLoadScript = function doLoadScript() {
        loadPackageScript(subPackage, function () {
          if (isWorker) {
            _common_global__WEBPACK_IMPORTED_MODULE_2__["default"].bridge.call('hideLoading');
          }

          doLoad();
        });
      };

      if (isWorker) {
        callBridge('showLoading');
      }

      if (isCli) {
        doLoadScript();
      } else {
        callBridge('loadSubPackage', {
          packages: [subPackage]
        }, doLoadScript);
      }
    }
  } else {
    doLoad();
  }
}

/***/ }),

/***/ "./src/framework/common/commonLogic.js":
/*!*********************************************!*\
  !*** ./src/framework/common/commonLogic.js ***!
  \*********************************************/
/*! exports provided: $global, Page, App, getApp, getCurrentPages, Component */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _global__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./global */ "./src/framework/common/global.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "$global", function() { return _global__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _Page__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Page */ "./src/framework/Page/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Page", function() { return _Page__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _App__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../App */ "./src/framework/App/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "App", function() { return _App__WEBPACK_IMPORTED_MODULE_2__["App"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getApp", function() { return _App__WEBPACK_IMPORTED_MODULE_2__["getApp"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getCurrentPages", function() { return _App__WEBPACK_IMPORTED_MODULE_2__["getCurrentPages"]; });

/* harmony import */ var _Component__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Component */ "./src/framework/Component/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Component", function() { return _Component__WEBPACK_IMPORTED_MODULE_3__["default"]; });







/***/ }),

/***/ "./src/framework/common/commonUI.js":
/*!******************************************!*\
  !*** ./src/framework/common/commonUI.js ***!
  \******************************************/
/*! exports provided: StyleSheet, createComponent, getComponentClass */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _StyleSheet_index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../StyleSheet/index */ "./src/framework/StyleSheet/index.web.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "StyleSheet", function() { return _StyleSheet_index__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _createComponent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../createComponent */ "./src/framework/createComponent/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createComponent", function() { return _createComponent__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _ComponentRegistry_getComponentClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../ComponentRegistry/getComponentClass */ "./src/framework/ComponentRegistry/getComponentClass.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getComponentClass", function() { return _ComponentRegistry_getComponentClass__WEBPACK_IMPORTED_MODULE_2__["default"]; });






/***/ }),

/***/ "./src/framework/common/global.js":
/*!****************************************!*\
  !*** ./src/framework/common/global.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var $global = {
  tabsConfig: {},
  pagesConfig: {},
  componentsConfig: {},
  currentPageConfig: null,
  currentComponentConfig: null
};
/* harmony default export */ __webpack_exports__["default"] = ($global);

/***/ }),

/***/ "./src/framework/createComponent/index.js":
/*!************************************************!*\
  !*** ./src/framework/createComponent/index.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return createComponent; });
/* harmony import */ var _babel_runtime_helpers_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/objectWithoutProperties */ "./node_modules/@babel/runtime/helpers/objectWithoutProperties.js");
/* harmony import */ var _babel_runtime_helpers_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _nerv__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/nerv */ "./src/nerv/index.ts");
/* harmony import */ var hoist_non_react_statics__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! hoist-non-react-statics */ "./node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js");
/* harmony import */ var hoist_non_react_statics__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(hoist_non_react_statics__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _utils_objectKeys__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/utils/objectKeys */ "./src/utils/objectKeys.js");
/* harmony import */ var _App__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../App */ "./src/framework/App/index.js");
/* harmony import */ var _utils_resolvePageUrl__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/resolvePageUrl */ "./src/framework/utils/resolvePageUrl.js");
/* harmony import */ var _common_global__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../common/global */ "./src/framework/common/global.js");
/* harmony import */ var _utils_camelCase__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../utils/camelCase */ "./src/framework/utils/camelCase.js");
/* harmony import */ var _Platform__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../Platform */ "./src/framework/Platform/index.js");
/* harmony import */ var _normalizeStyle__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./normalizeStyle */ "./src/framework/createComponent/normalizeStyle.js");
/* harmony import */ var _normalizeClassNameProps__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./normalizeClassNameProps */ "./src/framework/createComponent/normalizeClassNameProps.js");
/* harmony import */ var _mixins_PureRenderMixin__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../mixins/PureRenderMixin */ "./src/framework/mixins/PureRenderMixin.js");
/* harmony import */ var _mixins_TrackPageUpdateMixin__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../mixins/TrackPageUpdateMixin */ "./src/framework/mixins/TrackPageUpdateMixin.js");
/* harmony import */ var _mixins_BasicEventMixin__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../mixins/BasicEventMixin */ "./src/framework/mixins/BasicEventMixin.js");



function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }















function getNormalizedSrc(source, page) {
  var src;

  if (typeof source === 'string' && source.trim()) {
    if (source.indexOf('http://') === 0 || source.indexOf('https://') === 0 || source.indexOf('file://') === 0 || source.indexOf('data:image') === 0 // base64
    || source.indexOf('myfile://') === 0 // support custom protocol of IDE
    || source.indexOf('local://') === 0 // support custom protocol of IDE
    || source.indexOf('temp://') === 0 // support custom protocol of IDE
    ) {
        src = source;
      } else {
      src = Object(_utils_resolvePageUrl__WEBPACK_IMPORTED_MODULE_6__["default"])(source, page || Object(_App__WEBPACK_IMPORTED_MODULE_5__["getCurrentPageImpl"])());
      var _self = self,
          mpRuntimeConfig = _self.mpRuntimeConfig;

      if (mpRuntimeConfig && mpRuntimeConfig.contextPath) {
        src = "".concat(mpRuntimeConfig.contextPath, "/").concat(src);
      } else {
        src = "/".concat(src);
      }
    }
  }

  return src;
}

function createComponent() {
  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var _config$pure = config.pure,
      pure = _config$pure === void 0 ? true : _config$pure,
      _config$name = config.name,
      tagName = _config$name === void 0 ? '' : _config$name,
      trackPageUpdateForIOS = config.trackPageUpdateForIOS;
  return function create(WrappedComponent) {
    var mixins = pure ? [_mixins_PureRenderMixin__WEBPACK_IMPORTED_MODULE_12__["default"]] : [];

    if (_Platform__WEBPACK_IMPORTED_MODULE_9__["default"].browser === 'ios') {
      mixins.push(_mixins_TrackPageUpdateMixin__WEBPACK_IMPORTED_MODULE_13__["default"]);
    }

    mixins.push(_mixins_BasicEventMixin__WEBPACK_IMPORTED_MODULE_14__["default"]);
    var Container = Object(_nerv__WEBPACK_IMPORTED_MODULE_2__["createNervClass"])({
      displayName: "MP(".concat(tagName, ")"),
      mixins: mixins,
      getInitialState: function getInitialState() {
        this.$mp = _objectSpread(_objectSpread({}, this.$mp), {}, {
          bridge: _common_global__WEBPACK_IMPORTED_MODULE_7__["default"].bridge,
          // getTargetForEvent: this.getTargetForEvent,
          getDataset: this.getDataset,
          getNormalizedEvent: this.getNormalizedEvent,
          getNormalizedStyle: this.getNormalizedStyle,
          getAriaProps: this.getAriaProps,
          getDataProps: this.getDataProps,
          getNormalizedSrc: getNormalizedSrc,
          tagName: tagName,
          page: this.context.$page
        });
        return {
          $style: Object(_normalizeStyle__WEBPACK_IMPORTED_MODULE_10__["default"])(this)
        };
      },
      componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
        if (this.props.style !== nextProps.style // native need recomputed
        || !_Platform__WEBPACK_IMPORTED_MODULE_9__["default"].browser && this.props.className !== nextProps.className) {
          this.setState({
            $style: Object(_normalizeStyle__WEBPACK_IMPORTED_MODULE_10__["default"])(this, nextProps)
          });
        }
      },
      isTrackPageUpdateForIOS: function isTrackPageUpdateForIOS() {
        var wrappedComponent = this.wrappedComponent;
        return trackPageUpdateForIOS || wrappedComponent && wrappedComponent.isTrackPageUpdateForIOS && wrappedComponent.isTrackPageUpdateForIOS();
      },
      getNormalizedStyle: function getNormalizedStyle(props) {
        if (props) {
          var goProps = props;

          if (typeof props === 'string') {
            goProps = {
              style: props
            };
          }

          return Object(_normalizeStyle__WEBPACK_IMPORTED_MODULE_10__["default"])(this, goProps);
        }
      },
      getAriaProps: function getAriaProps() {
        var props = this.props;
        return Object(_utils_objectKeys__WEBPACK_IMPORTED_MODULE_4__["default"])(props).reduce(function (prev, key) {
          if (key === 'role' || key.match(/^aria[A-Z\-]/)) {
            prev[key] = props[key];
          }

          return prev;
        }, {});
      },
      getDataProps: function getDataProps() {
        var props = this.props;
        return Object(_utils_objectKeys__WEBPACK_IMPORTED_MODULE_4__["default"])(props).reduce(function (prev, key) {
          if (key.slice(0, 5) === 'data-') {
            prev[key] = props[key];
          }

          return prev;
        }, {});
      },
      getDataset: function getDataset() {
        var props = this.props;
        var dataset = {};
        Object(_utils_objectKeys__WEBPACK_IMPORTED_MODULE_4__["default"])(props).forEach(function (n) {
          if (n.slice(0, 5) === 'data-') {
            var key = Object(_utils_camelCase__WEBPACK_IMPORTED_MODULE_8__["default"])(n.slice(5));
            dataset[key] = props[n];
          }
        });
        return dataset;
      },
      // getTargetForEvent() {
      //   const { props } = this;
      //   return {
      //     id: props.id,
      //     tagName,
      //     dataset: this.getDataset(),
      //   };
      // },
      // /* 格式化event对象 */
      // getNormalizedEvent(eventParam, other) {
      //   let eventType = eventParam;
      //   let srcEvent;
      //   if (eventType.eventType) {
      //     srcEvent = eventType.srcEvent;
      //     eventType = eventType.eventType;
      //   }
      //   const nativeEvent = srcEvent && srcEvent.nativeEvent || srcEvent;
      //   const currentTarget = this.getTargetForEvent();
      //   let target = nativeEvent && nativeEvent.$target || currentTarget;
      //   if (nativeEvent && !nativeEvent.$target) {
      //     nativeEvent.$target = target;
      //   }
      //   // bug compatibility
      //   target = {
      //     targetDataset: target.dataset,
      //     ...target,
      //     dataset: currentTarget.dataset,
      //   };
      //   return {
      //     type: eventType,
      //     timeStamp: Date.now(),
      //     target,
      //     currentTarget,
      //     ...other,
      //   };
      // },
      saveRef: function saveRef(c) {
        this.wrappedComponent = c;
      },
      getWrappedComponent: function getWrappedComponent() {
        return this.wrappedComponent;
      },
      $getNormalizedProps: function $getNormalizedProps() {
        var _this$props = this.props,
            slot = _this$props.slot,
            props = _babel_runtime_helpers_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_0___default()(_this$props, ["slot"]);

        props.$mp = this.$mp;
        Object(_normalizeClassNameProps__WEBPACK_IMPORTED_MODULE_11__["default"])(props);
        delete props.style;

        if (this.state.$style) {
          props.style = this.state.$style;
        } else {
          props.style = undefined;
        }

        var $numProps = this.constructor.$numProps;

        if ($numProps) {
          $numProps.forEach(function (prop) {
            if (typeof props[prop] === 'string') {
              props[prop] = parseFloat(props[prop]);
            }
          });
        }

        return props;
      },
      render: function render() {
        var props = this.$getNormalizedProps();

        if (WrappedComponent.prototype.render) {
          props.ref = this.saveRef;
        }

        return _nerv__WEBPACK_IMPORTED_MODULE_2__["default"].createElement(WrappedComponent, props);
      }
    });
    var RetComponent = hoist_non_react_statics__WEBPACK_IMPORTED_MODULE_3___default()(Container, WrappedComponent);
    var $numProps = [];
    var defaultProps = WrappedComponent.defaultProps;

    if (defaultProps) {
      Object(_utils_objectKeys__WEBPACK_IMPORTED_MODULE_4__["default"])(defaultProps).forEach(function (prop) {
        if (typeof defaultProps[prop] === 'number') {
          $numProps.push(prop);
        }
      });

      if ($numProps.length) {
        RetComponent.$numProps = $numProps;
      }
    }

    return RetComponent;
  };
}

/***/ }),

/***/ "./src/framework/createComponent/normalizeClassNameProps.js":
/*!******************************************************************!*\
  !*** ./src/framework/createComponent/normalizeClassNameProps.js ***!
  \******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return normalizeClassNameProps; });
function normalizeClassNameProps(props) {
  var _props$className = props.className,
      className = _props$className === void 0 ? '' : _props$className;
  var tagName = props.$mp.tagName;

  if (tagName && className.indexOf(" a-".concat(tagName)) === -1) {
    props.className = " a-".concat(tagName, " ").concat(className);
  }
}

/***/ }),

/***/ "./src/framework/createComponent/normalizeClassNameStyle.js":
/*!******************************************************************!*\
  !*** ./src/framework/createComponent/normalizeClassNameStyle.js ***!
  \******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return normalizeClassNameStyle; });
function normalizeClassNameStyle(totalStyle) {
  return totalStyle;
}

/***/ }),

/***/ "./src/framework/createComponent/normalizeStyle.js":
/*!*********************************************************!*\
  !*** ./src/framework/createComponent/normalizeStyle.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return normalizeStyle; });
/* harmony import */ var _Platform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Platform */ "./src/framework/Platform/index.js");
/* harmony import */ var _utils_transformStyle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/transformStyle */ "./src/framework/utils/transformStyle.js");
/* harmony import */ var _normalizeClassNameStyle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./normalizeClassNameStyle */ "./src/framework/createComponent/normalizeClassNameStyle.js");




function parseStyle(style) {
  var styles = {};

  if (style) {
    style.split(';').filter(function (s) {
      return !!s.trim();
    }).forEach(function (rule) {
      var nameIndex = rule.indexOf(':');
      var name;
      var value;

      if (nameIndex !== -1) {
        name = rule.slice(0, nameIndex).trim();
        value = rule.slice(nameIndex + 1).trim();
        styles[name] = value;
      }
    });
  }

  return styles;
}

function normalizeStyle(component, cProps) {
  var totalStyle = [];
  var tagName = component.$mp.tagName;

  var _ref = cProps || component.props,
      style = _ref.style,
      className = _ref.className,
      id = _ref.id;

  totalStyle = Object(_normalizeClassNameStyle__WEBPACK_IMPORTED_MODULE_2__["default"])(totalStyle, component, tagName, className, id); // inline

  if (style) {
    var styleObj = style;

    if (typeof styleObj === 'string') {
      styleObj = parseStyle(styleObj.trim());
    }

    totalStyle.push(Object(_utils_transformStyle__WEBPACK_IMPORTED_MODULE_1__["default"])(styleObj));
  }

  if (_Platform__WEBPACK_IMPORTED_MODULE_0__["default"].OS === 'web') {
    if (totalStyle.length) {
      totalStyle = Object.assign.apply(undefined, [{}].concat(totalStyle));
    } else {
      totalStyle = undefined;
    }
  } else if (!totalStyle.length) {
    totalStyle = undefined;
  }

  return totalStyle;
}

/***/ }),

/***/ "./src/framework/index.js":
/*!********************************!*\
  !*** ./src/framework/index.js ***!
  \********************************/
/*! exports provided: EventHub, App, setCurrentPageImpl, getCurrentPageImpl, getCurrentPagesImpl, getApp, getAppImpl, getCurrentPages, getStartupParams, setStartupParams, Component, getComponentClass, StyleSheet, createComponent, Page, $global */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utils_env__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/env */ "./src/framework/utils/env.js");
/* harmony import */ var _utils_env__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_utils_env__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _utils_log__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/utils/log */ "./src/utils/log.js");
/* harmony import */ var _web_bootstrap__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./web/bootstrap */ "./src/framework/web/bootstrap.js");
/* harmony import */ var _common_commonUI__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./common/commonUI */ "./src/framework/common/commonUI.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getComponentClass", function() { return _common_commonUI__WEBPACK_IMPORTED_MODULE_3__["getComponentClass"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "StyleSheet", function() { return _common_commonUI__WEBPACK_IMPORTED_MODULE_3__["StyleSheet"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createComponent", function() { return _common_commonUI__WEBPACK_IMPORTED_MODULE_3__["createComponent"]; });

/* harmony import */ var _common_commonLogic__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./common/commonLogic */ "./src/framework/common/commonLogic.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "App", function() { return _common_commonLogic__WEBPACK_IMPORTED_MODULE_4__["App"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getApp", function() { return _common_commonLogic__WEBPACK_IMPORTED_MODULE_4__["getApp"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getCurrentPages", function() { return _common_commonLogic__WEBPACK_IMPORTED_MODULE_4__["getCurrentPages"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Component", function() { return _common_commonLogic__WEBPACK_IMPORTED_MODULE_4__["Component"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Page", function() { return _common_commonLogic__WEBPACK_IMPORTED_MODULE_4__["Page"]; });

/* harmony import */ var _common_global__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./common/global */ "./src/framework/common/global.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "$global", function() { return _common_global__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony import */ var _startupParams__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./startupParams */ "./src/framework/startupParams/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getStartupParams", function() { return _startupParams__WEBPACK_IMPORTED_MODULE_6__["getStartupParams"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "setStartupParams", function() { return _startupParams__WEBPACK_IMPORTED_MODULE_6__["setStartupParams"]; });

/* harmony import */ var _EventHub__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./EventHub */ "./src/framework/EventHub.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EventHub", function() { return _EventHub__WEBPACK_IMPORTED_MODULE_7__["default"]; });

/* harmony import */ var _App__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./App */ "./src/framework/App/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "setCurrentPageImpl", function() { return _App__WEBPACK_IMPORTED_MODULE_8__["setCurrentPageImpl"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getCurrentPageImpl", function() { return _App__WEBPACK_IMPORTED_MODULE_8__["getCurrentPageImpl"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getCurrentPagesImpl", function() { return _App__WEBPACK_IMPORTED_MODULE_8__["getCurrentPagesImpl"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getAppImpl", function() { return _App__WEBPACK_IMPORTED_MODULE_8__["getAppImpl"]; });










var g = self;

function ready(callback) {
  callback();
}

g.onerror = function onerror() {
  var msg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  var url = arguments.length > 1 ? arguments[1] : undefined;
  var line = arguments.length > 2 ? arguments[2] : undefined;
  var col = arguments.length > 3 ? arguments[3] : undefined;
  var error = arguments.length > 4 ? arguments[4] : undefined;
  var stack = [];

  try {
    stack = JSON.stringify(error.stack).split('\\n').splice(0, 3);
  } catch (e) {}

  var args = [msg, url, line, col, error];
  console.error('[RENDER] onerror', args);
};

g.bootstrapApp = function bootstrapApp() {
  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var container = config.container,
      _config$onReady = config.onReady,
      onReady = _config$onReady === void 0 ? ready : _config$onReady,
      onRender = config.onRender,
      onFail = config.onFail;
  onReady(function (runInfo) {
    var _ref = runInfo || {},
        bridge = _ref.bridge;

    var startupParams = bridge.startupParams;
    Object(_startupParams__WEBPACK_IMPORTED_MODULE_6__["setStartupParams"])(startupParams);

    if (location.hash.length > 1) {
      Object(_utils_log__WEBPACK_IMPORTED_MODULE_1__["debug"])('framework', '[RENDER] bootstrap page');
      Object(_web_bootstrap__WEBPACK_IMPORTED_MODULE_2__["default"])({
        container: container,
        onRender: onRender,
        onFail: onFail,
        type: 'initial hash'
      }, bridge);
    } else {
      window.addEventListener('hashchange', function () {
        Object(_utils_log__WEBPACK_IMPORTED_MODULE_1__["debug"])('framework', '[RENDER] bootstrap page when hashchange');
        Object(_web_bootstrap__WEBPACK_IMPORTED_MODULE_2__["default"])({
          container: container,
          onRender: onRender,
          onFail: onFail,
          type: 'hashchange'
        }, bridge);
      }, false);
    }
  });
};



/***/ }),

/***/ "./src/framework/legacy/CustomComponent.js":
/*!*************************************************!*\
  !*** ./src/framework/legacy/CustomComponent.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/extends */ "./node_modules/@babel/runtime/helpers/extends.js");
/* harmony import */ var _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/objectWithoutProperties */ "./node_modules/@babel/runtime/helpers/objectWithoutProperties.js");
/* harmony import */ var _babel_runtime_helpers_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _nerv__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/nerv */ "./src/nerv/index.ts");
/* harmony import */ var _utils_setData__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/utils/setData */ "./src/utils/setData.js");
/* harmony import */ var _utils_objectKeys__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/utils/objectKeys */ "./src/utils/objectKeys.js");
/* harmony import */ var _utils_consts__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/utils/consts */ "./src/utils/consts.js");
/* harmony import */ var _utils_log__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @/utils/log */ "./src/utils/log.js");
/* harmony import */ var _common_global__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../common/global */ "./src/framework/common/global.js");
/* harmony import */ var _EventHub__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../EventHub */ "./src/framework/EventHub.js");
/* harmony import */ var _mixins_PureRenderMixin__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../mixins/PureRenderMixin */ "./src/framework/mixins/PureRenderMixin.js");
/* harmony import */ var _mixins_BasicEventMixin__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../mixins/BasicEventMixin */ "./src/framework/mixins/BasicEventMixin.js");
/* harmony import */ var _utils_transformChildrenToSlots__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../utils/transformChildrenToSlots */ "./src/framework/utils/transformChildrenToSlots.js");
/* harmony import */ var _utils_normalizeComponentProps__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../utils/normalizeComponentProps */ "./src/framework/utils/normalizeComponentProps.js");
/* harmony import */ var _utils_types__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../utils/types */ "./src/utils/types.js");




function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2___default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }













var componentId = 1;
var mountedComponents;
var unmountedComponents;

function reset() {
  mountedComponents = [];
  unmountedComponents = [];
}

reset();
_EventHub__WEBPACK_IMPORTED_MODULE_9__["default"].addListener(['pageLoad', 'pageReady', 'pageUpdate'], function (e) {
  var _objectSpread2;

  e.payload = _objectSpread(_objectSpread({}, e.payload || {}), (_objectSpread2 = {}, _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2___default()(_objectSpread2, _utils_consts__WEBPACK_IMPORTED_MODULE_6__["PayloadKeyMountedComponents"], mountedComponents), _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2___default()(_objectSpread2, _utils_consts__WEBPACK_IMPORTED_MODULE_6__["PayloadKeyUnmountedComponents"], unmountedComponents), _objectSpread2));
  reset();
});
var renderCache = {};

function getRender(is) {
  if (is in renderCache) {
    return renderCache[is];
  }

  var setupConfig = _common_global__WEBPACK_IMPORTED_MODULE_8__["default"].componentsConfig[is].system;
  var _render = setupConfig.render;

  var render = _render();

  render = render["default"] || render;
  renderCache[is] = render;
  return render;
}

/* harmony default export */ __webpack_exports__["default"] = (function (is) {
  return Object(_nerv__WEBPACK_IMPORTED_MODULE_3__["createNervClass"])({
    $isCustomComponent: true,
    displayName: is,
    mixins: [_mixins_PureRenderMixin__WEBPACK_IMPORTED_MODULE_10__["default"]],
    statics: {
      is: is,
      getDerivedStateFromProps: function getDerivedStateFromProps(nextProps, state) {
        var __page = nextProps.__page;
        var properties = __page.customComponents[is].properties;
        var changedProps = {};

        for (var key in nextProps) {
          if (nextProps.hasOwnProperty(key)) {
            var nextProp = nextProps[key];

            if (properties.hasOwnProperty(key) && Object(_utils_types__WEBPACK_IMPORTED_MODULE_14__["getType"])(nextProp) === properties[key].type) {
              changedProps[key] = nextProp;
            }
          }
        }

        return _objectSpread(_objectSpread({}, state), changedProps);
      }
    },
    getInitialState: function getInitialState() {
      var _this$props = this.props,
          __page = _this$props.__page,
          id = _this$props.id;
      this.is = is;
      this.id = this.id || ++componentId;
      var _page$customComponen = __page.customComponents[is],
          properties = _page$customComponen.properties,
          data = _page$customComponen.data;
      this.properties = properties;
      this.eventHandlers = {};
      this.prevProps = {};
      __page.componentInstances[this.id] = this;

      __page.callRemote('self', 'fireComponentLifecycle', this.recordMounted(false), 'created');

      return _objectSpread({}, data);
    },
    componentDidMount: function componentDidMount() {
      var __page = this.props.__page;
      var info = this.recordMounted(this.diffProps(this.prevProps));

      __page.callRemote('self', 'fireComponentLifecycle', info, 'attached');

      this.prevProps = this.props;
    },
    onAttachedReady: function onAttachedReady() {
      var __page = this.props.__page;
      var info = this.recordMounted(this.diffProps(this.prevProps));

      __page.callRemote('self', 'fireComponentLifecycle', info, 'ready');
    },
    componentDidUpdate: function componentDidUpdate(prevProps) {
      var diffProps = this.diffProps(prevProps);

      if (diffProps) {
        this.recordMounted(diffProps);
      }
    },
    componentWillUnmount: function componentWillUnmount() {
      var __page = this.props.__page;
      delete __page.componentInstances[this.id];
      unmountedComponents.push(this.id);

      __page.callRemote('self', 'fireComponentLifecycle', this.recordMounted(false), 'unload');
    },
    setData: function setData(toBeData, callback) {
      var data = this.state;
      var ret = data;

      if (Array.isArray(toBeData)) {
        toBeData.forEach(function (d) {
          // immutable for shouldComponentUpdate
          ret = Object(_utils_setData__WEBPACK_IMPORTED_MODULE_4__["getOpFn"])(d.op)(ret, d.data);
        });
      } else {
        ret = Object(_utils_setData__WEBPACK_IMPORTED_MODULE_4__["getOpFn"])(toBeData.op)(ret, toBeData.data);
      }

      this.setState(_objectSpread({}, ret), callback);
    },
    recordMounted: function recordMounted(diffProps) {
      var _info;

      var id = this.props.id;
      var info = (_info = {}, _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2___default()(_info, _utils_consts__WEBPACK_IMPORTED_MODULE_6__["ComponentKeyId"], this.id), _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2___default()(_info, _utils_consts__WEBPACK_IMPORTED_MODULE_6__["ComponentKeyIs"], this.is), _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2___default()(_info, _utils_consts__WEBPACK_IMPORTED_MODULE_6__["ComponentPropsId"], id), _info);
      mountedComponents.push(info);

      if (diffProps) {
        var _this$normalizeProps = this.normalizeProps(diffProps),
            newProps = _this$normalizeProps.newProps;

        info[_utils_consts__WEBPACK_IMPORTED_MODULE_6__["ComponentKeyDiffProps"]] = newProps;
      }

      return info;
    },
    diffProps: function diffProps(prevProps) {
      var _this$properties = this.properties,
          properties = _this$properties === void 0 ? {} : _this$properties;
      var props = this.props; // 当前props

      var deleted = [];
      var updated = {};
      var isUpdated;
      var isDeleted;
      Object(_utils_objectKeys__WEBPACK_IMPORTED_MODULE_5__["default"])(Object(_utils_normalizeComponentProps__WEBPACK_IMPORTED_MODULE_13__["default"])(prevProps)).forEach(function (prevKey) {
        var prevProp = prevProps[prevKey];

        if (properties.hasOwnProperty(prevKey) && Object(_utils_types__WEBPACK_IMPORTED_MODULE_14__["getType"])(prevProp) === properties[prevKey].type) {
          if (!(prevKey in props)) {
            deleted.push(prevKey);
            isDeleted = true;
          } else if (prevProp !== props[prevKey]) {
            updated[prevKey] = props[prevKey];
            isUpdated = true;
          }
        }
      });
      Object(_utils_objectKeys__WEBPACK_IMPORTED_MODULE_5__["default"])(Object(_utils_normalizeComponentProps__WEBPACK_IMPORTED_MODULE_13__["default"])(props)).forEach(function (key) {
        var prop = props[key];

        if (properties.hasOwnProperty(key) && Object(_utils_types__WEBPACK_IMPORTED_MODULE_14__["getType"])(prop) === properties[key].type) {
          if (!(key in prevProps)) {
            updated[key] = prop;
            isUpdated = true;
          }
        }
      });
      var ret;

      if (isUpdated) {
        ret = ret || {};
        ret[_utils_consts__WEBPACK_IMPORTED_MODULE_6__["DiffKeyUpdated"]] = updated;
      }

      if (isDeleted) {
        ret = ret || {};
        ret[_utils_consts__WEBPACK_IMPORTED_MODULE_6__["DiffKeyDeleted"]] = deleted;
      }

      return ret;
    },
    normalizeProps: function normalizeProps(props) {
      var newProps = {};

      if (props[_utils_consts__WEBPACK_IMPORTED_MODULE_6__["DiffKeyDeleted"]]) {
        newProps[_utils_consts__WEBPACK_IMPORTED_MODULE_6__["DiffKeyDeleted"]] = props[_utils_consts__WEBPACK_IMPORTED_MODULE_6__["DiffKeyDeleted"]];
      }

      if (props[_utils_consts__WEBPACK_IMPORTED_MODULE_6__["DiffKeyUpdated"]]) {
        newProps[_utils_consts__WEBPACK_IMPORTED_MODULE_6__["DiffKeyUpdated"]] = _objectSpread({}, props[_utils_consts__WEBPACK_IMPORTED_MODULE_6__["DiffKeyUpdated"]]);
      }

      return {
        newProps: newProps
      };
    },
    $getEventHandler: function $getEventHandler(name) {
      var _this = this;

      if (!name || typeof name !== 'string') {
        return name;
      }

      var eventHandlers = this.eventHandlers;
      var __page = this.props.__page;

      if (!eventHandlers[name]) {
        var handle = function handle() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          __page.callRemote.apply(__page, ['self', 'triggerComponentEvent', _this.id, name].concat(args));
        };

        handle.handleName = name;
        handle.type = 'component';
        handle.id = this.id;
        eventHandlers[name] = handle;
      }

      return eventHandlers[name];
    },
    $getRefHandler: function $getRefHandler() {
      var _page$$getRefHandler;

      var __page = this.props.__page;

      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      return (_page$$getRefHandler = __page.$getRefHandler).call.apply(_page$$getRefHandler, [__page].concat(args));
    },
    triggerEvent: function triggerEvent(eventName, detail, options) {
      var event = new CustomEvent(eventName, _objectSpread({
        detail: detail
      }, options));
      this.root.dispatchEvent(event);
    },
    render: function render() {
      var _this2 = this;

      var _this$props2 = this.props,
          children = _this$props2.children,
          $scopedSlots = _this$props2.$scopedSlots;
      var props = Object(_utils_normalizeComponentProps__WEBPACK_IMPORTED_MODULE_13__["default"])(this.props);
      var $slots = Object(_utils_transformChildrenToSlots__WEBPACK_IMPORTED_MODULE_12__["default"])(children);

      var id = props.id,
          className = props.className,
          rest = _babel_runtime_helpers_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_1___default()(props, ["id", "className"]);

      return _nerv__WEBPACK_IMPORTED_MODULE_3__["default"].createElement("span", _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0___default()({
        ref: function ref(_ref) {
          return _this2.root = _ref;
        },
        id: id,
        className: className
      }, rest), getRender(is).call(this, _objectSpread(_objectSpread({
        $id: this.id,
        $scopedSlots: $scopedSlots,
        $slots: $slots
      }, rest), this.state)));
    }
  });
});

/***/ }),

/***/ "./src/framework/legacy/PageComponent.js":
/*!***********************************************!*\
  !*** ./src/framework/legacy/PageComponent.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _babel_runtime_helpers_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/objectWithoutProperties */ "./node_modules/@babel/runtime/helpers/objectWithoutProperties.js");
/* harmony import */ var _babel_runtime_helpers_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _nerv__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/nerv */ "./src/nerv/index.ts");
/* harmony import */ var _utils_addEvents__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/utils/addEvents */ "./src/utils/addEvents.js");
/* harmony import */ var _utils_consts__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/utils/consts */ "./src/utils/consts.js");
/* harmony import */ var _utils_objectKeys__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/utils/objectKeys */ "./src/utils/objectKeys.js");
/* harmony import */ var _utils_setData__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/utils/setData */ "./src/utils/setData.js");
/* harmony import */ var _utils_log__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @/utils/log */ "./src/utils/log.js");
/* harmony import */ var _mixins_BasicEventMixin__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../mixins/BasicEventMixin */ "./src/framework/mixins/BasicEventMixin.js");
/* harmony import */ var _mixins_MessageHandleMixin__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../mixins/MessageHandleMixin */ "./src/framework/mixins/MessageHandleMixin.js");
/* harmony import */ var _mixins_RefMixin__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../mixins/RefMixin */ "./src/framework/mixins/RefMixin.js");
/* harmony import */ var _App__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../App */ "./src/framework/App/index.js");
/* harmony import */ var _EventHub__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../EventHub */ "./src/framework/EventHub.js");
/* harmony import */ var _common_global__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../common/global */ "./src/framework/common/global.js");
/* harmony import */ var _utils_unit__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../utils/unit */ "./src/framework/utils/unit.js");
/* harmony import */ var _Platform__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../Platform */ "./src/framework/Platform/index.js");
/* harmony import */ var _Scene__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./Scene */ "./src/framework/legacy/Scene.js");



function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
















var styleSheetCaches = {};

function getStyleSheet(pagePath) {
  if (pagePath in styleSheetCaches) {
    return styleSheetCaches[pagePath];
  }

  var setupConfig = _common_global__WEBPACK_IMPORTED_MODULE_13__["default"].pagesConfig[pagePath].system;
  var _stylesheet = setupConfig.stylesheet;

  if (_stylesheet) {
    _stylesheet = _stylesheet();
  }

  var stylesheet = _stylesheet && (_stylesheet["default"] || _stylesheet);
  styleSheetCaches[pagePath] = stylesheet;
  return stylesheet;
}

var renderCache = {};

function getRender(pagePath) {
  if (pagePath in renderCache) {
    return renderCache[pagePath];
  }

  var setupConfig = _common_global__WEBPACK_IMPORTED_MODULE_13__["default"].pagesConfig[pagePath].system;
  var _render = setupConfig.render; // lazy require xml and css

  var render = _render();

  render = render["default"] || render;
  renderCache[pagePath] = render;
  return render;
}

/* harmony default export */ __webpack_exports__["default"] = (Object(_nerv__WEBPACK_IMPORTED_MODULE_2__["createNervClass"])({
  $isCustomComponent: false,
  displayName: 'PageComponent',
  mixins: [_mixins_MessageHandleMixin__WEBPACK_IMPORTED_MODULE_9__["default"], _mixins_RefMixin__WEBPACK_IMPORTED_MODULE_10__["default"]],
  getInitialState: function getInitialState() {
    var pagePath = this.props.pagePath;
    this.pagePath = pagePath;
    this.pageType = 'RENDER';
    this.eventHandlers = {};
    this.componentInstances = {};
    this.self = this;
    this.publicInstance = {};
    return {
      __InitialDataReady__: false
    };
  },
  componentDidMount: function componentDidMount() {
    this.insertStyle();
    Object.assign(this, {
      bridge: _common_global__WEBPACK_IMPORTED_MODULE_13__["default"].bridge,
      renderSeq: 1
    });
    Object(_App__WEBPACK_IMPORTED_MODULE_11__["setCurrentPageImpl"])(this);
    this.initMessageChannel();
  },
  UNSAFE_componentWillUpdate: function UNSAFE_componentWillUpdate() {
    this.renderSeq += 1;
  },
  insertStyle: function insertStyle() {
    var headNode = document.getElementsByTagName('head')[0]; // special for 1rpx or 2rpx

    var remReg = Object(_utils_unit__WEBPACK_IMPORTED_MODULE_14__["rpx2px"])(2) < 1 ? /\b0\.0[12]rem/g : Object(_utils_unit__WEBPACK_IMPORTED_MODULE_14__["rpx2px"])(1) < 1 ? /\b0\.01rem/g : null;
    var replacer = _Platform__WEBPACK_IMPORTED_MODULE_15__["default"].browser === 'ios' ? '0.5px' : '1px';
    var stylesheet = getStyleSheet(this.pagePath);

    if (stylesheet) {
      var styleNode = document.createElement('style');
      var styleString = stylesheet.toString();

      if (remReg) {
        styleString = styleString.replace(remReg, replacer);
      }

      styleNode.innerHTML = styleString;
      headNode.appendChild(styleNode);
    }
  },
  onInitDataReady: function onInitDataReady(data) {
    Object(_utils_log__WEBPACK_IMPORTED_MODULE_7__["debug"])('framework', "[RENDER] Page ".concat(this.pagePath, " onInitDataReady: "), data);

    var _this = this;

    var id = data.id,
        publicInstance = data.publicInstance,
        customComponents = data.customComponents,
        isRefresh = data.isRefresh;
    this.publicInstance = publicInstance;
    this.setId(id);
    this.customComponents = customComponents;
    var now = Date.now();
    this.setState(_objectSpread(_objectSpread({}, publicInstance.data || {}), {}, {
      __InitialDataReady__: true
    }), function () {
      _this.logRenderTime(now);

      if (publicInstance.onReachBottom || publicInstance.onPageScroll) {
        Object(_utils_addEvents__WEBPACK_IMPORTED_MODULE_3__["default"])(window, {
          scroll: _this.checkScroll
        });
      }
    });
  },

  /* load完成 准备ready */
  onLoaded: function onLoaded() {
    var _this2 = this;

    setTimeout(function () {
      Object(_utils_log__WEBPACK_IMPORTED_MODULE_7__["debug"])('framework', "[RENDER] Page ".concat(_this2.pagePath, " onLoaded"));
      _EventHub__WEBPACK_IMPORTED_MODULE_12__["default"].emit('pageLoaded');
      var e = {
        page: _this2
      };
      _EventHub__WEBPACK_IMPORTED_MODULE_12__["default"].emit('pageReady', e);

      _this2.callRemote('self', 'ready', e.payload);

      _this2.loaded = true;
    });
  },
  onComponentAttached: function onComponentAttached(componentId) {
    var _this3 = this;

    var fn = function fn() {
      var component = _this3.componentInstances[componentId];

      if (component) {
        component.onAttachedReady();
      }
    };

    if (this.loaded) {
      fn();
    } else {
      _EventHub__WEBPACK_IMPORTED_MODULE_12__["default"].on('pageLoaded', fn);
    }
  },
  checkScroll: function checkScroll() {
    var onReachBottomDistance = 50;
    var _window = window,
        innerHeight = _window.innerHeight,
        pageYOffset = _window.pageYOffset;
    var scrollHeight = document.body.scrollHeight;

    if (this.publicInstance.onPageScroll) {
      this.callRemote('self', 'onPageScroll', {
        scrollTop: pageYOffset,
        scrollHeight: scrollHeight
      });
    }

    if (this.publicInstance.onReachBottom && pageYOffset > 0) {
      var closeBottom = scrollHeight - (innerHeight + pageYOffset) <= onReachBottomDistance;

      if (closeBottom) {
        if (!this.shouldNotFireOnReachBottom) {
          this.shouldNotFireOnReachBottom = true;
          this.callRemote('self', 'onReachBottom');
        }
      } else {
        this.shouldNotFireOnReachBottom = false;
      }
    }
  },
  $getEventHandler: function $getEventHandler(name) {
    var _this = this;

    if (!name || typeof name !== 'string') {
      return name;
    }

    if (!this.eventHandlers[name]) {
      this.eventHandlers[name] = function (e) {
        var _ref;

        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        _this.callRemote.apply(_this, (_ref = ['self', 'onRenderEvent', name]).concat.apply(_ref, [e].concat(args)));
      };

      var handle = this.eventHandlers[name];
      handle.handleName = name;
      handle.type = 'page';
      handle.id = this.id;
    }

    return this.eventHandlers[name];
  },

  /* 接受worker消息触发 */
  triggerComponentCustomEvent: function triggerComponentCustomEvent(componentId, eventName, detail, options) {
    var component = this.componentInstances[componentId];

    if (component) {
      component.triggerEvent(eventName, detail, options);
    }
  },
  receiveData: function receiveData(toBeData, callback) {
    var _this = this;

    if (!toBeData.length) {
      return callback();
    }

    var pageData = [];
    var componentInstances = this.componentInstances;
    var componentsData = {};
    toBeData.forEach(function (toData) {
      var type = toData[_utils_consts__WEBPACK_IMPORTED_MODULE_4__["PendingKeyType"]];
      var data = toData[_utils_consts__WEBPACK_IMPORTED_MODULE_4__["PendingKeyData"]];
      var id = toData[_utils_consts__WEBPACK_IMPORTED_MODULE_4__["PendingKeyId"]];
      var op = toData[_utils_consts__WEBPACK_IMPORTED_MODULE_4__["PendingKeyOp"]] || _utils_consts__WEBPACK_IMPORTED_MODULE_4__["OpSet"];

      if (type === _utils_consts__WEBPACK_IMPORTED_MODULE_4__["PendingValuePage"]) {
        pageData.push({
          data: data,
          op: op
        });
      } else if (type === _utils_consts__WEBPACK_IMPORTED_MODULE_4__["PendingValueComponent"] && componentInstances[id]) {
        componentsData[id] = componentsData[id] || [];
        componentsData[id].push({
          data: data,
          op: op
        });
      }
    });

    var doIt = function doIt() {
      var count = Object(_utils_objectKeys__WEBPACK_IMPORTED_MODULE_5__["default"])(componentsData).length + (pageData.length ? 1 : 0);
      var c = 0;
      var now = Date.now();
      var unmountedChecked = Object(_utils_objectKeys__WEBPACK_IMPORTED_MODULE_5__["default"])(componentsData);
      var allKeys = unmountedChecked.concat();
      var pageComponent = _this;

      function done() {
        if (c < 0) {
          return;
        }

        var doneComponent = this;

        if (doneComponent === pageComponent) {
          ++c;
        }

        for (var l = unmountedChecked.length - 1; l >= 0; l--) {
          var id = unmountedChecked[l];
          var currentComponent = componentInstances[id];

          if (!currentComponent || currentComponent === doneComponent) {
            ++c;
            unmountedChecked.splice(l, 1);
          }
        }

        if (c === count) {
          c = -1;
          pageComponent.onPageUpdate(now, callback);
        }
      }

      allKeys.forEach(function (id) {
        // if unmounted, will not trigger setState callback
        componentInstances[id].setData(componentsData[id], done);
      });

      if (pageData.length) {
        _this.setData(pageData, done);
      }
    };

    doIt();
  },
  onPageUpdate: function onPageUpdate(now, callback) {
    this.logRenderTime(now);
    var e = {
      page: this
    };
    _EventHub__WEBPACK_IMPORTED_MODULE_12__["default"].emit('pageUpdate', e);

    if (e.payload) {
      this.callRemote('self', 'update', e.payload);
    }

    if (callback) {
      callback();
    }
  },
  setData: function setData(toBeData, callback) {
    var ret = this.state;
    toBeData.forEach(function (d) {
      // immutable for shouldComponentUpdate
      ret = Object(_utils_setData__WEBPACK_IMPORTED_MODULE_6__["getOpFn"])(d.op)(ret, d.data);
    });
    this.setState(_objectSpread({}, ret), callback);
  },
  initMessageChannel: function initMessageChannel() {
    var messageChannel = this.props.messageChannel;
    messageChannel.onMessage(this.onMessage);
  },
  postMessage: function postMessage(data) {
    Object(_utils_log__WEBPACK_IMPORTED_MODULE_7__["debug"])('framework', "[RENDER] Page ".concat(this.pagePath, " postMessage"), data);
    var messageChannel = this.props.messageChannel;
    messageChannel.postMessage(_objectSpread(_objectSpread({}, data), {}, {
      pageType: this.pageType,
      msgType: 'endpoint'
    }));
  },
  logRenderTime: function logRenderTime(now) {
    Object(_utils_log__WEBPACK_IMPORTED_MODULE_7__["debug"])('framework', "render ".concat(this.pagePath, " costs ").concat(Date.now() - now, "ms."));
  },
  saveRoot: function saveRoot(ref) {
    this.root = ref;
  },
  render: function render() {
    var _this$state = this.state,
        __InitialDataReady__ = _this$state.__InitialDataReady__,
        data = _babel_runtime_helpers_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_0___default()(_this$state, ["__InitialDataReady__"]);

    if (!__InitialDataReady__) {
      return null;
    }

    return _nerv__WEBPACK_IMPORTED_MODULE_2__["default"].createElement(_Scene__WEBPACK_IMPORTED_MODULE_16__["default"], {
      pagePath: this.pagePath,
      saveRoot: this.saveRoot,
      __page: this,
      __render: getRender(this.pagePath),
      data: data
    });
  }
}));

/***/ }),

/***/ "./src/framework/legacy/Scene.js":
/*!***************************************!*\
  !*** ./src/framework/legacy/Scene.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Scene; });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _nerv__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/nerv */ "./src/nerv/index.ts");
/* harmony import */ var _utils_config__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/utils/config */ "./src/utils/config.js");
/* harmony import */ var _EventHub__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../EventHub */ "./src/framework/EventHub.js");






function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4___default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4___default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3___default()(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }





var Scene = /*#__PURE__*/function (_Nerv$Component) {
  _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2___default()(Scene, _Nerv$Component);

  var _super = _createSuper(Scene);

  function Scene() {
    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default()(this, Scene);

    return _super.apply(this, arguments);
  }

  _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1___default()(Scene, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var __page = this.props.__page;
      var e = {
        page: __page
      };
      _EventHub__WEBPACK_IMPORTED_MODULE_7__["default"].emit('pageLoad', e);

      __page.callRemote('self', 'load');
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props = this.props,
          data = _this$props.data,
          saveRoot = _this$props.saveRoot,
          __page = _this$props.__page,
          __render = _this$props.__render;
      return _nerv__WEBPACK_IMPORTED_MODULE_5__["default"].createElement("".concat(_utils_config__WEBPACK_IMPORTED_MODULE_6__["elementPrefix"], "-page"), {
        ref: saveRoot
      }, __render.call(__page, data));
    }
  }]);

  return Scene;
}(_nerv__WEBPACK_IMPORTED_MODULE_5__["default"].Component);



/***/ }),

/***/ "./src/framework/mixins/BasicEventMixin.js":
/*!*************************************************!*\
  !*** ./src/framework/mixins/BasicEventMixin.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _nerv__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/nerv */ "./src/nerv/index.ts");
/* harmony import */ var _utils_addEvents__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/utils/addEvents */ "./src/utils/addEvents.js");
/* harmony import */ var _utils_objectKeys__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/utils/objectKeys */ "./src/utils/objectKeys.js");
/* harmony import */ var _utils_eventReg__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/utils/eventReg */ "./src/utils/eventReg.js");


function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }






function defaultCreateTouchList() {
  var touchList = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var list = [].slice.call(touchList, 0);
  return list.map(function (item) {
    return {
      clientX: item.clientX,
      clientY: item.clientY,
      identifier: item.identifier,
      pageX: item.pageX,
      pageY: item.pageY
    };
  });
}

function callBubblesEvent(instance, eventType, srcEvent, more, capture) {
  var catchHandler = instance.props[Object(_utils_eventReg__WEBPACK_IMPORTED_MODULE_4__["getPropsEventName"])(eventType, true, capture)];
  var e = instance.getNormalizedEvent({
    eventType: eventType,
    srcEvent: srcEvent
  }, more);
  e.currentTarget = _objectSpread(_objectSpread({}, e.currentTarget), instance.getTargetForEvent());

  if (catchHandler && srcEvent.stopPropagation) {
    srcEvent.stopPropagation();
    typeof catchHandler === 'function' && catchHandler(e);
    return;
  }

  var onHandler = instance.props[Object(_utils_eventReg__WEBPACK_IMPORTED_MODULE_4__["getPropsEventName"])(eventType, false, capture)];

  if (typeof onHandler === 'function') {
    onHandler(e);
  }
}

function defaultCreateTap(nativeEvent) {
  var detail = {};

  if (nativeEvent) {
    nativeEvent = nativeEvent.nativeEvent || nativeEvent;

    if ('pageX' in nativeEvent) {
      detail.pageX = nativeEvent.pageX;
      detail.pageY = nativeEvent.pageY;
    }

    if ('clientX' in nativeEvent) {
      detail.clientX = nativeEvent.clientX;
      detail.clientY = nativeEvent.clientY;
    } else if ('pageX' in detail) {
      detail.clientX = detail.pageX - window.pageXOffset;
      detail.clientY = detail.pageY - window.pageYOffset;
    }
  }

  return {
    detail: detail
  };
}

function detachScroll(instance) {
  if (instance.detachScrollEvent) {
    instance.detachScrollEvent.remove();
    instance.detachScrollEvent = null;
  }
}

function attachScroll(instance) {
  var disableScroll = instance.props.disableScroll;
  var detachScrollEvent = instance.detachScrollEvent;
  var __basicEventRoot = instance.__basicEventRoot;

  if (!__basicEventRoot) {
    return;
  }

  if (!disableScroll && detachScrollEvent) {
    return detachScroll(instance);
  }

  if (disableScroll && !detachScrollEvent) {
    instance.detachScrollEvent = Object(_utils_addEvents__WEBPACK_IMPORTED_MODULE_2__["default"])(instance.__basicEventRoot, {
      touchmove: function touchmove(e) {
        e.preventDefault();
      }
    });
  }
}

/* harmony default export */ __webpack_exports__["default"] = ({
  // componentDidMount() {
  //   this.__basicEventRoot = findDOMNode(this);
  //   attachScroll(this);
  // },
  // componentDidUpdate() {
  //   attachScroll(this);
  // },
  // componentWillUnmount() {
  //   detachScroll(this);
  // },
  // recordTarget(srcEvent) {
  //   const nativeEvent = srcEvent && srcEvent.nativeEvent;
  //   if (nativeEvent && !nativeEvent.$target) {
  //     nativeEvent.$target = this.getTargetForEvent();
  //   }
  // },
  // hasEvent(event, capture) {
  //   return getPropsEventName(event, false, capture) || getPropsEventName(event, true, capture);
  // },
  getDatasetForTarget: function getDatasetForTarget(target) {
    var dataset = {};

    for (var key in target.dataset) {
      if (Object.hasOwnProperty.call(target.dataset, key)) {
        var value = target.dataset[key];
        dataset[key] = value;
      }
    }

    return dataset;
  },
  getTargetForEvent: function getTargetForEvent(nativeEvent) {
    var key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'target';
    var props = this.props;
    var _nativeEvent$key = nativeEvent[key],
        offsetLeft = _nativeEvent$key.offsetLeft,
        offsetTop = _nativeEvent$key.offsetTop;
    return {
      id: props.id || '',
      dataset: this.getDatasetForTarget(nativeEvent[key]),
      offsetLeft: offsetLeft,
      offsetTop: offsetTop
    };
  },
  getDetailForEvent: function getDetailForEvent(nativeEvent) {
    var eventType = nativeEvent.type;
    var detail = {};

    if (eventType === 'click') {
      detail.x = nativeEvent.pageX;
      detail.y = nativeEvent.pageY;
    } else if (eventType === 'transitionend') {
      detail.elapsedTime = nativeEvent.elapsedTime;
      detail.propertyName = nativeEvent.propertyName;
    } else if (eventType === 'animationstart' || eventType === 'animationiteration' || eventType === 'animationend') {
      detail.elapsedTime = nativeEvent.elapsedTime;
      detail.animationName = nativeEvent.animationName;
    }

    return detail;
  },
  getTouchesForEvent: function getTouchesForEvent(nativeEvent) {
    var key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'touches';

    if (nativeEvent[key]) {
      var list = [].slice.call(nativeEvent[key], 0);
      return list.map(function (item) {
        return {
          clientX: item.clientX,
          clientY: item.clientY,
          identifier: item.identifier,
          force: item.force,
          pageX: item.pageX,
          pageY: item.pageY
        };
      });
    }
  },

  /* 格式化event对象 */
  getNormalizedEvent: function getNormalizedEvent(nativeEvent) {
    var more = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var eventType = nativeEvent.type === 'click' ? 'tap' : nativeEvent.type;
    var target = this.getTargetForEvent(nativeEvent);
    var currentTarget = this.getTargetForEvent(nativeEvent, 'currentTarget');
    var detail = this.getDetailForEvent(nativeEvent);
    var touches = this.getTouchesForEvent(nativeEvent);
    var changedTouches = this.getTouchesForEvent(nativeEvent, 'changedTouches');
    return _objectSpread({
      type: eventType,
      timeStamp: Date.now(),
      target: target,
      currentTarget: currentTarget,
      detail: detail,
      touches: touches,
      changedTouches: changedTouches
    }, more);
  } // onTap(srcEvent, capture = false) {
  //   this.recordTarget(srcEvent);
  //   // ios also trigger onTap after onLongTap
  //   if (this.__longTapTriggered) {
  //     return;
  //   }
  //   const eventName = 'tap';
  //   if (this.hasEvent(eventName, capture)) {
  //     callBubblesEvent(this, eventName, srcEvent, createTap && createTap.call(this, srcEvent, defaultCreateTap), capture);
  //   }
  // },
  // onTouchStart(srcEvent, capture = false) {
  //   this.recordTarget(srcEvent);
  //   this.__longTapTriggered = 0;
  //   const eventName = 'touchstart';
  //   if (this.hasEvent(eventName, capture)) {
  //     callBubblesEvent(this, eventName, srcEvent, {
  //       touches: createTouchList.call(this, srcEvent.touches),
  //       changedTouches: createTouchList.call(this, srcEvent.changedTouches),
  //     }, capture);
  //   }
  // },
  // onTouchMove(srcEvent, capture = false) {
  //   this.recordTarget(srcEvent);
  //   const eventName = 'touchmove';
  //   if (this.hasEvent(eventName, capture)) {
  //     callBubblesEvent(this, eventName, srcEvent, {
  //       touches: createTouchList.call(this, srcEvent.touches),
  //       changedTouches: createTouchList.call(this, srcEvent.changedTouches),
  //     }, capture);
  //   }
  // },
  // onTouchEnd(srcEvent, capture = false) {
  //   this.recordTarget(srcEvent);
  //   const eventName = 'touchend';
  //   if (this.hasEvent(eventName, capture)) {
  //     callBubblesEvent(this, eventName, srcEvent, {
  //       touches: createTouchList.call(this, srcEvent.touches),
  //       changedTouches: createTouchList.call(this, srcEvent.changedTouches),
  //     }, capture);
  //   }
  // },
  // onTouchCancel(srcEvent, capture = false) {
  //   this.recordTarget(srcEvent);
  //   const eventName = 'touchcancel';
  //   if (this.hasEvent(eventName, capture)) {
  //     callBubblesEvent(this, eventName, srcEvent, {
  //       touches: createTouchList.call(this, srcEvent.touches),
  //       changedTouches: createTouchList.call(this, srcEvent.changedTouches),
  //     }, capture);
  //   }
  // },
  // onLongTap(srcEvent) {
  //   this.__longTapTriggered = 1;
  //   if (this.hasEvent('LongTap')) {
  //     callBubblesEvent(this, 'longTap', srcEvent, createTap && createTap.call(this, srcEvent, defaultCreateTap));
  //   }
  // },
  // onTransitionEnd(srcEvent, capture = false) {
  //   this.recordTarget(srcEvent);
  //   if (this.hasEvent('transitionend', capture)) {
  //     callBubblesEvent(this, 'transitionend', srcEvent, {
  //       detail: {
  //         elapsedTime: srcEvent.elapsedTime,
  //         propertyName: srcEvent.propertyName,
  //       },
  //     }, capture);
  //   }
  // },
  // onAnimationStart(srcEvent, capture = false) {
  //   this.recordTarget(srcEvent);
  //   if (this.hasEvent('animationstart', capture)) {
  //     callBubblesEvent(this, 'animationstart', srcEvent, {
  //       detail: {
  //         elapsedTime: srcEvent.elapsedTime,
  //         animationName: srcEvent.animationName,
  //       },
  //     }, capture);
  //   }
  // },
  // onAnimationIteration(srcEvent, capture = false) {
  //   this.recordTarget(srcEvent);
  //   if (this.hasEvent('animationiteration', capture)) {
  //     callBubblesEvent(this, 'animationiteration', srcEvent, {
  //       detail: {
  //         elapsedTime: srcEvent.elapsedTime,
  //         animationName: srcEvent.animationName,
  //       },
  //     }, capture);
  //   }
  // },
  // onAnimationEnd(srcEvent, capture = false) {
  //   this.recordTarget(srcEvent);
  //   if (this.hasEvent('animationend', capture)) {
  //     callBubblesEvent(this, 'animationend', srcEvent, {
  //       detail: {
  //         elapsedTime: srcEvent.elapsedTime,
  //         animationName: srcEvent.animationName,
  //       },
  //     }, capture);
  //   }
  // },

});

/***/ }),

/***/ "./src/framework/mixins/MessageHandleMixin.js":
/*!****************************************************!*\
  !*** ./src/framework/mixins/MessageHandleMixin.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utils_log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/log */ "./src/utils/log.js");
/* harmony import */ var _utils_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/utils/types */ "./src/utils/types.js");


var MessageHandle = {
  getCallbackId: function getCallbackId() {
    this.callbackSeq = this.callbackSeq || 0;
    this.callbackSeq += 2;
    return this.callbackSeq;
  },
  setId: function setId(id) {
    this.id = id;
  },
  getId: function getId() {
    return this.id;
  },
  getPagePath: function getPagePath() {
    return this.pagePath;
  },
  onMessage: function onMessage(event) {
    var _this = this;

    if (this.unloaded) {
      return;
    }

    var data = event.data;

    if (typeof data === 'string') {
      data = JSON.parse(data).data;
    }

    var _data = data,
        method = _data.method,
        args = _data.args,
        caller = _data.caller,
        successCallback = _data.successCallback,
        errorCallback = _data.errorCallback;

    if (caller !== 'bridge' || method !== 'console') {
      Object(_utils_log__WEBPACK_IMPORTED_MODULE_0__["debug"])('framework', "[".concat(this.pageType, "] Page ").concat(this.pagePath, " onMessage"), data);
    }

    var callPath = caller && caller.split('.') || [];
    var callObj = this;
    callPath.forEach(function (p) {
      callObj = callObj && callObj[p];
    });

    if (callObj) {
      if (!args) {
        Object(_utils_log__WEBPACK_IMPORTED_MODULE_0__["debug"])('framework', "[".concat(this.pageType, "] Page ").concat(this.pagePath, " unhandled message"), event.data);
        return;
      }

      var myArgs = args.concat();

      if (successCallback) {
        myArgs.push(function () {
          for (var _len = arguments.length, a = new Array(_len), _key = 0; _key < _len; _key++) {
            a[_key] = arguments[_key];
          }

          _this.callRemote.apply(_this, ['self', 'invokeCallback', successCallback].concat(a));
        });
      } else {
        myArgs.push(_utils_types__WEBPACK_IMPORTED_MODULE_1__["noop"]);
      }

      if (errorCallback) {
        myArgs.push(function () {
          for (var _len2 = arguments.length, a = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            a[_key2] = arguments[_key2];
          }

          _this.callRemote.apply(_this, ['self', 'invokeCallback', errorCallback].concat(a));
        });
      } else {
        myArgs.push(_utils_types__WEBPACK_IMPORTED_MODULE_1__["noop"]);
      }

      if (callObj[method]) {
        var _callObj;

        (_callObj = callObj)[method].apply(_callObj, myArgs);

        return;
      }
    }

    Object(_utils_log__WEBPACK_IMPORTED_MODULE_0__["debug"])('framework', "[".concat(this.pageType, "] Page ").concat(this.pagePath, " unhandled message"), event.data);
  },
  invokeCallback: function invokeCallback(callbackId) {
    if (this.unloaded) {
      return;
    }

    var callbacks = this.callbacks;

    if (callbacks) {
      if (callbackId && callbacks[callbackId]) {
        for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
          args[_key3 - 1] = arguments[_key3];
        }

        callbacks[callbackId].apply(callbacks, args);
      }

      if (callbackId % 2 === 0) {
        callbackId -= 1;
      } // success and error


      delete callbacks[callbackId];
      delete callbacks[callbackId + 1];
    }
  },
  callRemote: function callRemote(caller, method) {
    if (this.unloaded) {
      return;
    }

    var successCallback;
    var errorCallback;

    for (var _len4 = arguments.length, args = new Array(_len4 > 2 ? _len4 - 2 : 0), _key4 = 2; _key4 < _len4; _key4++) {
      args[_key4 - 2] = arguments[_key4];
    }

    if (typeof args[args.length - 2] === 'function') {
      this.callbacks = this.callbacks || {};
      successCallback = this.getCallbackId() - 1;
      this.callbacks[successCallback] = args[args.length - 2];
      errorCallback = successCallback + 1;
      this.callbacks[errorCallback] = args[args.length - 1];
      args.pop();
      args.pop();
    } else if (typeof args[args.length - 1] === 'function') {
      this.callbacks = this.callbacks || {};
      successCallback = this.getCallbackId() - 1;
      this.callbacks[successCallback] = args[args.length - 1];
      errorCallback = successCallback + 1;
      args.pop();
    }

    this.postMessage({
      caller: caller,
      method: method,
      id: this.getId(),
      successCallback: successCallback,
      errorCallback: errorCallback,
      args: args
    });
  }
};
/* harmony default export */ __webpack_exports__["default"] = (MessageHandle);

/***/ }),

/***/ "./src/framework/mixins/PureRenderMixin.js":
/*!*************************************************!*\
  !*** ./src/framework/mixins/PureRenderMixin.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utils_shallowEqual__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/shallowEqual */ "./src/utils/shallowEqual.js");

var PureRender = {
  shouldComponentUpdate: function shouldComponentUpdate(nextProps, nextState) {
    return !Object(_utils_shallowEqual__WEBPACK_IMPORTED_MODULE_0__["default"])(nextProps, this.props) || !Object(_utils_shallowEqual__WEBPACK_IMPORTED_MODULE_0__["default"])(nextState, this.state);
  }
};
/* harmony default export */ __webpack_exports__["default"] = (PureRender);

/***/ }),

/***/ "./src/framework/mixins/RefMixin.js":
/*!******************************************!*\
  !*** ./src/framework/mixins/RefMixin.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var Ref = {
  getInitialState: function getInitialState() {
    this.refHandlers = {};
    this.refComponents = {};
    return {};
  },
  $getRefHandler: function $getRefHandler(name) {
    var _this = this;

    if (this.refHandlers[name]) {
      return this.refHandlers[name];
    }

    this.refHandlers[name] = function (ref) {
      var c = ref;

      if (c && c.getWrappedComponent) {
        c = c.getWrappedComponent();
      }

      _this.refComponents[name] = c;
    };

    return this.refHandlers[name];
  }
};
/* harmony default export */ __webpack_exports__["default"] = (Ref);

/***/ }),

/***/ "./src/framework/mixins/TrackPageUpdateMixin.js":
/*!******************************************************!*\
  !*** ./src/framework/mixins/TrackPageUpdateMixin.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _EventHub__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../EventHub */ "./src/framework/EventHub.js");
/* harmony import */ var _App__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../App */ "./src/framework/App/index.js");



function needReLayout(instance) {
  var tagName = instance.$mp.tagName;
  var _self = self;
  var NATIVE_COMPONENTS_AUTO_ADJUST = _self.NATIVE_COMPONENTS_AUTO_ADJUST;
  return !(NATIVE_COMPONENTS_AUTO_ADJUST && tagName in NATIVE_COMPONENTS_AUTO_ADJUST);
}

var TrackPageUpdate = {
  componentDidMount: function componentDidMount() {
    var _this = this;

    if (this.isTrackPageUpdateForIOS()) {
      this.renderSeq = Object(_App__WEBPACK_IMPORTED_MODULE_1__["getCurrentPageImpl"])().renderSeq;
      this.detachPageUpdate = _EventHub__WEBPACK_IMPORTED_MODULE_0__["default"].addListener('pageUpdate', function () {
        if (needReLayout(_this) && _this.renderSeq !== Object(_App__WEBPACK_IMPORTED_MODULE_1__["getCurrentPageImpl"])().renderSeq) {
          _this.forceUpdate();
        }
      });
    }
  },
  componentDidUpdate: function componentDidUpdate() {
    if (this.isTrackPageUpdateForIOS()) {
      this.renderSeq = Object(_App__WEBPACK_IMPORTED_MODULE_1__["getCurrentPageImpl"])().renderSeq;
    }
  },
  componentWillUnmount: function componentWillUnmount() {
    if (this.isTrackPageUpdateForIOS()) {
      this.detachPageUpdate.remove();
    }
  }
};
/* harmony default export */ __webpack_exports__["default"] = (TrackPageUpdate);

/***/ }),

/***/ "./src/framework/startupParams/index.js":
/*!**********************************************!*\
  !*** ./src/framework/startupParams/index.js ***!
  \**********************************************/
/*! exports provided: getStartupParams, setStartupParams */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utils_startupParams__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/startupParams */ "./src/utils/startupParams/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getStartupParams", function() { return _utils_startupParams__WEBPACK_IMPORTED_MODULE_0__["getStartupParams"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "setStartupParams", function() { return _utils_startupParams__WEBPACK_IMPORTED_MODULE_0__["setStartupParams"]; });




/***/ }),

/***/ "./src/framework/utils/camelCase.js":
/*!******************************************!*\
  !*** ./src/framework/utils/camelCase.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return camelCase; });
function camelCase(name) {
  return name.replace(/-(\w)/g, function (_w, g) {
    return g.toUpperCase();
  });
}

/***/ }),

/***/ "./src/framework/utils/env.js":
/*!************************************!*\
  !*** ./src/framework/utils/env.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {if (!global.Symbol) {
  var id = 0;

  var _Symbol = function _Symbol2(key) {
    return "$$_mp_symbol_".concat(key, "_").concat(++id, "_$$");
  };

  _Symbol.iterator = _Symbol('Symbol.iterator');
  global.Symbol = _Symbol;
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./src/framework/utils/filterCssValue.js":
/*!***********************************************!*\
  !*** ./src/framework/utils/filterCssValue.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return filterCssValue; });
/* harmony import */ var _unit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./unit */ "./src/framework/utils/unit.js");
/* harmony import */ var _isNumber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isNumber */ "./src/framework/utils/isNumber.js");



function normalizeCssValueWeb(_value) {
  var value = _value;

  if (typeof value === 'string') {
    value = value.replace(/\b([.\d]+)rpx\b/gi, function (_m, v) {
      return "".concat(Object(_unit__WEBPACK_IMPORTED_MODULE_0__["rpx"])(parseFloat(v)));
    });

    if (Object(_isNumber__WEBPACK_IMPORTED_MODULE_1__["default"])(value)) {
      return parseFloat(value);
    }
  }

  return value;
}

function filterCssValue(name, style) {
  var ret = {};
  ret[name] = normalizeCssValueWeb(style[name]);
  return ret;
}

/***/ }),

/***/ "./src/framework/utils/isNumber.js":
/*!*****************************************!*\
  !*** ./src/framework/utils/isNumber.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return isNumber; });
var numberReSnippet = '(?:NaN|-?(?:(?:\\d+|\\d*\\.\\d+)(?:[E|e][+|-]?\\d+)?|Infinity))';
var matchOnlyNumberRe = new RegExp("^(".concat(numberReSnippet, ")$"));
function isNumber(str) {
  return !!str.trim().match(matchOnlyNumberRe);
}

/***/ }),

/***/ "./src/framework/utils/normalizeComponentProps.js":
/*!********************************************************!*\
  !*** ./src/framework/utils/normalizeComponentProps.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return normalizeComponentProps; });
/* harmony import */ var _babel_runtime_helpers_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/objectWithoutProperties */ "./node_modules/@babel/runtime/helpers/objectWithoutProperties.js");
/* harmony import */ var _babel_runtime_helpers_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_0__);

function normalizeComponentProps(props) {
  var children = props.children,
      $scopedSlots = props.$scopedSlots,
      slot = props.slot,
      ret = _babel_runtime_helpers_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_0___default()(props, ["children", "$scopedSlots", "slot"]);

  return ret;
}

/***/ }),

/***/ "./src/framework/utils/pageInfoAndUrl.js":
/*!***********************************************!*\
  !*** ./src/framework/utils/pageInfoAndUrl.js ***!
  \***********************************************/
/*! exports provided: getUrlFromPageInfo, getPageInfoFromUrl */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getUrlFromPageInfo", function() { return getUrlFromPageInfo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getPageInfoFromUrl", function() { return getPageInfoFromUrl; });
/* harmony import */ var _common_global__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/global */ "./src/framework/common/global.js");

var pageMatchReg = /#([^?]+)(\?.+)?/;
var MP_PAGE_ID = '__mpPageId';
var pageIdMatch = new RegExp("[&?]".concat(MP_PAGE_ID, "=(\\d+)(?:&|$)"));
function getUrlFromPageInfo(_ref) {
  var pagePath = _ref.pagePath,
      pageId = _ref.pageId,
      queryString = _ref.queryString;
  return "#".concat(pagePath, "?").concat(MP_PAGE_ID, "=").concat(pageId).concat(queryString ? "&".concat(queryString) : '');
}
function getPageInfoFromUrl(url) {
  var id;
  var pageMatch = url && url.match(pageMatchReg);
  var pagePath = pageMatch && pageMatch[1];

  if (pagePath && pagePath.charAt(0) === '/') {
    pagePath = pagePath.slice(1);
  }

  var queryString = pageMatch && pageMatch[2] || '';
  var idMatch = queryString.match(pageIdMatch);

  if (idMatch) {
    id = parseInt(idMatch[1], 10);
    queryString = queryString.replace(pageIdMatch, '');
  }

  if (queryString.charAt(0) === '?') {
    queryString = queryString.slice(1);
  }

  id = id || _common_global__WEBPACK_IMPORTED_MODULE_0__["default"].tabsConfig[pagePath] || 0;
  return {
    id: id,
    pagePath: pagePath,
    queryString: queryString
  };
}

/***/ }),

/***/ "./src/framework/utils/resolvePageUrl.js":
/*!***********************************************!*\
  !*** ./src/framework/utils/resolvePageUrl.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return resolvePageUrl; });
/* harmony import */ var _resolveUrl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./resolveUrl */ "./src/framework/utils/resolveUrl.js");

function resolvePageUrl(pagePath, currentPage) {
  var url = pagePath;
  var queryString = '';
  var queryIndex = url.indexOf('?');

  if (queryIndex !== -1) {
    queryString = url.slice(queryIndex + 1);
    url = url.slice(0, queryIndex);
  }

  if (url.charAt(0) === '/') {
    url = url.slice(1);
  } else if (currentPage) {
    var refer = currentPage.getPagePath();
    url = Object(_resolveUrl__WEBPACK_IMPORTED_MODULE_0__["default"])(url, refer);
  }

  queryString = queryString ? "?".concat(queryString) : queryString;
  return "".concat(url).concat(queryString);
}

/***/ }),

/***/ "./src/framework/utils/resolveUrl.js":
/*!*******************************************!*\
  !*** ./src/framework/utils/resolveUrl.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return resolveUrl; });
/* harmony import */ var _utils_startsWith__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/startsWith */ "./src/utils/startsWith.js");

function resolveUrl(path, refered) {
  if (Object(_utils_startsWith__WEBPACK_IMPORTED_MODULE_0__["default"])(path, '/')) {
    return path;
  }

  if (!Object(_utils_startsWith__WEBPACK_IMPORTED_MODULE_0__["default"])(path, './') && !Object(_utils_startsWith__WEBPACK_IMPORTED_MODULE_0__["default"])(path, '../')) {
    path = "./".concat(path);
  }

  var referedParts = refered.split('/');

  if (referedParts[referedParts.length - 1]) {
    referedParts.pop();
  }

  var parts = referedParts.concat(path.split('/'));
  var res = [];
  parts.forEach(function (p) {
    // ignore empty parts
    if (!p || p === '.') {
      return;
    }

    if (p === '..') {
      res.pop();
    } else {
      res.push(p);
    }
  });
  return res.join('/');
}

/***/ }),

/***/ "./src/framework/utils/ruleTransform.js":
/*!**********************************************!*\
  !*** ./src/framework/utils/ruleTransform.js ***!
  \**********************************************/
/*! exports provided: ruleName, ruleValue, needNormalizeCssValue */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ruleName", function() { return ruleName; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ruleValue", function() { return ruleValue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "needNormalizeCssValue", function() { return needNormalizeCssValue; });
/* harmony import */ var css_vendor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! css-vendor */ "./node_modules/css-vendor/dist/css-vendor.esm.js");

function ruleName(v) {
  return Object(css_vendor__WEBPACK_IMPORTED_MODULE_0__["supportedProperty"])(v);
}
function ruleValue(n, v) {
  return Object(css_vendor__WEBPACK_IMPORTED_MODULE_0__["supportedValue"])(n, v);
}
function needNormalizeCssValue(property) {
  return property.indexOf('flex') !== -1 || property.indexOf('display') !== -1;
}

/***/ }),

/***/ "./src/framework/utils/transformChildrenToSlots.js":
/*!*********************************************************!*\
  !*** ./src/framework/utils/transformChildrenToSlots.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return transformChildrenToSlots; });
/* harmony import */ var _nerv__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/nerv */ "./src/nerv/index.ts");

function transformChildrenToSlots(children) {
  var slots = {};
  _nerv__WEBPACK_IMPORTED_MODULE_0__["default"].Children.forEach(children, function (c) {
    var slot = c && c.props && c.props.slot || '$default';
    var holder = slots[slot] || [];
    holder.push(c);
    slots[slot] = holder;
  });
  return slots;
}

/***/ }),

/***/ "./src/framework/utils/transformStyle.js":
/*!***********************************************!*\
  !*** ./src/framework/utils/transformStyle.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return transformStyle; });
/* harmony import */ var _utils_objectKeys__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/objectKeys */ "./src/utils/objectKeys.js");
/* harmony import */ var _camelCase__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./camelCase */ "./src/framework/utils/camelCase.js");
/* harmony import */ var _filterCssValue__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./filterCssValue */ "./src/framework/utils/filterCssValue.js");
/* harmony import */ var _ruleTransform__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ruleTransform */ "./src/framework/utils/ruleTransform.js");




function transformStyle(style) {
  var d = {};
  Object(_utils_objectKeys__WEBPACK_IMPORTED_MODULE_0__["default"])(style).forEach(function (name) {
    var expanded = Object(_filterCssValue__WEBPACK_IMPORTED_MODULE_2__["default"])(name, style);

    if (expanded === false) {
      return;
    }

    Object(_utils_objectKeys__WEBPACK_IMPORTED_MODULE_0__["default"])(expanded).forEach(function (key) {
      var v = expanded[key];
      var property = Object(_ruleTransform__WEBPACK_IMPORTED_MODULE_3__["ruleName"])(Object(_camelCase__WEBPACK_IMPORTED_MODULE_1__["default"])(key)); // color #xxx -> rgb()

      if (property) {
        d[property] = Object(_ruleTransform__WEBPACK_IMPORTED_MODULE_3__["needNormalizeCssValue"])(property) ? Object(_ruleTransform__WEBPACK_IMPORTED_MODULE_3__["ruleValue"])(property, v) : v;
      }
    });
  });
  return d;
}

/***/ }),

/***/ "./src/framework/utils/unit.js":
/*!*************************************!*\
  !*** ./src/framework/utils/unit.js ***!
  \*************************************/
/*! exports provided: rpx, rpx2px, px */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rpx", function() { return rpx; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rpx2px", function() { return rpx2px; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "px", function() { return px; });
/* harmony import */ var _Platform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Platform */ "./src/framework/Platform/index.js");

var isIOS = _Platform__WEBPACK_IMPORTED_MODULE_0__["default"].browser === 'ios';
var clientWidth = document.documentElement.clientWidth;
function rpx(v) {
  var value = rpx2px(v);

  if (value > 0 && value < 1) {
    value = isIOS ? 0.5 : 1;
  } else {
    value = Math.floor(value);
  }

  return "".concat(value, "px");
}
function rpx2px(v) {
  return v / 750 * clientWidth;
}
function px(v) {
  return "".concat(v, "px");
}

/***/ }),

/***/ "./src/framework/web/bootstrap.js":
/*!****************************************!*\
  !*** ./src/framework/web/bootstrap.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _nerv__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/nerv */ "./src/nerv/index.ts");
/* harmony import */ var _utils_log__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/utils/log */ "./src/utils/log.js");
/* harmony import */ var _utils_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/utils/types */ "./src/utils/types.js");
/* harmony import */ var _PageRegistry__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../PageRegistry */ "./src/framework/PageRegistry/index.js");
/* harmony import */ var _utils_pageInfoAndUrl__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/pageInfoAndUrl */ "./src/framework/utils/pageInfoAndUrl.js");
/* harmony import */ var _getMessageChannel__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./getMessageChannel */ "./src/framework/web/getMessageChannel.js");
/* harmony import */ var _SubPackage__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../SubPackage */ "./src/framework/SubPackage/index.js");







var g = self;
/* harmony default export */ __webpack_exports__["default"] = (function (config, bridge) {
  var _config$container = config.container,
      container = _config$container === void 0 ? document.getElementById('__frame__') : _config$container,
      _config$onRender = config.onRender,
      onRender = _config$onRender === void 0 ? _utils_types__WEBPACK_IMPORTED_MODULE_2__["noop"] : _config$onRender,
      _config$onFail = config.onFail,
      onFail = _config$onFail === void 0 ? _utils_types__WEBPACK_IMPORTED_MODULE_2__["noop"] : _config$onFail,
      type = config.type;
  var pageInfo = Object(_utils_pageInfoAndUrl__WEBPACK_IMPORTED_MODULE_4__["getPageInfoFromUrl"])(location.href);
  Object(_utils_log__WEBPACK_IMPORTED_MODULE_1__["debug"])('framework', 'pageInfo', pageInfo);
  var pagePath = pageInfo.pagePath;

  if (pagePath) {
    document.documentElement.style.fontSize = "".concat(100 * document.documentElement.clientWidth / 750, "px");
    Object(_SubPackage__WEBPACK_IMPORTED_MODULE_6__["loadPage"])(pagePath, function () {
      var PageComponent = _PageRegistry__WEBPACK_IMPORTED_MODULE_3__["default"].getComponent(pagePath);

      if (PageComponent) {
        Object(_utils_log__WEBPACK_IMPORTED_MODULE_1__["debug"])('framework', "Render page: ".concat(pagePath));

        if (onRender) {
          onRender(type);
        }

        var messageChannel = Object(_getMessageChannel__WEBPACK_IMPORTED_MODULE_5__["default"])(pageInfo, bridge);
        Object(_nerv__WEBPACK_IMPORTED_MODULE_0__["hydrate"])(_nerv__WEBPACK_IMPORTED_MODULE_0__["default"].createElement(PageComponent, {
          pagePath: pagePath,
          container: container,
          messageChannel: messageChannel
        }), container);
      } else {
        var error = new Error("page '".concat(pagePath, "' not found!"));
        error.type = 'PAGE_NOT_FOUND';

        if (onFail) {
          onFail(error);
        }
      }
    });
  } else {
    Object(_nerv__WEBPACK_IMPORTED_MODULE_0__["unmountComponentAtNode"])(container);
  }
});

/***/ }),

/***/ "./src/framework/web/getMessageChannel.js":
/*!************************************************!*\
  !*** ./src/framework/web/getMessageChannel.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return getMessageChannel; });
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__);


function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var g = self;
function getMessageChannel(pageInfo, bridge) {
  var unhandledMessages = [];
  var callback;

  g.send = function (event) {
    if (callback) {
      callback(event);
    } else {
      unhandledMessages.push(event);
    }
  };

  g.addEventListener('message', g.send);
  var queryString = pageInfo.queryString,
      id = pageInfo.id,
      pagePath = pageInfo.pagePath;
  var payload = {
    pagePath: pagePath,
    id: id,
    pageType: 'RENDER',
    msgType: 'DOMContentLoaded',
    viewId: g.WEBVIEWID
  };

  if (queryString) {
    payload.queryString = queryString;
  }

  bridge.call('postMessage', payload);
  return {
    id: id,
    postMessage: function postMessage(data) {
      bridge.call('postMessage', _objectSpread(_objectSpread({
        viewId: g.WEBVIEWID
      }, data), {}, {
        id: data.id || id
      }));
    },
    onMessage: function onMessage(fn) {
      callback = fn;

      if (unhandledMessages.length) {
        unhandledMessages.forEach(function (message) {
          fn(message);
        });
        unhandledMessages = [];
      }
    }
  };
}

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _web_components__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./web-components */ "./src/web-components/index.js");
/* harmony import */ var _apis___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/apis/ */ "./src/apis/index.js");
/* harmony import */ var _nerv__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/nerv */ "./src/nerv/index.ts");
/* harmony import */ var _utils_log__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/utils/log */ "./src/utils/log.js");
/* harmony import */ var _framework_index__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./framework/index */ "./src/framework/index.js");
/* harmony import */ var _xml_runtime__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./xml-runtime */ "./src/xml-runtime/index.js");







var __mpStartTime = Date.now();

self.Nerv = _nerv__WEBPACK_IMPORTED_MODULE_2__["default"];
self.XMLRuntime = _xml_runtime__WEBPACK_IMPORTED_MODULE_5__["default"];
self.MP = {
  bridge: _apis___WEBPACK_IMPORTED_MODULE_1__["default"],
  EventHub: _framework_index__WEBPACK_IMPORTED_MODULE_4__["EventHub"],
  App: _framework_index__WEBPACK_IMPORTED_MODULE_4__["App"],
  setCurrentPageImpl: _framework_index__WEBPACK_IMPORTED_MODULE_4__["setCurrentPageImpl"],
  getCurrentPageImpl: _framework_index__WEBPACK_IMPORTED_MODULE_4__["getCurrentPageImpl"],
  getCurrentPagesImpl: _framework_index__WEBPACK_IMPORTED_MODULE_4__["getCurrentPagesImpl"],
  getApp: _framework_index__WEBPACK_IMPORTED_MODULE_4__["getApp"],
  getAppImpl: _framework_index__WEBPACK_IMPORTED_MODULE_4__["getAppImpl"],
  getCurrentPages: _framework_index__WEBPACK_IMPORTED_MODULE_4__["getCurrentPages"],
  getStartupParams: _framework_index__WEBPACK_IMPORTED_MODULE_4__["getStartupParams"],
  setStartupParams: _framework_index__WEBPACK_IMPORTED_MODULE_4__["setStartupParams"],
  Component: _framework_index__WEBPACK_IMPORTED_MODULE_4__["Component"],
  getComponentClass: _framework_index__WEBPACK_IMPORTED_MODULE_4__["getComponentClass"],
  StyleSheet: _framework_index__WEBPACK_IMPORTED_MODULE_4__["StyleSheet"],
  createComponent: _framework_index__WEBPACK_IMPORTED_MODULE_4__["createComponent"],
  Page: _framework_index__WEBPACK_IMPORTED_MODULE_4__["Page"],
  $global: _framework_index__WEBPACK_IMPORTED_MODULE_4__["$global"]
};

var __mpCosts = Date.now() - __mpStartTime;

Object(_utils_log__WEBPACK_IMPORTED_MODULE_3__["debug"])('framework', "web bundle costs ".concat(__mpCosts, " ms"));

/***/ }),

/***/ "./src/nerv/children.ts":
/*!******************************!*\
  !*** ./src/nerv/children.ts ***!
  \******************************/
/*! exports provided: Children */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Children", function() { return Children; });
/* harmony import */ var _nerv_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/nerv/utils */ "./src/nerv/utils/index.ts");
/* harmony import */ var _nerv_shared__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/nerv/shared */ "./src/nerv/shared/index.ts");


var Children = {
    map: function (children, fn, ctx) {
        if (Object(_nerv_shared__WEBPACK_IMPORTED_MODULE_1__["isNullOrUndef"])(children)) {
            return children;
        }
        children = Children.toArray(children);
        if (ctx && ctx !== children) {
            fn = fn.bind(ctx);
        }
        return children.map(fn);
    },
    forEach: function (children, fn, ctx) {
        if (Object(_nerv_shared__WEBPACK_IMPORTED_MODULE_1__["isNullOrUndef"])(children)) {
            return;
        }
        children = Children.toArray(children);
        if (ctx && ctx !== children) {
            fn = fn.bind(ctx);
        }
        for (var i = 0, len = children.length; i < len; i++) {
            var child = Object(_nerv_shared__WEBPACK_IMPORTED_MODULE_1__["isInvalid"])(children[i]) ? null : children[i];
            fn(child, i, children);
        }
    },
    count: function (children) {
        children = Children.toArray(children);
        return children.length;
    },
    only: function (children) {
        children = Children.toArray(children);
        if (children.length !== 1) {
            throw new Error('Children.only() expects only one child.');
        }
        return children[0];
    },
    toArray: function (children) {
        if (Object(_nerv_shared__WEBPACK_IMPORTED_MODULE_1__["isNullOrUndef"])(children)) {
            return [];
        }
        if (Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["isArray"])(children)) {
            var result = [];
            flatten(children, result);
            return result;
        }
        return _nerv_shared__WEBPACK_IMPORTED_MODULE_1__["EMPTY_CHILDREN"].concat(children);
    },
};
function flatten(arr, result) {
    for (var i = 0, len = arr.length; i < len; i++) {
        var value = arr[i];
        if (Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["isArray"])(value)) {
            flatten(value, result);
        }
        else {
            result.push(value);
        }
    }
    return result;
}


/***/ }),

/***/ "./src/nerv/clone-element.ts":
/*!***********************************!*\
  !*** ./src/nerv/clone-element.ts ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return cloneElement; });
/* harmony import */ var _nerv_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/nerv/utils */ "./src/nerv/utils/index.ts");
/* harmony import */ var _nerv_shared__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/nerv/shared */ "./src/nerv/shared/index.ts");
/* harmony import */ var _create_element__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./create-element */ "./src/nerv/create-element.ts");
/* harmony import */ var _vdom_create_vtext__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./vdom/create-vtext */ "./src/nerv/vdom/create-vtext.ts");
/* harmony import */ var _vdom_create_void__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./vdom/create-void */ "./src/nerv/vdom/create-void.ts");





function cloneElement(vnode, props) {
    var children = [];
    for (var _i = 2; _i < arguments.length; _i++) {
        children[_i - 2] = arguments[_i];
    }
    if (Object(_nerv_shared__WEBPACK_IMPORTED_MODULE_1__["isVText"])(vnode)) {
        return Object(_vdom_create_vtext__WEBPACK_IMPORTED_MODULE_3__["default"])(vnode.text);
    }
    if (Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["isString"])(vnode) || Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["isNumber"])(vnode)) {
        return Object(_vdom_create_vtext__WEBPACK_IMPORTED_MODULE_3__["default"])(vnode);
    }
    if (Object(_nerv_shared__WEBPACK_IMPORTED_MODULE_1__["isInvalid"])(vnode)
        || (!Object(_nerv_shared__WEBPACK_IMPORTED_MODULE_1__["isInvalid"])(vnode) && Object(_nerv_shared__WEBPACK_IMPORTED_MODULE_1__["isPortal"])(vnode.vtype, vnode))
        || (vnode && (vnode.vtype & 16 /* Void */))) {
        return Object(_vdom_create_void__WEBPACK_IMPORTED_MODULE_4__["createVoid"])();
    }
    var properties = Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["clone"])(Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["extend"])(Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["clone"])(vnode.props), props));
    if (vnode.namespace) {
        properties.namespace = vnode.namespace;
    }
    if ((vnode.vtype & 4 /* Composite */) && !Object(_nerv_shared__WEBPACK_IMPORTED_MODULE_1__["isNullOrUndef"])(vnode.ref)) {
        properties.ref = vnode.ref;
    }
    var childrenTmp = (arguments.length > 2
        ? [].slice.call(arguments, 2)
        : vnode.children || properties.children) || [];
    if (childrenTmp.length) {
        if (childrenTmp.length === 1) {
            childrenTmp = children[0];
        }
    }
    if (Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["isArray"])(vnode)) {
        return vnode.map(function (item) {
            return cloneElement(item);
        });
    }
    var newVNode = Object(_create_element__WEBPACK_IMPORTED_MODULE_2__["default"])(vnode.type, properties);
    if (Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["isArray"])(childrenTmp)) {
        var _children = childrenTmp.map(function (child) {
            return cloneElement(child, child.props);
        });
        if (_children.length === 0) {
            _children = _nerv_shared__WEBPACK_IMPORTED_MODULE_1__["EMPTY_CHILDREN"];
        }
        if (Object(_nerv_shared__WEBPACK_IMPORTED_MODULE_1__["isVNode"])(newVNode)) {
            newVNode.children = _children;
        }
        newVNode.props.children = _children;
    }
    else if (childrenTmp) {
        if (Object(_nerv_shared__WEBPACK_IMPORTED_MODULE_1__["isVNode"])(newVNode)) {
            newVNode.children = cloneElement(childrenTmp);
        }
        newVNode.props.children = cloneElement(childrenTmp, childrenTmp.props);
    }
    return newVNode;
}


/***/ }),

/***/ "./src/nerv/component.ts":
/*!*******************************!*\
  !*** ./src/nerv/component.ts ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _nerv_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/nerv/utils */ "./src/nerv/utils/index.ts");
/* harmony import */ var _nerv_shared__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/nerv/shared */ "./src/nerv/shared/index.ts");
/* harmony import */ var _render_queue__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./render-queue */ "./src/nerv/render-queue.ts");
/* harmony import */ var _lifecycle__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lifecycle */ "./src/nerv/lifecycle.ts");




var Component = /** @class */ (function () {
    function Component(props, context) {
        this._dirty = true;
        this._disable = true;
        this._pendingStates = [];
        this._pendingCallbacks = [];
        this._afterScheduleEffect = false;
        this.hooks = [];
        this.effects = _nerv_shared__WEBPACK_IMPORTED_MODULE_1__["EMPTY_CHILDREN"];
        this.layoutEffects = _nerv_shared__WEBPACK_IMPORTED_MODULE_1__["EMPTY_CHILDREN"];
        if (!this.state) {
            this.state = {};
        }
        this.props = props || {};
        this.context = context || _nerv_shared__WEBPACK_IMPORTED_MODULE_1__["EMPTY_OBJ"];
        this.refs = {};
    }
    Component.prototype.setState = function (state, callback) {
        if (state) {
            this._pendingStates.push(state);
        }
        if (Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["isFunction"])(callback)) {
            this._pendingCallbacks.push(callback);
        }
        if (!this._disable) {
            Object(_render_queue__WEBPACK_IMPORTED_MODULE_2__["enqueueRender"])(this);
        }
    };
    Component.prototype.getState = function () {
        var _this = this;
        // tslint:disable-next-line:no-this-assignment
        var _a = this, _pendingStates = _a._pendingStates, state = _a.state, props = _a.props;
        if (!_pendingStates.length) {
            return state;
        }
        var stateClone = Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["clone"])(state);
        var queue = _pendingStates.concat();
        this._pendingStates.length = 0;
        queue.forEach(function (nextState) {
            if (Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["isFunction"])(nextState)) {
                nextState = nextState.call(_this, state, props);
            }
            Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["extend"])(stateClone, nextState);
        });
        return stateClone;
    };
    Component.prototype.clearCallBacks = function () {
        // cached the length of callbacks, or callbacks may increase by calling them in the same loop
        var len = this._pendingCallbacks.length;
        while (this._dirty ? this._pendingCallbacks.length : len) {
            var cb = this._pendingCallbacks.shift();
            cb.call(this);
            len--;
        }
    };
    Component.prototype.forceUpdate = function (callback) {
        if (Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["isFunction"])(callback)) {
            this._pendingCallbacks.push(callback);
        }
        Object(_lifecycle__WEBPACK_IMPORTED_MODULE_3__["updateComponent"])(this, true);
    };
    // tslint:disable-next-line
    Component.prototype.render = function (nextProps, nextState, nextContext) { };
    return Component;
}());
Component.prototype.isReactComponent = _nerv_shared__WEBPACK_IMPORTED_MODULE_1__["EMPTY_OBJ"];
/* harmony default export */ __webpack_exports__["default"] = (Component);


/***/ }),

/***/ "./src/nerv/create-class.ts":
/*!**********************************!*\
  !*** ./src/nerv/create-class.ts ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return createClass; });
/* harmony import */ var _nerv_shared__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/nerv/shared */ "./src/nerv/shared/index.ts");
/* harmony import */ var _nerv_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/nerv/utils */ "./src/nerv/utils/index.ts");
/* harmony import */ var _component__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./component */ "./src/nerv/component.ts");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();



// don't autobind these methods since they already have guaranteed context.
var AUTOBIND_BLACKLIST = {
    constructor: 1,
    render: 1,
    shouldComponentUpdate: 1,
    // tslint:disable-next-line:object-literal-sort-keys
    componentWillUpdate: 1,
    componentWillReceiveProps: 1,
    componentDidUpdate: 1,
    componentWillMount: 1,
    componentDidMount: 1,
    componentWillUnmount: 1,
    componentDidUnmount: 1,
    getDerivedStateFromProps: 1,
};
function extend(base, props) {
    for (var key in props) {
        if (!Object(_nerv_shared__WEBPACK_IMPORTED_MODULE_0__["isNullOrUndef"])(props[key])) {
            base[key] = props[key];
        }
    }
    return base;
}
function bindAll(ctx) {
    for (var i in ctx) {
        var v = ctx[i];
        if (typeof v === 'function' && !v.__bound && AUTOBIND_BLACKLIST[i] !== 1) {
            (ctx[i] = v.bind(ctx)).__bound = true;
        }
    }
}
function collateMixins(mixins, keyed) {
    if (keyed === void 0) { keyed = {}; }
    for (var i = 0, len = mixins.length; i < len; i++) {
        var mixin = mixins[i];
        if (mixin.mixins) {
            // Recursively collate sub-mixins
            collateMixins(mixin.mixins, keyed);
        }
        for (var key in mixin) {
            if (mixin.hasOwnProperty(key) && typeof mixin[key] === 'function') {
                (keyed[key] || (keyed[key] = [])).push(mixin[key]);
            }
        }
    }
    return keyed;
}
function multihook(hooks, mergeFn) {
    return function () {
        var ret;
        for (var i = 0, len = hooks.length; i < len; i++) {
            var hook = hooks[i];
            var r = hook.apply(this, arguments);
            if (mergeFn) {
                ret = mergeFn(ret, r);
            }
            else if (!Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_1__["isUndefined"])(r)) {
                ret = r;
            }
        }
        return ret;
    };
}
function mergeNoDupes(previous, current) {
    if (!Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_1__["isUndefined"])(current)) {
        if (!previous) {
            previous = {};
        }
        for (var key in current) {
            if (current.hasOwnProperty(key)) {
                if (previous.hasOwnProperty(key)) {
                    throw new Error("Mixins return duplicate key " + key + " in their return values");
                }
                previous[key] = current[key];
            }
        }
    }
    return previous;
}
function applyMixin(key, inst, mixin) {
    var hooks = Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_1__["isUndefined"])(inst[key]) ? mixin : mixin.concat(inst[key]);
    inst[key] = key === 'getDefaultProps'
        || key === 'getInitialState'
        || key === 'getChildContext'
        ? multihook(hooks, mergeNoDupes)
        : multihook(hooks);
}
function applyMixins(Cl, mixins) {
    for (var key in mixins) {
        if (mixins.hasOwnProperty(key)) {
            var mixin = mixins[key];
            var inst = key === 'getDefaultProps' ? Cl : Cl.prototype;
            if (Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_1__["isFunction"])(mixin[0])) {
                applyMixin(key, inst, mixin);
            }
            else {
                inst[key] = mixin;
            }
        }
    }
}
function createClass(obj) {
    var BoundClass = /** @class */ (function (_super) {
        __extends(BoundClass, _super);
        function BoundClass(props, context) {
            var _this = _super.call(this, props, context) || this;
            bindAll(_this);
            if (_this.getInitialState) {
                _this.state = _this.getInitialState();
            }
            return _this;
        }
        BoundClass.prototype.replaceState = function (nextState, callback) {
            this.setState(nextState, callback);
        };
        BoundClass.prototype.isMounted = function () {
            return !this.dom;
        };
        BoundClass.displayName = obj.displayName || 'Component';
        BoundClass.propTypes = obj.propTypes;
        BoundClass.mixins = obj.mixins && collateMixins(obj.mixins);
        BoundClass.getDefaultProps = obj.getDefaultProps;
        return BoundClass;
    }(_component__WEBPACK_IMPORTED_MODULE_2__["default"]));
    extend(BoundClass.prototype, obj);
    if (obj.statics) {
        extend(BoundClass, obj.statics);
    }
    if (obj.mixins) {
        applyMixins(BoundClass, collateMixins(obj.mixins));
    }
    BoundClass.defaultProps = Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_1__["isUndefined"])(BoundClass.getDefaultProps)
        ? undefined
        : BoundClass.getDefaultProps();
    return BoundClass;
}


/***/ }),

/***/ "./src/nerv/create-context.ts":
/*!************************************!*\
  !*** ./src/nerv/create-context.ts ***!
  \************************************/
/*! exports provided: uid, createContext */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "uid", function() { return uid; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createContext", function() { return createContext; });
/* harmony import */ var _nerv_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/nerv/utils */ "./src/nerv/utils/index.ts");
/* harmony import */ var _emiter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./emiter */ "./src/nerv/emiter.ts");
/* harmony import */ var _component__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./component */ "./src/nerv/component.ts");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();



var uid = 0;
function onlyChild(children) {
    return Array.isArray(children) ? children[0] : children;
}
function createContext(defaultValue) {
    var contextProp = "__context_" + uid++ + "__";
    var Provider = /** @class */ (function (_super) {
        __extends(Provider, _super);
        function Provider() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.emiter = new _emiter__WEBPACK_IMPORTED_MODULE_1__["Emiter"](_this.props.value);
            return _this;
        }
        Provider.prototype.getChildContext = function () {
            var _a;
            return _a = {},
                _a[contextProp] = this.emiter,
                _a;
        };
        Provider.prototype.componentWillReceiveProps = function (nextProps) {
            if (!Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["objectIs"])(this.props.value, nextProps.value)) {
                this.emiter.set(nextProps.value);
            }
        };
        Provider.prototype.render = function () {
            return this.props.children;
        };
        Provider.isContextProvider = true;
        return Provider;
    }(_component__WEBPACK_IMPORTED_MODULE_2__["default"]));
    // tslint:disable-next-line: max-classes-per-file
    var Consumer = /** @class */ (function (_super) {
        __extends(Consumer, _super);
        function Consumer() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.state = {
                value: _this.getContextValue(),
            };
            _this.onUpdate = function (value) {
                if (!Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["objectIs"])(value, _this.state.value)) {
                    _this.setState({
                        value: _this.getContextValue(),
                    });
                }
            };
            return _this;
        }
        Consumer.prototype.componentWillMount = function () {
            var emiter = this.context[contextProp];
            if (emiter) {
                emiter.off(this.onUpdate);
            }
        };
        Consumer.prototype.componentDidMount = function () {
            var emiter = this.context[contextProp];
            if (emiter) {
                emiter.on(this.onUpdate);
            }
        };
        Consumer.prototype.getContextValue = function () {
            var emiter = this.context[contextProp];
            return Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["isUndefined"])(emiter) ? defaultValue : emiter.value;
        };
        Consumer.prototype.render = function () {
            return onlyChild(this.props.children)(this.state.value);
        };
        Consumer.isContextConsumer = true;
        return Consumer;
    }(_component__WEBPACK_IMPORTED_MODULE_2__["default"]));
    return {
        Provider: Provider,
        Consumer: Consumer,
        _id: contextProp,
        _defaultValue: defaultValue,
    };
}


/***/ }),

/***/ "./src/nerv/create-element.ts":
/*!************************************!*\
  !*** ./src/nerv/create-element.ts ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _nerv_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/nerv/utils */ "./src/nerv/utils/index.ts");
/* harmony import */ var _nerv_shared__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/nerv/shared */ "./src/nerv/shared/index.ts");
/* harmony import */ var _vdom_h__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./vdom/h */ "./src/nerv/vdom/h.ts");
/* harmony import */ var _full_component__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./full-component */ "./src/nerv/full-component.ts");
/* harmony import */ var _current_owner__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./current-owner */ "./src/nerv/current-owner.ts");




// import StatelessComponent from './stateless-component'

function transformPropsForRealTag(type, props) {
    var newProps = {};
    for (var propName in props) {
        var propValue = props[propName];
        if (propName === 'defaultValue') {
            newProps.value = props.value || props.defaultValue;
            continue;
        }
        // const svgPropName = SVGPropertyConfig.DOMAttributeNames[propName];
        // if (svgPropName && svgPropName !== propName) {
        //   newProps[svgPropName] = propValue;
        //   continue;
        // }
        newProps[propName] = propValue;
    }
    return newProps;
}
/**
 *
 * @param props
 * @param defaultProps
 * defaultProps should respect null but ignore undefined
 * @see: https://facebook.github.io/react/docs/react-component.html#defaultprops
 */
function transformPropsForComponent(props, defaultProps) {
    var newProps = {};
    for (var propName in props) {
        var propValue = props[propName];
        newProps[propName] = propValue;
    }
    if (defaultProps) {
        for (var propName in defaultProps) {
            if (Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["isUndefined"])(newProps[propName])) {
                newProps[propName] = defaultProps[propName];
            }
        }
    }
    return newProps;
}
function createElement(type, properties) {
    var _children = [];
    for (var _i = 2; _i < arguments.length; _i++) {
        _children[_i - 2] = arguments[_i];
    }
    var children = _children;
    if (_children) {
        if (_children.length === 1) {
            children = _children[0];
        }
        else if (_children.length === 0) {
            children = undefined;
        }
    }
    var props;
    if (Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["isString"])(type)) {
        props = transformPropsForRealTag(type, properties);
        props.owner = _current_owner__WEBPACK_IMPORTED_MODULE_4__["default"].current;
        return Object(_vdom_h__WEBPACK_IMPORTED_MODULE_2__["default"])(type, props, children);
    }
    else if (Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["isFunction"])(type)) {
        props = transformPropsForComponent(properties, type.defaultProps);
        if (!props.children || props.children === _nerv_shared__WEBPACK_IMPORTED_MODULE_1__["EMPTY_CHILDREN"]) {
            props.children = children || children === 0 ? children : _nerv_shared__WEBPACK_IMPORTED_MODULE_1__["EMPTY_CHILDREN"];
        }
        props.owner = _current_owner__WEBPACK_IMPORTED_MODULE_4__["default"].current;
        return new _full_component__WEBPACK_IMPORTED_MODULE_3__["default"](type, props);
    }
    return type;
}
/* harmony default export */ __webpack_exports__["default"] = (createElement);


/***/ }),

/***/ "./src/nerv/create-ref.ts":
/*!********************************!*\
  !*** ./src/nerv/create-ref.ts ***!
  \********************************/
/*! exports provided: createRef, forwardRef */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createRef", function() { return createRef; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forwardRef", function() { return forwardRef; });
function createRef() {
    return {};
}
function forwardRef(cb) {
    var fn = function (props) {
        var ref = props.ref;
        delete props.ref;
        return cb(props, ref);
    };
    fn._forwarded = true;
    return fn;
}


/***/ }),

/***/ "./src/nerv/current-owner.ts":
/*!***********************************!*\
  !*** ./src/nerv/current-owner.ts ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var Current = {
    current: null,
    index: 0
};
/* harmony default export */ __webpack_exports__["default"] = (Current);


/***/ }),

/***/ "./src/nerv/dom.ts":
/*!*************************!*\
  !*** ./src/nerv/dom.ts ***!
  \*************************/
/*! exports provided: unmountComponentAtNode, findDOMNode, createFactory, unstable_renderSubtreeIntoContainer, isValidElement, unstable_batchedUpdates */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unmountComponentAtNode", function() { return unmountComponentAtNode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "findDOMNode", function() { return findDOMNode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createFactory", function() { return createFactory; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unstable_renderSubtreeIntoContainer", function() { return unstable_renderSubtreeIntoContainer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isValidElement", function() { return isValidElement; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unstable_batchedUpdates", function() { return unstable_batchedUpdates; });
/* harmony import */ var _nerv_shared__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/nerv/shared */ "./src/nerv/shared/index.ts");
/* harmony import */ var _nerv_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/nerv/utils */ "./src/nerv/utils/index.ts");
/* harmony import */ var _lifecycle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lifecycle */ "./src/nerv/lifecycle.ts");
/* harmony import */ var _render__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./render */ "./src/nerv/render.ts");
/* harmony import */ var _vdom_unmount__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./vdom/unmount */ "./src/nerv/vdom/unmount.ts");
/* harmony import */ var _create_element__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./create-element */ "./src/nerv/create-element.ts");
/* harmony import */ var _component__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./component */ "./src/nerv/component.ts");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();







function unmountComponentAtNode(dom) {
    var component = dom._component;
    if (Object(_nerv_shared__WEBPACK_IMPORTED_MODULE_0__["isValidElement"])(component)) {
        Object(_vdom_unmount__WEBPACK_IMPORTED_MODULE_4__["unmount"])(component, dom);
        delete dom._component;
        return true;
    }
    return false;
}
function findDOMNode(component) {
    if (Object(_nerv_shared__WEBPACK_IMPORTED_MODULE_0__["isInvalid"])(component)) {
        return null;
    }
    return Object(_nerv_shared__WEBPACK_IMPORTED_MODULE_0__["isComponent"])(component)
        ? component.vnode.dom
        : Object(_nerv_shared__WEBPACK_IMPORTED_MODULE_0__["isValidElement"])(component)
            ? component.dom : component;
}
function createFactory(type) {
    return _create_element__WEBPACK_IMPORTED_MODULE_5__["default"].bind(null, type);
}
var WrapperComponent = /** @class */ (function (_super) {
    __extends(WrapperComponent, _super);
    function WrapperComponent() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    WrapperComponent.prototype.getChildContext = function () {
        // tslint:disable-next-line
        return this.props.context;
    };
    WrapperComponent.prototype.render = function () {
        return this.props.children;
    };
    return WrapperComponent;
}(_component__WEBPACK_IMPORTED_MODULE_6__["default"]));
function unstable_renderSubtreeIntoContainer(parentComponent, vnode, container, callback) {
    // @TODO: should handle props.context?
    var wrapper = Object(_create_element__WEBPACK_IMPORTED_MODULE_5__["default"])(WrapperComponent, { context: Object(_lifecycle__WEBPACK_IMPORTED_MODULE_2__["getChildContext"])(parentComponent, parentComponent.context) }, vnode);
    var rendered = Object(_render__WEBPACK_IMPORTED_MODULE_3__["render"])(wrapper, container);
    if (callback) {
        callback.call(rendered);
    }
    return rendered;
}
function isValidElement(element) {
    return (Object(_nerv_shared__WEBPACK_IMPORTED_MODULE_0__["isValidElement"])(element) && (element.vtype & (4 /* Composite */ | 2 /* Node */)) > 0);
}
var unstable_batchedUpdates = _nerv_utils__WEBPACK_IMPORTED_MODULE_1__["nextTick"];


/***/ }),

/***/ "./src/nerv/emiter.ts":
/*!****************************!*\
  !*** ./src/nerv/emiter.ts ***!
  \****************************/
/*! exports provided: Emiter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Emiter", function() { return Emiter; });
var Emiter = /** @class */ (function () {
    function Emiter(value) {
        this.handlers = [];
        this.value = value;
    }
    Emiter.prototype.on = function (handler) {
        this.handlers.push(handler);
    };
    Emiter.prototype.off = function (handler) {
        this.handlers = this.handlers.filter(function (h) { return h !== handler; });
    };
    Emiter.prototype.set = function (value) {
        var _this = this;
        this.value = value;
        this.handlers.forEach(function (h) { return h(_this.value); });
    };
    return Emiter;
}());



/***/ }),

/***/ "./src/nerv/event.ts":
/*!***************************!*\
  !*** ./src/nerv/event.ts ***!
  \***************************/
/*! exports provided: attachEvent, detachEvent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "attachEvent", function() { return attachEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "detachEvent", function() { return detachEvent; });
/* harmony import */ var _nerv_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/nerv/utils */ "./src/nerv/utils/index.ts");
/* harmony import */ var _nerv_shared__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/nerv/shared */ "./src/nerv/shared/index.ts");
/* harmony import */ var _utils_addListenerToElement__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/utils/addListenerToElement */ "./src/utils/addListenerToElement.js");



var ONINPUT = 'oninput';
var ONPROPERTYCHANGE = 'onpropertychange';
var bindFocus = false;
if (typeof Event !== 'undefined' && !Event.prototype.persist) {
    // tslint:disable-next-line:no-empty
    Event.prototype.persist = _nerv_shared__WEBPACK_IMPORTED_MODULE_1__["noop"];
}
function attachEvent(domNode, eventName, handler) {
    eventName = fixEvent(domNode, eventName);
    /* istanbul ignore next */
    if (eventName === ONPROPERTYCHANGE) {
        processOnPropertyChangeEvent(domNode, handler);
        return;
    }
    Object(_utils_addListenerToElement__WEBPACK_IMPORTED_MODULE_2__["default"])(domNode, eventName, handler);
}
function detachEvent(domNode, eventName, handler) {
    eventName = fixEvent(domNode, eventName);
    if (eventName === ONPROPERTYCHANGE) {
        return;
    }
    Object(_utils_addListenerToElement__WEBPACK_IMPORTED_MODULE_2__["removeListenerToElement"])(domNode, eventName, handler);
}
var propertyChangeActiveElement;
var propertyChangeActiveElementValue;
var propertyChangeActiveElementValueProp;
var propertyChangeActiveHandlers = {};
/* istanbul ignore next */
function propertyChangeHandler(event) {
    if (event.propertyName !== 'value') {
        return;
    }
    var target = event.target || event.srcElement;
    var val = target.value;
    if (val === propertyChangeActiveElementValue) {
        return;
    }
    propertyChangeActiveElementValue = val;
    var handler = propertyChangeActiveHandlers[target.name];
    if (Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["isFunction"])(handler)) {
        handler.call(target, event);
    }
}
/* istanbul ignore next */
function processOnPropertyChangeEvent(node, handler) {
    propertyChangeActiveHandlers[node.name] = handler;
    if (!bindFocus) {
        // bindFocus = true
        node.addEventListener('focusin', function () {
            unbindOnPropertyChange();
            bindOnPropertyChange(node);
        }, false);
        node.addEventListener('focusout', unbindOnPropertyChange, false);
    }
}
/* istanbul ignore next */
function bindOnPropertyChange(node) {
    propertyChangeActiveElement = node;
    propertyChangeActiveElementValue = node.value;
    propertyChangeActiveElementValueProp = Object.getOwnPropertyDescriptor(node.constructor.prototype, 'value');
    Object.defineProperty(propertyChangeActiveElement, 'value', {
        get: function () {
            return propertyChangeActiveElementValueProp.get.call(this);
        },
        set: function (val) {
            propertyChangeActiveElementValue = val;
            propertyChangeActiveElementValueProp.set.call(this, val);
        },
    });
    propertyChangeActiveElement.addEventListener('propertychange', propertyChangeHandler, false);
}
/* istanbul ignore next */
function unbindOnPropertyChange() {
    if (!propertyChangeActiveElement) {
        return;
    }
    delete propertyChangeActiveElement.value;
    propertyChangeActiveElement.removeEventListener('propertychange', propertyChangeHandler, false);
    propertyChangeActiveElement = null;
    propertyChangeActiveElementValue = null;
    propertyChangeActiveElementValueProp = null;
}
function detectCanUseOnInputNode(node) {
    var nodeName = node.nodeName && node.nodeName.toLowerCase();
    var type = node.type;
    return ((nodeName === 'input' && /text|password/.test(type))
        || nodeName === 'textarea');
}
function fixEvent(node, eventName) {
    if (eventName === 'onDoubleClick') {
        eventName = 'ondblclick';
    }
    else if (eventName === 'onTouchTap') {
        eventName = 'onclick';
        // tslint:disable-next-line:prefer-conditional-expression
    }
    else if (eventName === 'onChange' && detectCanUseOnInputNode(node)) {
        eventName = ONINPUT in window ? ONINPUT : ONPROPERTYCHANGE;
    }
    else {
        eventName = eventName.toLowerCase();
    }
    return eventName;
}


/***/ }),

/***/ "./src/nerv/fragment.ts":
/*!******************************!*\
  !*** ./src/nerv/fragment.ts ***!
  \******************************/
/*! exports provided: Fragment */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Fragment", function() { return Fragment; });
function Fragment(props) {
    return props.children;
}


/***/ }),

/***/ "./src/nerv/full-component.ts":
/*!************************************!*\
  !*** ./src/nerv/full-component.ts ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _nerv_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/nerv/utils */ "./src/nerv/utils/index.ts");
/* harmony import */ var _lifecycle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lifecycle */ "./src/nerv/lifecycle.ts");
/* harmony import */ var _options__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./options */ "./src/nerv/options.ts");



var ComponentWrapper = /** @class */ (function () {
    function ComponentWrapper(type, props) {
        this.vtype = 4 /* Composite */;
        this.type = type;
        this.name = type.name;
        if (Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["isUndefined"])(this.name)) {
            var names = type.toString().match(/^function\s*([^\s(]+)/);
            this.name = Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["isArray"])(names) ? names[0] : 'Component';
        }
        type.displayName = this.name;
        this._owner = props.owner;
        delete props.owner;
        if ((this.ref = props.ref)) {
            delete props.ref;
        }
        if (type._forwarded) {
            if (!Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["isUndefined"])(this.ref)) {
                props.ref = this.ref;
            }
            delete this.ref;
        }
        this.props = props;
        this.key = props.key || null;
        this.dom = null;
        _options__WEBPACK_IMPORTED_MODULE_2__["default"].afterCreate(this);
    }
    ComponentWrapper.prototype.init = function (parentContext, parentComponent) {
        _options__WEBPACK_IMPORTED_MODULE_2__["default"].beforeMount(this);
        var dom = Object(_lifecycle__WEBPACK_IMPORTED_MODULE_1__["mountComponent"])(this, parentContext, parentComponent);
        _options__WEBPACK_IMPORTED_MODULE_2__["default"].afterMount(this);
        return dom;
    };
    ComponentWrapper.prototype.update = function (previous, current, parentContext, domNode) {
        this.context = Object(_lifecycle__WEBPACK_IMPORTED_MODULE_1__["getContextByContextType"])(this, parentContext);
        _options__WEBPACK_IMPORTED_MODULE_2__["default"].beforeUpdate(this);
        var dom = Object(_lifecycle__WEBPACK_IMPORTED_MODULE_1__["reRenderComponent"])(previous, this);
        _options__WEBPACK_IMPORTED_MODULE_2__["default"].afterUpdate(this);
        return dom;
    };
    ComponentWrapper.prototype.destroy = function () {
        _options__WEBPACK_IMPORTED_MODULE_2__["default"].beforeUnmount(this);
        Object(_lifecycle__WEBPACK_IMPORTED_MODULE_1__["unmountComponent"])(this);
    };
    return ComponentWrapper;
}());
/* harmony default export */ __webpack_exports__["default"] = (ComponentWrapper);


/***/ }),

/***/ "./src/nerv/hooks.ts":
/*!***************************!*\
  !*** ./src/nerv/hooks.ts ***!
  \***************************/
/*! exports provided: getHooks, useState, useReducer, invokeEffects, useEffect, useLayoutEffect, useRef, useMemo, useCallback, useContext, useImperativeHandle */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getHooks", function() { return getHooks; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useState", function() { return useState; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useReducer", function() { return useReducer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "invokeEffects", function() { return invokeEffects; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useEffect", function() { return useEffect; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useLayoutEffect", function() { return useLayoutEffect; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useRef", function() { return useRef; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useMemo", function() { return useMemo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useCallback", function() { return useCallback; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useContext", function() { return useContext; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useImperativeHandle", function() { return useImperativeHandle; });
/* harmony import */ var _nerv_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/nerv/utils */ "./src/nerv/utils/index.ts");
/* harmony import */ var _nerv_shared__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/nerv/shared */ "./src/nerv/shared/index.ts");
/* harmony import */ var _current_owner__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./current-owner */ "./src/nerv/current-owner.ts");
/* harmony import */ var _render_queue__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./render-queue */ "./src/nerv/render-queue.ts");




function getHooks(index) {
    if (_current_owner__WEBPACK_IMPORTED_MODULE_2__["default"].current === null) {
        throw new Error('invalid hooks call: hooks can only be called in a stateless component.');
    }
    var hooks = _current_owner__WEBPACK_IMPORTED_MODULE_2__["default"].current.hooks;
    if (index >= hooks.length) {
        hooks.push({});
    }
    return hooks[index];
}
function useState(initialState) {
    if (Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["isFunction"])(initialState)) {
        initialState = initialState();
    }
    var hook = getHooks(_current_owner__WEBPACK_IMPORTED_MODULE_2__["default"].index++);
    if (!hook.state) {
        hook.component = _current_owner__WEBPACK_IMPORTED_MODULE_2__["default"].current;
        hook.state = [
            initialState,
            function (action) {
                hook.state[0] = Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["isFunction"])(action) ? action(hook.state[0]) : action;
                hook.component._disable = false;
                hook.component.setState({});
            },
        ];
    }
    return hook.state;
}
function useReducer(reducer, initialState, initializer) {
    if (Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["isFunction"])(initialState)) {
        initialState = initialState();
    }
    var hook = getHooks(_current_owner__WEBPACK_IMPORTED_MODULE_2__["default"].index++);
    if (!hook.state) {
        hook.component = _current_owner__WEBPACK_IMPORTED_MODULE_2__["default"].current;
        hook.state = [
            Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["isUndefined"])(initializer) ? initialState : initializer(initialState),
            function (action) {
                hook.state[0] = reducer(hook.state[0], action);
                hook.component._disable = false;
                hook.component.setState({});
            },
        ];
    }
    return hook.state;
}
function areDepsChanged(prevDeps, deps) {
    if (Object(_nerv_shared__WEBPACK_IMPORTED_MODULE_1__["isNullOrUndef"])(prevDeps) || Object(_nerv_shared__WEBPACK_IMPORTED_MODULE_1__["isNullOrUndef"])(deps)) {
        return true;
    }
    return deps.some(function (d, i) { return !Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["objectIs"])(d, prevDeps[i]); });
}
function invokeEffects(component, delay) {
    if (delay === void 0) { delay = false; }
    var effects = delay ? component.effects : component.layoutEffects;
    (effects || []).forEach(function (hook) {
        if (Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["isFunction"])(hook.cleanup)) {
            hook.cleanup();
        }
        var result = hook.effect();
        if (Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["isFunction"])(result)) {
            hook.cleanup = result;
        }
    });
    if (delay) {
        component.effects = [];
    }
    else {
        component.layoutEffects = [];
    }
}
var scheduleEffectComponents = [];
function invokeScheduleEffects(component) {
    if (!component._afterScheduleEffect) {
        component._afterScheduleEffect = true;
        scheduleEffectComponents.push(component);
        if (scheduleEffectComponents.length === 1) {
            Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["nextTick"])(function () {
                setTimeout(function () {
                    scheduleEffectComponents.forEach(function (c) {
                        c._afterScheduleEffect = false;
                        invokeEffects(c, true);
                    });
                    scheduleEffectComponents = [];
                }, 0);
            });
        }
    }
}
function useEffectImpl(effect, deps, delay) {
    if (delay === void 0) { delay = false; }
    var hook = getHooks(_current_owner__WEBPACK_IMPORTED_MODULE_2__["default"].index++);
    if (areDepsChanged(hook.deps, deps)) {
        hook.effect = effect;
        hook.deps = deps;
        if (delay) {
            _current_owner__WEBPACK_IMPORTED_MODULE_2__["default"].current.effects = _current_owner__WEBPACK_IMPORTED_MODULE_2__["default"].current.effects.concat(hook);
            invokeScheduleEffects(_current_owner__WEBPACK_IMPORTED_MODULE_2__["default"].current);
        }
        else {
            _current_owner__WEBPACK_IMPORTED_MODULE_2__["default"].current.layoutEffects = _current_owner__WEBPACK_IMPORTED_MODULE_2__["default"].current.layoutEffects.concat(hook);
        }
    }
}
function useEffect(effect, deps) {
    useEffectImpl(effect, deps, true);
}
function useLayoutEffect(effect, deps) {
    useEffectImpl(effect, deps);
}
function useRef(initialValue) {
    var hook = getHooks(_current_owner__WEBPACK_IMPORTED_MODULE_2__["default"].index++);
    if (!hook.ref) {
        hook.ref = {
            current: initialValue,
        };
    }
    return hook.ref;
}
function useMemo(factory, deps) {
    var hook = getHooks(_current_owner__WEBPACK_IMPORTED_MODULE_2__["default"].index++);
    if (areDepsChanged(hook.deps, deps)) {
        hook.deps = deps;
        hook.callback = factory;
        hook.value = factory();
    }
    return hook.value;
}
function useCallback(callback, deps) {
    return useMemo(function () { return callback; }, deps);
}
function useContext(context) {
    var provider = _current_owner__WEBPACK_IMPORTED_MODULE_2__["default"].current.context[context._id];
    if (Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["isUndefined"])(provider)) {
        return context._defaultValue;
    }
    var hook = getHooks(_current_owner__WEBPACK_IMPORTED_MODULE_2__["default"].index++);
    // should update when value changes with shouldComponentUpdate:false Component on top
    if (Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["isUndefined"])(hook.context)) {
        hook.context = true;
        var c_1 = _current_owner__WEBPACK_IMPORTED_MODULE_2__["default"].current;
        provider.on(function () { return Object(_render_queue__WEBPACK_IMPORTED_MODULE_3__["enqueueRender"])(c_1); });
    }
    return provider.value;
}
function useImperativeHandle(ref, init, deps) {
    useLayoutEffect(function () {
        if (Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["isFunction"])(ref)) {
            ref(init());
            return function () { return ref(null); };
        }
        else if (!Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["isUndefined"])(ref)) {
            ref.current = init();
            return function () {
                delete ref.current;
            };
        }
    }, Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["isArray"])(deps) ? deps.concat([ref]) : undefined);
}


/***/ }),

/***/ "./src/nerv/hydrate.ts":
/*!*****************************!*\
  !*** ./src/nerv/hydrate.ts ***!
  \*****************************/
/*! exports provided: hydrate */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hydrate", function() { return hydrate; });
/* harmony import */ var _render__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./render */ "./src/nerv/render.ts");
// tslint:disable:no-conditional-assignment

function hydrate(vnode, container, callback) {
    if (container !== null) {
        // lastChild causes less reflow than firstChild
        var dom = container.lastChild;
        // there should be only a single entry for the root
        while (dom) {
            var next = dom.previousSibling;
            container.removeChild(dom);
            dom = next;
        }
        return Object(_render__WEBPACK_IMPORTED_MODULE_0__["render"])(vnode, container, callback);
    }
}


/***/ }),

/***/ "./src/nerv/index.ts":
/*!***************************!*\
  !*** ./src/nerv/index.ts ***!
  \***************************/
/*! exports provided: createNervClass, Children, Component, PureComponent, createElement, cloneElement, render, nextTick, options, findDOMNode, isValidElement, unmountComponentAtNode, createPortal, unstable_renderSubtreeIntoContainer, hydrate, createFactory, unstable_batchedUpdates, version, PropTypes, createRef, forwardRef, memo, createContext, renderComponent, getHooks, Current, Fragment, useEffect, useLayoutEffect, useReducer, useState, useRef, useCallback, useMemo, useImperativeHandle, useContext, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _nerv_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/nerv/utils */ "./src/nerv/utils/index.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "nextTick", function() { return _nerv_utils__WEBPACK_IMPORTED_MODULE_0__["nextTick"]; });

/* harmony import */ var _component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./component */ "./src/nerv/component.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Component", function() { return _component__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _pure_component__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./pure-component */ "./src/nerv/pure-component.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PureComponent", function() { return _pure_component__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _render__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./render */ "./src/nerv/render.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "render", function() { return _render__WEBPACK_IMPORTED_MODULE_3__["render"]; });

/* harmony import */ var _create_element__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./create-element */ "./src/nerv/create-element.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createElement", function() { return _create_element__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _clone_element__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./clone-element */ "./src/nerv/clone-element.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "cloneElement", function() { return _clone_element__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony import */ var _children__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./children */ "./src/nerv/children.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Children", function() { return _children__WEBPACK_IMPORTED_MODULE_6__["Children"]; });

/* harmony import */ var _hydrate__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./hydrate */ "./src/nerv/hydrate.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "hydrate", function() { return _hydrate__WEBPACK_IMPORTED_MODULE_7__["hydrate"]; });

/* harmony import */ var _options__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./options */ "./src/nerv/options.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "options", function() { return _options__WEBPACK_IMPORTED_MODULE_8__["default"]; });

/* harmony import */ var _vdom_create_portal__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./vdom/create-portal */ "./src/nerv/vdom/create-portal.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createPortal", function() { return _vdom_create_portal__WEBPACK_IMPORTED_MODULE_9__["createPortal"]; });

/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./version */ "./src/nerv/version.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "version", function() { return _version__WEBPACK_IMPORTED_MODULE_10__["version"]; });

/* harmony import */ var _dom__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./dom */ "./src/nerv/dom.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "findDOMNode", function() { return _dom__WEBPACK_IMPORTED_MODULE_11__["findDOMNode"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isValidElement", function() { return _dom__WEBPACK_IMPORTED_MODULE_11__["isValidElement"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "unmountComponentAtNode", function() { return _dom__WEBPACK_IMPORTED_MODULE_11__["unmountComponentAtNode"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "unstable_renderSubtreeIntoContainer", function() { return _dom__WEBPACK_IMPORTED_MODULE_11__["unstable_renderSubtreeIntoContainer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createFactory", function() { return _dom__WEBPACK_IMPORTED_MODULE_11__["createFactory"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "unstable_batchedUpdates", function() { return _dom__WEBPACK_IMPORTED_MODULE_11__["unstable_batchedUpdates"]; });

/* harmony import */ var _prop_types__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./prop-types */ "./src/nerv/prop-types.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PropTypes", function() { return _prop_types__WEBPACK_IMPORTED_MODULE_12__["PropTypes"]; });

/* harmony import */ var _hooks__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./hooks */ "./src/nerv/hooks.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getHooks", function() { return _hooks__WEBPACK_IMPORTED_MODULE_13__["getHooks"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "useEffect", function() { return _hooks__WEBPACK_IMPORTED_MODULE_13__["useEffect"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "useLayoutEffect", function() { return _hooks__WEBPACK_IMPORTED_MODULE_13__["useLayoutEffect"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "useReducer", function() { return _hooks__WEBPACK_IMPORTED_MODULE_13__["useReducer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "useState", function() { return _hooks__WEBPACK_IMPORTED_MODULE_13__["useState"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "useRef", function() { return _hooks__WEBPACK_IMPORTED_MODULE_13__["useRef"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "useCallback", function() { return _hooks__WEBPACK_IMPORTED_MODULE_13__["useCallback"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "useMemo", function() { return _hooks__WEBPACK_IMPORTED_MODULE_13__["useMemo"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "useImperativeHandle", function() { return _hooks__WEBPACK_IMPORTED_MODULE_13__["useImperativeHandle"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "useContext", function() { return _hooks__WEBPACK_IMPORTED_MODULE_13__["useContext"]; });

/* harmony import */ var _create_ref__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./create-ref */ "./src/nerv/create-ref.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createRef", function() { return _create_ref__WEBPACK_IMPORTED_MODULE_14__["createRef"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "forwardRef", function() { return _create_ref__WEBPACK_IMPORTED_MODULE_14__["forwardRef"]; });

/* harmony import */ var _memo__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./memo */ "./src/nerv/memo.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "memo", function() { return _memo__WEBPACK_IMPORTED_MODULE_15__["memo"]; });

/* harmony import */ var _create_context__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./create-context */ "./src/nerv/create-context.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createContext", function() { return _create_context__WEBPACK_IMPORTED_MODULE_16__["createContext"]; });

/* harmony import */ var _lifecycle__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./lifecycle */ "./src/nerv/lifecycle.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "renderComponent", function() { return _lifecycle__WEBPACK_IMPORTED_MODULE_17__["renderComponent"]; });

/* harmony import */ var _current_owner__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./current-owner */ "./src/nerv/current-owner.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Current", function() { return _current_owner__WEBPACK_IMPORTED_MODULE_18__["default"]; });

/* harmony import */ var _fragment__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./fragment */ "./src/nerv/fragment.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Fragment", function() { return _fragment__WEBPACK_IMPORTED_MODULE_19__["Fragment"]; });

/* harmony import */ var _create_class__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./create-class */ "./src/nerv/create-class.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createNervClass", function() { return _create_class__WEBPACK_IMPORTED_MODULE_20__["default"]; });













 // for React 15- compat
// tslint:disable-next-line: max-line-length









/* harmony default export */ __webpack_exports__["default"] = ({
    createNervClass: _create_class__WEBPACK_IMPORTED_MODULE_20__["default"],
    Children: _children__WEBPACK_IMPORTED_MODULE_6__["Children"],
    Component: _component__WEBPACK_IMPORTED_MODULE_1__["default"],
    PureComponent: _pure_component__WEBPACK_IMPORTED_MODULE_2__["default"],
    createElement: _create_element__WEBPACK_IMPORTED_MODULE_4__["default"],
    cloneElement: _clone_element__WEBPACK_IMPORTED_MODULE_5__["default"],
    render: _render__WEBPACK_IMPORTED_MODULE_3__["render"],
    nextTick: _nerv_utils__WEBPACK_IMPORTED_MODULE_0__["nextTick"],
    options: _options__WEBPACK_IMPORTED_MODULE_8__["default"],
    findDOMNode: _dom__WEBPACK_IMPORTED_MODULE_11__["findDOMNode"],
    isValidElement: _dom__WEBPACK_IMPORTED_MODULE_11__["isValidElement"],
    unmountComponentAtNode: _dom__WEBPACK_IMPORTED_MODULE_11__["unmountComponentAtNode"],
    createPortal: _vdom_create_portal__WEBPACK_IMPORTED_MODULE_9__["createPortal"],
    unstable_renderSubtreeIntoContainer: _dom__WEBPACK_IMPORTED_MODULE_11__["unstable_renderSubtreeIntoContainer"],
    hydrate: _hydrate__WEBPACK_IMPORTED_MODULE_7__["hydrate"],
    createFactory: _dom__WEBPACK_IMPORTED_MODULE_11__["createFactory"],
    unstable_batchedUpdates: _dom__WEBPACK_IMPORTED_MODULE_11__["unstable_batchedUpdates"],
    version: _version__WEBPACK_IMPORTED_MODULE_10__["version"],
    PropTypes: _prop_types__WEBPACK_IMPORTED_MODULE_12__["PropTypes"],
    createRef: _create_ref__WEBPACK_IMPORTED_MODULE_14__["createRef"],
    forwardRef: _create_ref__WEBPACK_IMPORTED_MODULE_14__["forwardRef"],
    memo: _memo__WEBPACK_IMPORTED_MODULE_15__["memo"],
    createContext: _create_context__WEBPACK_IMPORTED_MODULE_16__["createContext"],
    renderComponent: _lifecycle__WEBPACK_IMPORTED_MODULE_17__["renderComponent"],
    getHooks: _hooks__WEBPACK_IMPORTED_MODULE_13__["getHooks"],
    Current: _current_owner__WEBPACK_IMPORTED_MODULE_18__["default"],
    useEffect: _hooks__WEBPACK_IMPORTED_MODULE_13__["useEffect"],
    useLayoutEffect: _hooks__WEBPACK_IMPORTED_MODULE_13__["useLayoutEffect"],
    useReducer: _hooks__WEBPACK_IMPORTED_MODULE_13__["useReducer"],
    useState: _hooks__WEBPACK_IMPORTED_MODULE_13__["useState"],
    useRef: _hooks__WEBPACK_IMPORTED_MODULE_13__["useRef"],
    useCallback: _hooks__WEBPACK_IMPORTED_MODULE_13__["useCallback"],
    useMemo: _hooks__WEBPACK_IMPORTED_MODULE_13__["useMemo"],
    useImperativeHandle: _hooks__WEBPACK_IMPORTED_MODULE_13__["useImperativeHandle"],
    useContext: _hooks__WEBPACK_IMPORTED_MODULE_13__["useContext"],
    Fragment: _fragment__WEBPACK_IMPORTED_MODULE_19__["Fragment"],
});


/***/ }),

/***/ "./src/nerv/lifecycle.ts":
/*!*******************************!*\
  !*** ./src/nerv/lifecycle.ts ***!
  \*******************************/
/*! exports provided: errorCatcher, ensureVirtualNode, mountVNode, getContextByContextType, mountComponent, getChildContext, renderComponent, flushMount, reRenderComponent, updateComponent, unmountComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "errorCatcher", function() { return errorCatcher; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ensureVirtualNode", function() { return ensureVirtualNode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mountVNode", function() { return mountVNode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getContextByContextType", function() { return getContextByContextType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mountComponent", function() { return mountComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getChildContext", function() { return getChildContext; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "renderComponent", function() { return renderComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "flushMount", function() { return flushMount; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reRenderComponent", function() { return reRenderComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "updateComponent", function() { return updateComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unmountComponent", function() { return unmountComponent; });
/* harmony import */ var _nerv_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/nerv/utils */ "./src/nerv/utils/index.ts");
/* harmony import */ var _nerv_shared__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/nerv/shared */ "./src/nerv/shared/index.ts");
/* harmony import */ var _current_owner__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./current-owner */ "./src/nerv/current-owner.ts");
/* harmony import */ var _vdom_create_element__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./vdom/create-element */ "./src/nerv/vdom/create-element.ts");
/* harmony import */ var _vdom_create_vtext__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./vdom/create-vtext */ "./src/nerv/vdom/create-vtext.ts");
/* harmony import */ var _vdom_create_void__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./vdom/create-void */ "./src/nerv/vdom/create-void.ts");
/* harmony import */ var _vdom_patch__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./vdom/patch */ "./src/nerv/vdom/patch.ts");
/* harmony import */ var _vdom_unmount__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./vdom/unmount */ "./src/nerv/vdom/unmount.ts");
/* harmony import */ var _vdom_ref__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./vdom/ref */ "./src/nerv/vdom/ref.ts");
/* harmony import */ var _component__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./component */ "./src/nerv/component.ts");
/* harmony import */ var _hooks__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./hooks */ "./src/nerv/hooks.ts");
// import { extend, isFunction, isNumber, isString } from '@/nerv/utils'











var readyComponents = [];
function errorCatcher(fn, component) {
    try {
        return fn();
    }
    catch (error) {
        errorHandler(component, error);
    }
}
function errorHandler(component, error) {
    // if(!component) { throw error ; return }
    var boundary;
    while (true) {
        var getDerivedStateFromError = component.constructor.getDerivedStateFromError;
        if (Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["isFunction"])(getDerivedStateFromError) || Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["isFunction"])(component.componentDidCatch)) {
            boundary = component;
            break;
        }
        else if (component._parentComponent) {
            component = component._parentComponent;
        }
        else {
            break;
        }
    }
    if (boundary) {
        var getDerivedStateFromError = boundary.constructor.getDerivedStateFromError;
        var _disable = boundary._disable;
        boundary._disable = false;
        if (Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["isFunction"])(getDerivedStateFromError)) {
            component.setState(getDerivedStateFromError(error));
        }
        else if (Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["isFunction"])(component.componentDidCatch)) {
            boundary.componentDidCatch(error);
        }
        boundary._disable = _disable;
    }
    else {
        throw error;
    }
}
function ensureVirtualNode(rendered) {
    if (Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["isNumber"])(rendered) || Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["isString"])(rendered)) {
        return Object(_vdom_create_vtext__WEBPACK_IMPORTED_MODULE_4__["default"])(rendered);
    }
    else if (Object(_nerv_shared__WEBPACK_IMPORTED_MODULE_1__["isInvalid"])(rendered)) {
        return Object(_vdom_create_void__WEBPACK_IMPORTED_MODULE_5__["createVoid"])();
    }
    else if (Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["isArray"])(rendered)) {
        rendered = rendered.length === 0 ? Object(_vdom_create_void__WEBPACK_IMPORTED_MODULE_5__["createVoid"])() : rendered.map(ensureVirtualNode);
    }
    return rendered;
}
function mountVNode(vnode, parentContext, parentComponent) {
    return Object(_vdom_create_element__WEBPACK_IMPORTED_MODULE_3__["default"])(vnode, false, parentContext, parentComponent);
}
function getContextByContextType(vnode, parentContext) {
    var contextType = vnode.type.contextType;
    var hasContextType = !Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["isUndefined"])(contextType);
    var provider = hasContextType ? (parentContext[contextType._id]) : null;
    var context = hasContextType
        ? (!Object(_nerv_shared__WEBPACK_IMPORTED_MODULE_1__["isNullOrUndef"])(provider) ? provider.value : contextType._defaultValue)
        : parentContext;
    return context;
}
function mountComponent(vnode, parentContext, parentComponent) {
    var ref = vnode.ref;
    if (vnode.type.prototype && vnode.type.prototype.render) {
        var context = getContextByContextType(vnode, parentContext);
        vnode.component = new vnode.type(vnode.props, context);
    }
    else {
        var c_1 = new _component__WEBPACK_IMPORTED_MODULE_9__["default"](vnode.props, parentContext);
        c_1.render = function () { return vnode.type.call(c_1, c_1.props, c_1.context); };
        vnode.component = c_1;
    }
    var component = vnode.component;
    component.vnode = vnode;
    if (Object(_nerv_shared__WEBPACK_IMPORTED_MODULE_1__["isComponent"])(parentComponent)) {
        component._parentComponent = parentComponent;
    }
    var newState = callGetDerivedStateFromProps(vnode.props, component.state, component);
    if (!Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["isUndefined"])(newState)) {
        component.state = newState;
    }
    if (!hasNewLifecycle(component) && Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["isFunction"])(component.componentWillMount)) {
        errorCatcher(function () {
            component.componentWillMount();
        }, component);
        component.state = component.getState();
        component.clearCallBacks();
    }
    component._dirty = false;
    var rendered = renderComponent(component);
    rendered.parentVNode = vnode;
    component._rendered = rendered;
    if (!Object(_nerv_shared__WEBPACK_IMPORTED_MODULE_1__["isNullOrUndef"])(ref)) {
        _vdom_ref__WEBPACK_IMPORTED_MODULE_8__["default"].attach(vnode, ref, vnode.dom);
    }
    var dom = (vnode.dom = mountVNode(rendered, getChildContext(component, parentContext), component));
    Object(_hooks__WEBPACK_IMPORTED_MODULE_10__["invokeEffects"])(component);
    if (Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["isFunction"])(component.componentDidMount)) {
        readyComponents.push(component);
    }
    component._disable = false;
    return dom;
}
function getChildContext(component, context) {
    if (context === void 0) { context = _nerv_shared__WEBPACK_IMPORTED_MODULE_1__["EMPTY_OBJ"]; }
    if (Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["isFunction"])(component.getChildContext)) {
        return Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["extend"])(Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["clone"])(context), component.getChildContext());
    }
    return Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["clone"])(context);
}
function renderComponent(component) {
    _current_owner__WEBPACK_IMPORTED_MODULE_2__["default"].current = component;
    _current_owner__WEBPACK_IMPORTED_MODULE_2__["default"].index = 0;
    Object(_hooks__WEBPACK_IMPORTED_MODULE_10__["invokeEffects"])(component, true);
    var rendered;
    errorCatcher(function () {
        rendered = component.render();
    }, component);
    rendered = ensureVirtualNode(rendered);
    _current_owner__WEBPACK_IMPORTED_MODULE_2__["default"].current = null;
    return rendered;
}
function flushMount() {
    if (!readyComponents.length) {
        return;
    }
    // @TODO: perf
    var queue = readyComponents.slice(0);
    readyComponents.length = 0;
    queue.forEach(function (item) {
        if (Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["isFunction"])(item)) {
            item();
        }
        else if (item.componentDidMount) {
            errorCatcher(function () {
                item.componentDidMount();
            }, item);
        }
    });
}
function getFragmentHostNode(children) {
    var child = children[0];
    if (Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["isArray"])(child)) {
        return getFragmentHostNode(child);
    }
    else if (Object(_nerv_shared__WEBPACK_IMPORTED_MODULE_1__["isComposite"])(child) && child.dom == null) {
        return getFragmentHostNode(child.component._rendered);
    }
    return child != null ? child.dom : null;
}
function reRenderComponent(prev, current) {
    var component = (current.component = prev.component);
    var nextProps = current.props;
    var nextContext = current.context;
    component._disable = true;
    if (!hasNewLifecycle(component) && Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["isFunction"])(component.componentWillReceiveProps)) {
        errorCatcher(function () {
            component.componentWillReceiveProps(nextProps, nextContext);
        }, component);
    }
    component._disable = false;
    component.prevProps = component.props;
    component.prevState = component.state;
    component.prevContext = component.context;
    component.props = nextProps;
    component.context = nextContext;
    if (!Object(_nerv_shared__WEBPACK_IMPORTED_MODULE_1__["isNullOrUndef"])(current.ref)) {
        _vdom_ref__WEBPACK_IMPORTED_MODULE_8__["default"].update(prev, current);
    }
    return updateComponent(component);
}
function callShouldComponentUpdate(props, state, context, component) {
    var shouldUpdate = true;
    errorCatcher(function () {
        shouldUpdate = component.shouldComponentUpdate(props, state, context);
    }, component);
    return shouldUpdate;
}
function updateComponent(component, isForce) {
    if (isForce === void 0) { isForce = false; }
    var vnode = component.vnode;
    var dom = vnode.dom;
    var props = component.props;
    var state = component.getState();
    var context = component.context;
    var prevProps = component.prevProps || props;
    var prevState = component.prevState || component.state;
    var prevContext = component.prevContext || context;
    var stateFromProps = callGetDerivedStateFromProps(props, state, component);
    if (!Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["isUndefined"])(stateFromProps)) {
        state = stateFromProps;
    }
    component.props = prevProps;
    component.context = prevContext;
    var skip = false;
    var onSCU = props.onShouldComponentUpdate;
    if (!isForce
        && ((Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["isFunction"])(component.shouldComponentUpdate)
            && callShouldComponentUpdate(props, state, context, component) === false)
            || (Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["isFunction"])(onSCU) && onSCU(prevProps, props) === false))) {
        skip = true;
    }
    else if (!hasNewLifecycle(component) && Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["isFunction"])(component.componentWillUpdate)) {
        errorCatcher(function () {
            component.componentWillUpdate(props, state, context);
        }, component);
    }
    if (!Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["isUndefined"])(stateFromProps)) {
        component.state = stateFromProps;
    }
    component.props = props;
    component.state = state;
    component.context = context;
    component._dirty = false;
    if (!skip) {
        var lastRendered = component._rendered;
        var rendered = renderComponent(component);
        rendered.parentVNode = vnode;
        var childContext = getChildContext(component, context);
        var snapshot_1 = callGetSnapshotBeforeUpdate(prevProps, prevState, component);
        var parentDom = lastRendered.dom && lastRendered.dom.parentNode;
        if (Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["isArray"])(lastRendered)) {
            var hostNode = getFragmentHostNode(lastRendered);
            if (hostNode != null) {
                parentDom = lastRendered.dom = hostNode.parentNode;
            }
        }
        dom = vnode.dom = Object(_vdom_patch__WEBPACK_IMPORTED_MODULE_6__["default"])(lastRendered, rendered, parentDom || null, childContext);
        component._rendered = rendered;
        if (Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["isFunction"])(component.componentDidUpdate)) {
            errorCatcher(function () {
                component.componentDidUpdate(prevProps, prevState, snapshot_1);
            }, component);
        }
        while (vnode = vnode.parentVNode) {
            if ((vnode.vtype & (4 /* Composite */)) > 0) {
                vnode.dom = dom;
            }
        }
    }
    component.prevProps = component.props;
    component.prevState = component.state;
    component.prevContext = component.context;
    component.clearCallBacks();
    flushMount();
    Object(_hooks__WEBPACK_IMPORTED_MODULE_10__["invokeEffects"])(component);
    return dom;
}
function unmountComponent(vnode) {
    var component = vnode.component;
    component.hooks.forEach(function (hook) {
        if (Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["isFunction"])(hook.cleanup)) {
            hook.cleanup();
        }
    });
    if (Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["isFunction"])(component.componentWillUnmount)) {
        errorCatcher(function () {
            component.componentWillUnmount();
        }, component);
    }
    component._disable = true;
    Object(_vdom_unmount__WEBPACK_IMPORTED_MODULE_7__["unmount"])(component._rendered);
    if (!Object(_nerv_shared__WEBPACK_IMPORTED_MODULE_1__["isNullOrUndef"])(vnode.ref)) {
        _vdom_ref__WEBPACK_IMPORTED_MODULE_8__["default"].detach(vnode, vnode.ref, vnode.dom);
    }
}
function callGetDerivedStateFromProps(props, state, inst) {
    var getDerivedStateFromProps = inst.constructor.getDerivedStateFromProps;
    var newState;
    // @TODO show warning
    errorCatcher(function () {
        if (Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["isFunction"])(getDerivedStateFromProps)) {
            var partialState = getDerivedStateFromProps.call(null, props, state);
            if (!Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["isUndefined"])(partialState)) {
                newState = Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["extend"])(Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["clone"])(state), partialState);
            }
        }
    }, inst);
    return newState;
}
function callGetSnapshotBeforeUpdate(props, state, inst) {
    var getSnapshotBeforeUpdate = inst.getSnapshotBeforeUpdate;
    var snapshot;
    errorCatcher(function () {
        if (Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["isFunction"])(getSnapshotBeforeUpdate)) {
            snapshot = getSnapshotBeforeUpdate.call(inst, props, state);
        }
    }, inst);
    return snapshot;
}
function hasNewLifecycle(component) {
    if (Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["isFunction"])(component.constructor.getDerivedStateFromProps)) {
        return true;
    }
    return false;
}


/***/ }),

/***/ "./src/nerv/memo.ts":
/*!**************************!*\
  !*** ./src/nerv/memo.ts ***!
  \**************************/
/*! exports provided: memo */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "memo", function() { return memo; });
/* harmony import */ var _nerv_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/nerv/utils */ "./src/nerv/utils/index.ts");
/* harmony import */ var _vdom_ref__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./vdom/ref */ "./src/nerv/vdom/ref.ts");
/* harmony import */ var _create_element__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./create-element */ "./src/nerv/create-element.ts");
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};



function memo(component, propsAreEqual) {
    function shouldComponentUpdate(nextProps) {
        var prevRef = this.props.ref;
        var nextRef = nextProps.ref;
        if (prevRef !== nextRef) {
            _vdom_ref__WEBPACK_IMPORTED_MODULE_1__["default"].detach(this.vnode, prevRef, this.dom);
            _vdom_ref__WEBPACK_IMPORTED_MODULE_1__["default"].attach(this.vnode, nextRef, this.dom);
            return true;
        }
        return Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["isFunction"])(propsAreEqual) ? !propsAreEqual(this.props, nextProps) : !Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["shallowEqual"])(this.props, nextProps);
    }
    function Memoed(props) {
        this.shouldComponentUpdate = shouldComponentUpdate;
        return Object(_create_element__WEBPACK_IMPORTED_MODULE_2__["default"])(component, __assign({}, props));
    }
    Memoed._forwarded = true;
    Memoed.isMemo = true;
    return Memoed;
}


/***/ }),

/***/ "./src/nerv/options.ts":
/*!*****************************!*\
  !*** ./src/nerv/options.ts ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _nerv_shared__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/nerv/shared */ "./src/nerv/shared/index.ts");

var options = {
    afterMount: _nerv_shared__WEBPACK_IMPORTED_MODULE_0__["noop"],
    afterUpdate: _nerv_shared__WEBPACK_IMPORTED_MODULE_0__["noop"],
    beforeUpdate: _nerv_shared__WEBPACK_IMPORTED_MODULE_0__["noop"],
    beforeUnmount: _nerv_shared__WEBPACK_IMPORTED_MODULE_0__["noop"],
    beforeRender: _nerv_shared__WEBPACK_IMPORTED_MODULE_0__["noop"],
    beforeMount: _nerv_shared__WEBPACK_IMPORTED_MODULE_0__["noop"],
    afterCreate: _nerv_shared__WEBPACK_IMPORTED_MODULE_0__["noop"],
    roots: [],
    debug: false,
};
/* harmony default export */ __webpack_exports__["default"] = (options);


/***/ }),

/***/ "./src/nerv/prop-types.ts":
/*!********************************!*\
  !*** ./src/nerv/prop-types.ts ***!
  \********************************/
/*! exports provided: PropTypes */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PropTypes", function() { return PropTypes; });
/* harmony import */ var _nerv_shared__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/nerv/shared */ "./src/nerv/shared/index.ts");

var shim = _nerv_shared__WEBPACK_IMPORTED_MODULE_0__["noop"];
shim.isRequired = _nerv_shared__WEBPACK_IMPORTED_MODULE_0__["noop"];
function getShim() {
    return shim;
}
var PropTypes = {
    array: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    any: shim,
    arrayOf: getShim,
    element: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim,
    exact: getShim,
    PropTypes: {},
    checkPropTypes: _nerv_shared__WEBPACK_IMPORTED_MODULE_0__["noop"],
};
PropTypes.PropTypes = PropTypes;



/***/ }),

/***/ "./src/nerv/pure-component.ts":
/*!************************************!*\
  !*** ./src/nerv/pure-component.ts ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _nerv_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/nerv/utils */ "./src/nerv/utils/index.ts");
/* harmony import */ var _component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./component */ "./src/nerv/component.ts");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


var PureComponent = /** @class */ (function (_super) {
    __extends(PureComponent, _super);
    function PureComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.isPureComponent = true;
        return _this;
    }
    PureComponent.prototype.shouldComponentUpdate = function (nextProps, nextState) {
        return !Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["shallowEqual"])(this.props, nextProps) || !Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["shallowEqual"])(this.state, nextState);
    };
    return PureComponent;
}(_component__WEBPACK_IMPORTED_MODULE_1__["default"]));
/* harmony default export */ __webpack_exports__["default"] = (PureComponent);


/***/ }),

/***/ "./src/nerv/render-queue.ts":
/*!**********************************!*\
  !*** ./src/nerv/render-queue.ts ***!
  \**********************************/
/*! exports provided: enqueueRender, rerender */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "enqueueRender", function() { return enqueueRender; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rerender", function() { return rerender; });
/* harmony import */ var _nerv_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/nerv/utils */ "./src/nerv/utils/index.ts");
/* harmony import */ var _lifecycle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lifecycle */ "./src/nerv/lifecycle.ts");


var items = [];
function enqueueRender(component) {
    // tslint:disable-next-line:no-conditional-assignment
    if (!component._dirty && (component._dirty = true) && items.push(component) === 1) {
        Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["nextTick"])(rerender);
    }
}
function rerender(isForce) {
    if (isForce === void 0) { isForce = false; }
    var p;
    var list = items;
    items = [];
    // tslint:disable-next-line:no-conditional-assignment
    while ((p = list.pop())) {
        if (p._dirty) {
            Object(_lifecycle__WEBPACK_IMPORTED_MODULE_1__["updateComponent"])(p, isForce);
        }
    }
}


/***/ }),

/***/ "./src/nerv/render.ts":
/*!****************************!*\
  !*** ./src/nerv/render.ts ***!
  \****************************/
/*! exports provided: render */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "render", function() { return render; });
/* harmony import */ var _nerv_shared__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/nerv/shared */ "./src/nerv/shared/index.ts");
/* harmony import */ var _lifecycle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lifecycle */ "./src/nerv/lifecycle.ts");
/* harmony import */ var _vdom_patch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./vdom/patch */ "./src/nerv/vdom/patch.ts");
/* harmony import */ var _options__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./options */ "./src/nerv/options.ts");
/* harmony import */ var _vdom_create_element__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./vdom/create-element */ "./src/nerv/vdom/create-element.ts");





function render(vnode, container, callback) {
    if (!container) {
        throw new Error(container + " should be a DOM Element");
    }
    var lastVnode = container._component;
    var dom;
    _options__WEBPACK_IMPORTED_MODULE_3__["default"].roots.push(vnode);
    if (typeof lastVnode !== 'undefined') {
        _options__WEBPACK_IMPORTED_MODULE_3__["default"].roots = _options__WEBPACK_IMPORTED_MODULE_3__["default"].roots.filter(function (item) { return item !== lastVnode; });
        dom = Object(_vdom_patch__WEBPACK_IMPORTED_MODULE_2__["patch"])(lastVnode, vnode, container, {});
    }
    else {
        dom = Object(_lifecycle__WEBPACK_IMPORTED_MODULE_1__["mountVNode"])(vnode, {});
        Object(_vdom_create_element__WEBPACK_IMPORTED_MODULE_4__["mountElement"])(dom, container);
    }
    if (container) {
        container._component = vnode;
    }
    Object(_lifecycle__WEBPACK_IMPORTED_MODULE_1__["flushMount"])();
    if (callback) {
        callback();
    }
    return Object(_nerv_shared__WEBPACK_IMPORTED_MODULE_0__["isComposite"])(vnode) ? vnode.component : dom;
}


/***/ }),

/***/ "./src/nerv/shared/index.ts":
/*!**********************************!*\
  !*** ./src/nerv/shared/index.ts ***!
  \**********************************/
/*! exports provided: EMPTY_CHILDREN, EMPTY_OBJ, isNullOrUndef, isInvalid, isVNode, isVText, isComponent, isWidget, isPortal, isComposite, isValidElement, isHook, noop, VType */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EMPTY_CHILDREN", function() { return EMPTY_CHILDREN; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EMPTY_OBJ", function() { return EMPTY_OBJ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isNullOrUndef", function() { return isNullOrUndef; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isInvalid", function() { return isInvalid; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isVNode", function() { return isVNode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isVText", function() { return isVText; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isComponent", function() { return isComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isWidget", function() { return isWidget; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isPortal", function() { return isPortal; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isComposite", function() { return isComposite; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isValidElement", function() { return isValidElement; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isHook", function() { return isHook; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "noop", function() { return noop; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VType", function() { return VType; });
var EMPTY_CHILDREN = [];
var EMPTY_OBJ = {};
function isNullOrUndef(o) {
    return o === undefined || o === null;
}
function isInvalid(o) {
    return isNullOrUndef(o) || o === true || o === false;
}
function isVNode(node) {
    return !isNullOrUndef(node) && node.vtype === 2 /* Node */;
}
function isVText(node) {
    return !isNullOrUndef(node) && node.vtype === 1 /* Text */;
}
function isComponent(instance) {
    return !isInvalid(instance) && instance.isReactComponent === EMPTY_OBJ;
}
function isWidget(node) {
    return (!isNullOrUndef(node)
        && (node.vtype & (4 /* Composite */)) > 0);
}
function isPortal(vtype, node) {
    return (vtype & 32 /* Portal */) > 0;
}
function isComposite(node) {
    return !isNullOrUndef(node) && node.vtype === 4 /* Composite */;
}
function isValidElement(node) {
    return !isNullOrUndef(node) && node.vtype;
}
function isHook(arg) {
    return !isNullOrUndef(arg) && typeof arg.vhook === 'number';
}
// tslint:disable-next-line:no-empty
function noop() { }
// typescript will compile the enum's value for us.
// eg.
// Composite = 1 << 2  => Composite = 4
var VType;
(function (VType) {
    VType[VType["Text"] = 1] = "Text";
    VType[VType["Node"] = 2] = "Node";
    VType[VType["Composite"] = 4] = "Composite";
    VType[VType["Void"] = 16] = "Void";
    VType[VType["Portal"] = 32] = "Portal";
})(VType || (VType = {}));


/***/ }),

/***/ "./src/nerv/utils/env.ts":
/*!*******************************!*\
  !*** ./src/nerv/utils/env.ts ***!
  \*******************************/
/*! exports provided: global, isBrowser, doc, UA, isMacSafari, isIE9, isiOS */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "global", function() { return global; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isBrowser", function() { return isBrowser; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "doc", function() { return doc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UA", function() { return UA; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isMacSafari", function() { return isMacSafari; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isIE9", function() { return isIE9; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isiOS", function() { return isiOS; });
// tslint:disable-next-line
var global = (function () {
    var local;
    if (typeof global !== 'undefined') {
        local = global;
    }
    else if (typeof self !== 'undefined') {
        local = self;
    }
    else {
        try {
            // tslint:disable-next-line:function-constructor
            local = Function('return this')();
        }
        catch (e) {
            throw new Error('global object is unavailable in this environment');
        }
    }
    return local;
})();
var isBrowser = typeof window !== 'undefined';
// tslint:disable-next-line:no-empty
function noop() { }
var fakeDoc = {
    createElement: noop,
    createElementNS: noop,
    createTextNode: noop,
};
var doc = isBrowser ? document : fakeDoc;
var UA = isBrowser && window.navigator.userAgent.toLowerCase();
var isMacSafari = isBrowser && UA && window.navigator.platform
    && /mac/i.test(window.navigator.platform) && /^((?!chrome|android).)*safari/i.test(UA);
var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
var isiOS = (UA && /iphone|ipad|ipod|ios/.test(UA));


/***/ }),

/***/ "./src/nerv/utils/index.ts":
/*!*********************************!*\
  !*** ./src/nerv/utils/index.ts ***!
  \*********************************/
/*! exports provided: nextTick, shallowEqual, SimpleMap, MapClass, isNumber, isSupportSVG, isString, isFunction, isBoolean, isArray, isObject, isNative, isUndefined, objectIs, global, isBrowser, doc, UA, isMacSafari, isIE9, isiOS, getPrototype, isAttrAnEvent, extend, clone */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getPrototype", function() { return getPrototype; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isAttrAnEvent", function() { return isAttrAnEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extend", function() { return extend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony import */ var _next_tick__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./next-tick */ "./src/nerv/utils/next-tick.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "nextTick", function() { return _next_tick__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _shallow_equal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./shallow-equal */ "./src/nerv/utils/shallow-equal.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "shallowEqual", function() { return _shallow_equal__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _simple_map__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./simple-map */ "./src/nerv/utils/simple-map.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SimpleMap", function() { return _simple_map__WEBPACK_IMPORTED_MODULE_2__["SimpleMap"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MapClass", function() { return _simple_map__WEBPACK_IMPORTED_MODULE_2__["MapClass"]; });

/* harmony import */ var _is__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./is */ "./src/nerv/utils/is.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isNumber", function() { return _is__WEBPACK_IMPORTED_MODULE_3__["isNumber"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isSupportSVG", function() { return _is__WEBPACK_IMPORTED_MODULE_3__["isSupportSVG"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isString", function() { return _is__WEBPACK_IMPORTED_MODULE_3__["isString"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isFunction", function() { return _is__WEBPACK_IMPORTED_MODULE_3__["isFunction"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isBoolean", function() { return _is__WEBPACK_IMPORTED_MODULE_3__["isBoolean"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isArray", function() { return _is__WEBPACK_IMPORTED_MODULE_3__["isArray"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isObject", function() { return _is__WEBPACK_IMPORTED_MODULE_3__["isObject"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isNative", function() { return _is__WEBPACK_IMPORTED_MODULE_3__["isNative"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isUndefined", function() { return _is__WEBPACK_IMPORTED_MODULE_3__["isUndefined"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "objectIs", function() { return _is__WEBPACK_IMPORTED_MODULE_3__["objectIs"]; });

/* harmony import */ var _env__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./env */ "./src/nerv/utils/env.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "global", function() { return _env__WEBPACK_IMPORTED_MODULE_4__["global"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isBrowser", function() { return _env__WEBPACK_IMPORTED_MODULE_4__["isBrowser"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "doc", function() { return _env__WEBPACK_IMPORTED_MODULE_4__["doc"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "UA", function() { return _env__WEBPACK_IMPORTED_MODULE_4__["UA"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isMacSafari", function() { return _env__WEBPACK_IMPORTED_MODULE_4__["isMacSafari"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isIE9", function() { return _env__WEBPACK_IMPORTED_MODULE_4__["isIE9"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isiOS", function() { return _env__WEBPACK_IMPORTED_MODULE_4__["isiOS"]; });






function getPrototype(obj) {
    /* istanbul ignore next */
    if (Object.getPrototypeOf) {
        return Object.getPrototypeOf(obj);
    }
    else if (obj.__proto__) {
        return obj.__proto__;
    }
    /* istanbul ignore next */
    return obj.constructor.prototype;
}
function isAttrAnEvent(attr) {
    if (attr[0] === 'o' && attr[1] === 'n') {
        return true;
    }
    if (/^(bind|catch|capture-bind|capture-catch)([A-Za-z_]+)/.test(attr)) {
        return true;
    }
    return false;
}
var extend = (function () {
    return function (source, from) {
        if (!from) {
            return source;
        }
        Object.assign(source, from);
        return source;
    };
})();

function clone(obj) {
    return extend({}, obj);
}


/***/ }),

/***/ "./src/nerv/utils/is.ts":
/*!******************************!*\
  !*** ./src/nerv/utils/is.ts ***!
  \******************************/
/*! exports provided: isNumber, isSupportSVG, isString, isFunction, isBoolean, isArray, isObject, isNative, isUndefined, objectIs */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isNumber", function() { return isNumber; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isSupportSVG", function() { return isSupportSVG; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isString", function() { return isString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isFunction", function() { return isFunction; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isBoolean", function() { return isBoolean; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isArray", function() { return isArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isObject", function() { return isObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isNative", function() { return isNative; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isUndefined", function() { return isUndefined; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "objectIs", function() { return objectIs; });
/* harmony import */ var _env__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./env */ "./src/nerv/utils/env.ts");

function isNumber(arg) {
    return typeof arg === 'number';
}
var isSupportSVG = isFunction(_env__WEBPACK_IMPORTED_MODULE_0__["doc"].createAttributeNS);
function isString(arg) {
    return typeof arg === 'string';
}
function isFunction(arg) {
    return typeof arg === 'function';
}
function isBoolean(arg) {
    return arg === true || arg === false;
}
var isArray = Array.isArray;
function isObject(arg) {
    return arg === Object(arg) && !isFunction(arg);
}
function isNative(Ctor) {
    return isFunction(Ctor) && /native code/.test(Ctor.toString());
}
function isUndefined(o) {
    return o === undefined;
}
// Object.is polyfill
// https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/is
function objectIs(x, y) {
    if (x === y) { // Steps 1-5, 7-10
        // Steps 6.b-6.e: +0 != -0
        return x !== 0 || 1 / x === 1 / y;
    }
    // eslint-disable-next-line no-self-compare
    return x !== x && y !== y;
}


/***/ }),

/***/ "./src/nerv/utils/next-tick.ts":
/*!*************************************!*\
  !*** ./src/nerv/utils/next-tick.ts ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _env__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./env */ "./src/nerv/utils/env.ts");
/* harmony import */ var _is__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./is */ "./src/nerv/utils/is.ts");
var __spreadArrays = (undefined && undefined.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};


var canUsePromise = 'Promise' in _env__WEBPACK_IMPORTED_MODULE_0__["global"] && !_env__WEBPACK_IMPORTED_MODULE_0__["isMacSafari"];
var resolved;
if (canUsePromise) {
    resolved = Promise.resolve();
}
var nextTick = function (fn) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
    }
    fn = Object(_is__WEBPACK_IMPORTED_MODULE_1__["isFunction"])(fn) ? fn.bind.apply(fn, __spreadArrays([null], args)) : fn;
    if (canUsePromise) {
        return resolved.then(fn);
    }
    var timerFunc = 'requestAnimationFrame' in _env__WEBPACK_IMPORTED_MODULE_0__["global"] && !_env__WEBPACK_IMPORTED_MODULE_0__["isMacSafari"] ? requestAnimationFrame : setTimeout;
    timerFunc(fn);
};
/* harmony default export */ __webpack_exports__["default"] = (nextTick);


/***/ }),

/***/ "./src/nerv/utils/shallow-equal.ts":
/*!*****************************************!*\
  !*** ./src/nerv/utils/shallow-equal.ts ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return shallowEqual; });
/* istanbul ignore next */
// tslint:disable-next-line
Object.is = Object.is || function (x, y) {
    if (x === y) {
        return x !== 0 || 1 / x === 1 / y;
    }
    return x !== x && y !== y;
};
function shallowEqual(obj1, obj2) {
    if (obj1 === null || obj2 === null) {
        return false;
    }
    if (Object.is(obj1, obj2)) {
        return true;
    }
    var obj1Keys = obj1 ? Object.keys(obj1) : [];
    var obj2Keys = obj2 ? Object.keys(obj2) : [];
    if (obj1Keys.length !== obj2Keys.length) {
        return false;
    }
    for (var i = 0; i < obj1Keys.length; i++) {
        var obj1KeyItem = obj1Keys[i];
        if (!obj2.hasOwnProperty(obj1KeyItem) || !Object.is(obj1[obj1KeyItem], obj2[obj1KeyItem])) {
            return false;
        }
    }
    return true;
}


/***/ }),

/***/ "./src/nerv/utils/simple-map.ts":
/*!**************************************!*\
  !*** ./src/nerv/utils/simple-map.ts ***!
  \**************************************/
/*! exports provided: SimpleMap, MapClass */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SimpleMap", function() { return SimpleMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MapClass", function() { return MapClass; });
/* harmony import */ var _env__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./env */ "./src/nerv/utils/env.ts");

var SimpleMap = /** @class */ (function () {
    function SimpleMap() {
        this.cache = [];
        this.size = 0;
    }
    SimpleMap.prototype.set = function (k, v) {
        var len = this.cache.length;
        if (!len) {
            this.cache.push({ k: k, v: v });
            this.size += 1;
            return;
        }
        for (var i = 0; i < len; i++) {
            var item = this.cache[i];
            if (item.k === k) {
                item.v = v;
                return;
            }
        }
        this.cache.push({ k: k, v: v });
        this.size += 1;
    };
    SimpleMap.prototype.get = function (k) {
        var len = this.cache.length;
        if (!len) {
            return;
        }
        for (var i = 0; i < len; i++) {
            var item = this.cache[i];
            if (item.k === k) {
                return item.v;
            }
        }
    };
    SimpleMap.prototype.has = function (k) {
        var len = this.cache.length;
        if (!len) {
            return false;
        }
        for (var i = 0; i < len; i++) {
            var item = this.cache[i];
            if (item.k === k) {
                return true;
            }
        }
        return false;
    };
    SimpleMap.prototype.delete = function (k) {
        var len = this.cache.length;
        for (var i = 0; i < len; i++) {
            var item = this.cache[i];
            if (item.k === k) {
                this.cache.splice(i, 1);
                this.size -= 1;
                return true;
            }
        }
        return false;
    };
    SimpleMap.prototype.clear = function () {
        var len = this.cache.length;
        this.size = 0;
        if (!len) {
            return;
        }
        while (len) {
            this.cache.pop();
            len--;
        }
    };
    return SimpleMap;
}());

var MapClass = 'Map' in _env__WEBPACK_IMPORTED_MODULE_0__["global"] ? Map : SimpleMap;


/***/ }),

/***/ "./src/nerv/vdom/create-element.ts":
/*!*****************************************!*\
  !*** ./src/nerv/vdom/create-element.ts ***!
  \*****************************************/
/*! exports provided: mountVNode, mountChild, mountElement, insertElement, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mountVNode", function() { return mountVNode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mountChild", function() { return mountChild; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mountElement", function() { return mountElement; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "insertElement", function() { return insertElement; });
/* harmony import */ var _nerv_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/nerv/utils */ "./src/nerv/utils/index.ts");
/* harmony import */ var _nerv_shared__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/nerv/shared */ "./src/nerv/shared/index.ts");
/* harmony import */ var _patch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./patch */ "./src/nerv/vdom/patch.ts");
/* harmony import */ var _ref__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ref */ "./src/nerv/vdom/ref.ts");




var SVG_NAMESPACE = 'http://www.w3.org/2000/svg';
function createElement(vnode, isSvg, parentContext, parentComponent) {
    var domNode;
    if (Object(_nerv_shared__WEBPACK_IMPORTED_MODULE_1__["isValidElement"])(vnode)) {
        var vtype = vnode.vtype;
        if (vtype & (4 /* Composite */)) {
            domNode = vnode.init(parentContext, parentComponent);
        }
        else if (vtype & 1 /* Text */) {
            domNode = _nerv_utils__WEBPACK_IMPORTED_MODULE_0__["doc"].createTextNode(vnode.text);
            vnode.dom = domNode;
        }
        else if (vtype & 2 /* Node */) {
            domNode = mountVNode(vnode, isSvg, parentContext, parentComponent);
        }
        else if (vtype & 16 /* Void */) {
            domNode = vnode.dom = _nerv_utils__WEBPACK_IMPORTED_MODULE_0__["doc"].createTextNode('');
        }
        else if (Object(_nerv_shared__WEBPACK_IMPORTED_MODULE_1__["isPortal"])(vtype, vnode)) {
            vnode.type.appendChild(createElement(vnode.children, isSvg, parentContext, parentComponent));
            domNode = _nerv_utils__WEBPACK_IMPORTED_MODULE_0__["doc"].createTextNode('');
        }
    }
    else if (Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["isString"])(vnode) || Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["isNumber"])(vnode)) {
        domNode = _nerv_utils__WEBPACK_IMPORTED_MODULE_0__["doc"].createTextNode(vnode);
    }
    else if (Object(_nerv_shared__WEBPACK_IMPORTED_MODULE_1__["isNullOrUndef"])(vnode) || Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["isBoolean"])(vnode)) {
        domNode = _nerv_utils__WEBPACK_IMPORTED_MODULE_0__["doc"].createTextNode('');
    }
    else if (Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["isArray"])(vnode)) {
        domNode = vnode.map(function (child) { return createElement(child, isSvg, parentContext, parentComponent); });
    }
    else {
        throw new Error('Unsupported VNode.');
    }
    return domNode;
}
function mountVNode(vnode, isSvg, parentContext, parentComponent) {
    if (vnode.isSvg) {
        isSvg = true;
    }
    else if (vnode.type === 'svg') {
        isSvg = true;
        /* istanbul ignore next */
    }
    else if (!_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["isSupportSVG"]) {
        isSvg = false;
    }
    if (isSvg) {
        vnode.namespace = SVG_NAMESPACE;
        vnode.isSvg = isSvg;
    }
    var domNode = !isSvg
        ? _nerv_utils__WEBPACK_IMPORTED_MODULE_0__["doc"].createElement(vnode.type)
        : _nerv_utils__WEBPACK_IMPORTED_MODULE_0__["doc"].createElementNS(vnode.namespace, vnode.type);
    setProps(domNode, vnode, isSvg);
    if (vnode.type === 'foreignObject') {
        isSvg = false;
    }
    var children = vnode.children;
    if (Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["isArray"])(children)) {
        for (var i = 0, len = children.length; i < len; i++) {
            mountChild(children[i], domNode, parentContext, isSvg, parentComponent);
        }
    }
    else {
        mountChild(children, domNode, parentContext, isSvg, parentComponent);
    }
    vnode.dom = domNode;
    if (vnode.ref !== null) {
        _ref__WEBPACK_IMPORTED_MODULE_3__["default"].attach(vnode, vnode.ref, domNode);
    }
    return domNode;
}
function mountChild(child, domNode, parentContext, isSvg, parentComponent) {
    child.parentContext = parentContext || _nerv_shared__WEBPACK_IMPORTED_MODULE_1__["EMPTY_OBJ"];
    var childNode = createElement(child, isSvg, parentContext, parentComponent);
    mountElement(childNode, domNode);
}
function mountElement(element, parentNode, refChild) {
    if (Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["isArray"])(element)) {
        for (var i = 0; i < element.length; i += 1) {
            var el = element[i];
            mountElement(el, parentNode);
        }
    }
    else {
        refChild != null ? parentNode.insertBefore(element, refChild) : parentNode.appendChild(element);
    }
}
function insertElement(element, parentNode, lastDom) {
    if (Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["isArray"])(element)) {
        for (var i = 0; i < element.length; i += 1) {
            var el = element[i];
            insertElement(el, parentNode, lastDom);
        }
    }
    else {
        parentNode.insertBefore(element, lastDom);
    }
}
function setProps(domNode, vnode, isSvg) {
    var props = vnode.props;
    for (var p in props) {
        Object(_patch__WEBPACK_IMPORTED_MODULE_2__["patchProp"])(domNode, p, null, props[p], null, isSvg);
    }
}
/* harmony default export */ __webpack_exports__["default"] = (createElement);


/***/ }),

/***/ "./src/nerv/vdom/create-portal.ts":
/*!****************************************!*\
  !*** ./src/nerv/vdom/create-portal.ts ***!
  \****************************************/
/*! exports provided: createPortal */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createPortal", function() { return createPortal; });
function createPortal(children, container) {
    return {
        type: container,
        vtype: 32 /* Portal */,
        children: children,
        dom: null,
    };
}


/***/ }),

/***/ "./src/nerv/vdom/create-vnode.ts":
/*!***************************************!*\
  !*** ./src/nerv/vdom/create-vnode.ts ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _nerv_shared__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/nerv/shared */ "./src/nerv/shared/index.ts");

function createVNode(type, props, children, key, namespace, owner, ref) {
    return {
        type: type,
        key: key || null,
        vtype: 2 /* Node */,
        props: props || _nerv_shared__WEBPACK_IMPORTED_MODULE_0__["EMPTY_OBJ"],
        children: children,
        namespace: namespace || null,
        _owner: owner,
        dom: null,
        ref: ref || null,
    };
}
/* harmony default export */ __webpack_exports__["default"] = (createVNode);


/***/ }),

/***/ "./src/nerv/vdom/create-void.ts":
/*!**************************************!*\
  !*** ./src/nerv/vdom/create-void.ts ***!
  \**************************************/
/*! exports provided: createVoid */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createVoid", function() { return createVoid; });
function createVoid() {
    return {
        dom: null,
        vtype: 16 /* Void */,
    };
}


/***/ }),

/***/ "./src/nerv/vdom/create-vtext.ts":
/*!***************************************!*\
  !*** ./src/nerv/vdom/create-vtext.ts ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return createVText; });
function createVText(text) {
    return {
        text: text,
        vtype: 1 /* Text */,
        dom: null,
    };
}


/***/ }),

/***/ "./src/nerv/vdom/h.ts":
/*!****************************!*\
  !*** ./src/nerv/vdom/h.ts ***!
  \****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _nerv_shared__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/nerv/shared */ "./src/nerv/shared/index.ts");
/* harmony import */ var _nerv_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/nerv/utils */ "./src/nerv/utils/index.ts");
/* harmony import */ var _create_vnode__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./create-vnode */ "./src/nerv/vdom/create-vnode.ts");
/* harmony import */ var _create_vtext__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./create-vtext */ "./src/nerv/vdom/create-vtext.ts");
/* harmony import */ var _create_void__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./create-void */ "./src/nerv/vdom/create-void.ts");





function h(type, props, children) {
    var childNodes;
    if (props.children) {
        if (!children) {
            children = props.children;
        }
    }
    if (Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_1__["isArray"])(children)) {
        childNodes = [];
        addChildren(childNodes, children, type);
    }
    else if (Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_1__["isString"])(children) || Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_1__["isNumber"])(children)) {
        children = Object(_create_vtext__WEBPACK_IMPORTED_MODULE_3__["default"])(String(children));
    }
    else if (!Object(_nerv_shared__WEBPACK_IMPORTED_MODULE_0__["isValidElement"])(children)) {
        children = _nerv_shared__WEBPACK_IMPORTED_MODULE_0__["EMPTY_CHILDREN"];
    }
    props.children = childNodes !== undefined ? childNodes : children;
    return Object(_create_vnode__WEBPACK_IMPORTED_MODULE_2__["default"])(type, props, props.children, props.key, props.namespace, props.owner, props.ref);
}
function addChildren(childNodes, children, type) {
    if (Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_1__["isString"])(children) || Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_1__["isNumber"])(children)) {
        childNodes.push(Object(_create_vtext__WEBPACK_IMPORTED_MODULE_3__["default"])(String(children)));
    }
    else if (Object(_nerv_shared__WEBPACK_IMPORTED_MODULE_0__["isValidElement"])(children)) {
        childNodes.push(children);
    }
    else if (Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_1__["isArray"])(children)) {
        for (var i = 0; i < children.length; i++) {
            addChildren(childNodes, children[i], type);
        }
    }
    else {
        childNodes.push(Object(_create_void__WEBPACK_IMPORTED_MODULE_4__["createVoid"])());
    }
}
/* harmony default export */ __webpack_exports__["default"] = (h);


/***/ }),

/***/ "./src/nerv/vdom/patch.ts":
/*!********************************!*\
  !*** ./src/nerv/vdom/patch.ts ***!
  \********************************/
/*! exports provided: patch, patchChildren, patchProp, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "patch", function() { return patch; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "patchChildren", function() { return patchChildren; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "patchProp", function() { return patchProp; });
/* harmony import */ var _nerv_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/nerv/utils */ "./src/nerv/utils/index.ts");
/* harmony import */ var _nerv_shared__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/nerv/shared */ "./src/nerv/shared/index.ts");
/* harmony import */ var _create_element__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./create-element */ "./src/nerv/vdom/create-element.ts");
/* harmony import */ var _unmount__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./unmount */ "./src/nerv/vdom/unmount.ts");
/* harmony import */ var _ref__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ref */ "./src/nerv/vdom/ref.ts");
/* harmony import */ var _event__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../event */ "./src/nerv/event.ts");
/* harmony import */ var _svg_property_config__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./svg-property-config */ "./src/nerv/vdom/svg-property-config.ts");
/* tslint:disable: no-empty */







function patch(lastVnode, nextVnode, parentNode, context, isSvg) {
    var lastDom = lastVnode.dom;
    var newDom;
    var lastVnodeIsArray = Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["isArray"])(lastVnode);
    var nextVnodeisArray = Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["isArray"])(nextVnode);
    if (isSameVNode(lastVnode, nextVnode)) {
        var vtype = nextVnode.vtype;
        if (vtype & 2 /* Node */) {
            isSvg = Object(_nerv_shared__WEBPACK_IMPORTED_MODULE_1__["isNullOrUndef"])(isSvg) ? lastVnode.isSvg : isSvg;
            if (isSvg) {
                nextVnode.isSvg = isSvg;
            }
            patchProps(lastDom, nextVnode.props, lastVnode.props, lastVnode, isSvg);
            patchChildren(lastDom, lastVnode.children, nextVnode.children, context, isSvg);
            if (nextVnode.ref !== null) {
                _ref__WEBPACK_IMPORTED_MODULE_4__["default"].update(lastVnode, nextVnode, lastDom);
            }
            newDom = lastDom;
        }
        else if ((vtype & (4 /* Composite */)) > 0) {
            newDom = nextVnode.update(lastVnode, nextVnode, context);
        }
        else if (vtype & 1 /* Text */) {
            return patchVText(lastVnode, nextVnode);
        }
        else if (vtype & 32 /* Portal */) {
            patchChildren(lastVnode.type, lastVnode.children, nextVnode.children, context, isSvg);
        }
        // @TODO: test case
        nextVnode.dom = newDom || lastDom;
    }
    else if (Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["isArray"])(lastVnode) && Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["isArray"])(nextVnode)) {
        patchArrayChildren(lastDom, lastVnode, nextVnode, context, false);
    }
    else if (lastVnodeIsArray && !nextVnodeisArray) {
        patchArrayChildren(parentNode, lastVnode, [nextVnode], context, false);
    }
    else if (!lastVnodeIsArray && nextVnodeisArray) {
        newDom = Object(_create_element__WEBPACK_IMPORTED_MODULE_2__["default"])(nextVnode, isSvg, context);
        Object(_create_element__WEBPACK_IMPORTED_MODULE_2__["insertElement"])(newDom, parentNode, lastDom);
        parentNode.removeChild(lastDom);
    }
    else {
        Object(_unmount__WEBPACK_IMPORTED_MODULE_3__["unmount"])(lastVnode);
        newDom = Object(_create_element__WEBPACK_IMPORTED_MODULE_2__["default"])(nextVnode, isSvg, context);
        if (nextVnode !== null) {
            nextVnode.dom = newDom;
        }
        var newDomIsArray = Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["isArray"])(newDom);
        var lastDomIsArray = Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["isArray"])(lastDom);
        if (newDomIsArray) {
            Object(_create_element__WEBPACK_IMPORTED_MODULE_2__["insertElement"])(newDom, parentNode, lastDom);
            parentNode.removeChild(lastDom);
        }
        else if (lastDomIsArray) {
            parentNode = lastDom[0].parentNode;
            parentNode.insertBefore(newDom, lastDom[0]);
            for (var i = 0; i < lastDom.length; i++) {
                parentNode.removeChild(lastDom[i]);
            }
        }
        else if (parentNode !== null) {
            if (lastDom != null) {
                parentNode.replaceChild(newDom, lastDom);
            }
            else {
                parentNode.appendChild(newDom);
            }
        }
    }
    return newDom;
}
function patchArrayChildren(parentDom, lastChildren, nextChildren, context, isSvg) {
    var lastLength = lastChildren.length;
    var nextLength = nextChildren.length;
    if (lastLength === 0) {
        if (nextLength > 0) {
            for (var i = 0; i < nextLength; i++) {
                Object(_create_element__WEBPACK_IMPORTED_MODULE_2__["mountChild"])(nextChildren[i], parentDom, context, isSvg);
            }
        }
    }
    else if (nextLength === 0) {
        Object(_unmount__WEBPACK_IMPORTED_MODULE_3__["unmountChildren"])(lastChildren);
        parentDom.textContent = '';
    }
    else if (isKeyed(lastChildren, nextChildren)) {
        patchKeyedChildren(lastChildren, nextChildren, parentDom, context, isSvg, lastLength, nextLength);
    }
    else {
        patchNonKeyedChildren(parentDom, lastChildren, nextChildren, context, isSvg, lastLength, nextLength);
    }
}
function patchChildren(parentDom, lastChildren, nextChildren, context, isSvg) {
    // @TODO: is a better way to compatible with react-router?
    // if (lastChildren === nextChildren) {
    //   return
    // }
    var lastChildrenIsArray = Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["isArray"])(lastChildren);
    var nextChildrenIsArray = Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["isArray"])(nextChildren);
    if (lastChildrenIsArray && nextChildrenIsArray) {
        patchArrayChildren(parentDom, lastChildren, nextChildren, context, isSvg);
    }
    else if (!lastChildrenIsArray && !nextChildrenIsArray) {
        patch(lastChildren, nextChildren, parentDom, context, isSvg);
    }
    else if (lastChildrenIsArray && !nextChildrenIsArray) {
        patchArrayChildren(parentDom, lastChildren, [nextChildren], context, isSvg);
    }
    else if (!lastChildrenIsArray && nextChildrenIsArray) {
        patchArrayChildren(parentDom, [lastChildren], nextChildren, context, isSvg);
    }
}
function patchNonKeyedChildren(parentDom, lastChildren, nextChildren, context, isSvg, lastLength, nextLength) {
    var minLength = Math.min(lastLength, nextLength);
    var i = 0;
    while (i < minLength) {
        patch(lastChildren[i], nextChildren[i], parentDom, context, isSvg);
        i++;
    }
    if (lastLength < nextLength) {
        for (i = minLength; i < nextLength; i++) {
            if (parentDom !== null) {
                var refVnode = lastChildren[i - 1];
                Object(_create_element__WEBPACK_IMPORTED_MODULE_2__["mountElement"])(Object(_create_element__WEBPACK_IMPORTED_MODULE_2__["default"])(nextChildren[i], isSvg, context), parentDom, Object(_nerv_shared__WEBPACK_IMPORTED_MODULE_1__["isValidElement"])(refVnode) && refVnode.dom != null
                    ? refVnode.dom.nextSibling
                    : null);
            }
        }
    }
    else if (lastLength > nextLength) {
        for (i = minLength; i < lastLength; i++) {
            Object(_unmount__WEBPACK_IMPORTED_MODULE_3__["unmount"])(lastChildren[i], parentDom);
        }
    }
}
/**
 *
 * Virtual DOM patching algorithm based on ivi by
 * Boris Kaul (@localvoid)
 * Licensed under the MIT License
 * https://github.com/ivijs/ivi/blob/master/LICENSE
 *
 */
function patchKeyedChildren(a, b, dom, context, isSvg, aLength, bLength) {
    var aEnd = aLength - 1;
    var bEnd = bLength - 1;
    var aStart = 0;
    var bStart = 0;
    var i;
    var j;
    var aNode;
    var bNode;
    var nextNode;
    var nextPos;
    var node;
    var aStartNode = a[aStart];
    var bStartNode = b[bStart];
    var aEndNode = a[aEnd];
    var bEndNode = b[bEnd];
    // Step 1
    // tslint:disable-next-line
    outer: {
        // Sync nodes with the same key at the beginning.
        while (aStartNode.key === bStartNode.key) {
            patch(aStartNode, bStartNode, dom, context, isSvg);
            aStart++;
            bStart++;
            if (aStart > aEnd || bStart > bEnd) {
                break outer;
            }
            aStartNode = a[aStart];
            bStartNode = b[bStart];
        }
        // Sync nodes with the same key at the end.
        while (aEndNode.key === bEndNode.key) {
            patch(aEndNode, bEndNode, dom, context, isSvg);
            aEnd--;
            bEnd--;
            if (aStart > aEnd || bStart > bEnd) {
                break outer;
            }
            aEndNode = a[aEnd];
            bEndNode = b[bEnd];
        }
    }
    if (aStart > aEnd) {
        if (bStart <= bEnd) {
            nextPos = bEnd + 1;
            nextNode = nextPos < bLength ? b[nextPos].dom : null;
            while (bStart <= bEnd) {
                node = b[bStart];
                bStart++;
                attachNewNode(dom, Object(_create_element__WEBPACK_IMPORTED_MODULE_2__["default"])(node, isSvg, context), nextNode);
            }
        }
    }
    else if (bStart > bEnd) {
        while (aStart <= aEnd) {
            Object(_unmount__WEBPACK_IMPORTED_MODULE_3__["unmount"])(a[aStart++], dom);
        }
    }
    else {
        var aLeft = aEnd - aStart + 1;
        var bLeft = bEnd - bStart + 1;
        var sources = new Array(bLeft);
        // Mark all nodes as inserted.
        for (i = 0; i < bLeft; i++) {
            sources[i] = -1;
        }
        var moved = false;
        var pos = 0;
        var patched = 0;
        // When sizes are small, just loop them through
        if (bLeft <= 4 || aLeft * bLeft <= 16) {
            for (i = aStart; i <= aEnd; i++) {
                aNode = a[i];
                if (patched < bLeft) {
                    for (j = bStart; j <= bEnd; j++) {
                        bNode = b[j];
                        if (aNode.key === bNode.key) {
                            sources[j - bStart] = i;
                            if (pos > j) {
                                moved = true;
                            }
                            else {
                                pos = j;
                            }
                            patch(aNode, bNode, dom, context, isSvg);
                            patched++;
                            a[i] = null;
                            break;
                        }
                    }
                }
            }
        }
        else {
            var keyIndex = new _nerv_utils__WEBPACK_IMPORTED_MODULE_0__["MapClass"]();
            for (i = bStart; i <= bEnd; i++) {
                keyIndex.set(b[i].key, i);
            }
            for (i = aStart; i <= aEnd; i++) {
                aNode = a[i];
                if (patched < bLeft) {
                    j = keyIndex.get(aNode.key);
                    if (j !== undefined) {
                        bNode = b[j];
                        sources[j - bStart] = i;
                        if (pos > j) {
                            moved = true;
                        }
                        else {
                            pos = j;
                        }
                        patch(aNode, bNode, dom, context, isSvg);
                        patched++;
                        a[i] = null;
                    }
                }
            }
        }
        if (aLeft === aLength && patched === 0) {
            Object(_unmount__WEBPACK_IMPORTED_MODULE_3__["unmountChildren"])(a);
            dom.textContent = '';
            while (bStart < bLeft) {
                node = b[bStart];
                bStart++;
                attachNewNode(dom, Object(_create_element__WEBPACK_IMPORTED_MODULE_2__["default"])(node, isSvg, context), null);
            }
        }
        else {
            i = aLeft - patched;
            while (i > 0) {
                aNode = a[aStart++];
                if (aNode !== null) {
                    Object(_unmount__WEBPACK_IMPORTED_MODULE_3__["unmount"])(aNode, dom);
                    i--;
                }
            }
            if (moved) {
                var seq = lis(sources);
                j = seq.length - 1;
                for (i = bLeft - 1; i >= 0; i--) {
                    if (sources[i] === -1) {
                        pos = i + bStart;
                        node = b[pos];
                        nextPos = pos + 1;
                        attachNewNode(dom, Object(_create_element__WEBPACK_IMPORTED_MODULE_2__["default"])(node, isSvg, context), nextPos < bLength ? b[nextPos].dom : null);
                    }
                    else if (j < 0 || i !== seq[j]) {
                        pos = i + bStart;
                        node = b[pos];
                        nextPos = pos + 1;
                        attachNewNode(dom, node.dom, nextPos < bLength ? b[nextPos].dom : null);
                    }
                    else {
                        j--;
                    }
                }
            }
            else if (patched !== bLeft) {
                for (i = bLeft - 1; i >= 0; i--) {
                    if (sources[i] === -1) {
                        pos = i + bStart;
                        node = b[pos];
                        nextPos = pos + 1;
                        attachNewNode(dom, Object(_create_element__WEBPACK_IMPORTED_MODULE_2__["default"])(node, isSvg, context), nextPos < bLength ? b[nextPos].dom : null);
                    }
                }
            }
        }
    }
}
function attachNewNode(parentDom, newNode, nextNode) {
    if (Object(_nerv_shared__WEBPACK_IMPORTED_MODULE_1__["isNullOrUndef"])(nextNode)) {
        parentDom.appendChild(newNode);
    }
    else {
        parentDom.insertBefore(newNode, nextNode);
    }
}
/**
 * Slightly modified Longest Increased Subsequence algorithm, it ignores items that have -1 value, they're representing
 * new items.
 *
 * http://en.wikipedia.org/wiki/Longest_increasing_subsequence
 *
 * @param a Array of numbers.
 * @returns Longest increasing subsequence.
 */
function lis(a) {
    var p = a.slice();
    var result = [];
    result.push(0);
    var u;
    var v;
    for (var i = 0, il = a.length; i < il; ++i) {
        if (a[i] === -1) {
            continue;
        }
        var j = result[result.length - 1];
        if (a[j] < a[i]) {
            p[i] = j;
            result.push(i);
            continue;
        }
        u = 0;
        v = result.length - 1;
        while (u < v) {
            var c = ((u + v) / 2) | 0;
            if (a[result[c]] < a[i]) {
                u = c + 1;
            }
            else {
                v = c;
            }
        }
        if (a[i] < a[result[u]]) {
            if (u > 0) {
                p[i] = result[u - 1];
            }
            result[u] = i;
        }
    }
    u = result.length;
    v = result[u - 1];
    while (u-- > 0) {
        result[u] = v;
        v = p[v];
    }
    return result;
}
function isKeyed(lastChildren, nextChildren) {
    return (nextChildren.length > 0
        && !Object(_nerv_shared__WEBPACK_IMPORTED_MODULE_1__["isNullOrUndef"])(nextChildren[0])
        && !Object(_nerv_shared__WEBPACK_IMPORTED_MODULE_1__["isNullOrUndef"])(nextChildren[0].key)
        && lastChildren.length > 0
        && !Object(_nerv_shared__WEBPACK_IMPORTED_MODULE_1__["isNullOrUndef"])(lastChildren[0])
        && !Object(_nerv_shared__WEBPACK_IMPORTED_MODULE_1__["isNullOrUndef"])(lastChildren[0].key));
}
function isSameVNode(a, b) {
    if (Object(_nerv_shared__WEBPACK_IMPORTED_MODULE_1__["isInvalid"])(a) || Object(_nerv_shared__WEBPACK_IMPORTED_MODULE_1__["isInvalid"])(b) || Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["isArray"])(a) || Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["isArray"])(b)) {
        return false;
    }
    return a.type === b.type && a.vtype === b.vtype && a.key === b.key;
}
function patchVText(lastVNode, nextVNode) {
    var dom = lastVNode.dom;
    if (dom === null) {
        return;
    }
    var nextText = nextVNode.text;
    nextVNode.dom = dom;
    if (lastVNode.text !== nextText) {
        dom.nodeValue = nextText;
    }
    return dom;
}
var skipProps = {
    children: 1,
    key: 1,
    ref: 1,
    owner: 1,
    /* 编译小程序，生成的prop */
    __owner: 1,
    __page: 1,
};
var IS_NON_DIMENSIONAL = /acit|ex(?:s|g|n|p|$)|rph|ows|mnc|ntw|ine[ch]|zoo|^ord/i;
function setStyle(domStyle, style, value) {
    if (Object(_nerv_shared__WEBPACK_IMPORTED_MODULE_1__["isNullOrUndef"])(value) || (Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["isNumber"])(value) && isNaN(value))) {
        domStyle[style] = '';
        return;
    }
    if (style === 'float') {
        domStyle.cssFloat = value;
        domStyle.styleFloat = value;
        return;
    }
    domStyle[style] = !Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["isNumber"])(value) || IS_NON_DIMENSIONAL.test(style) ? value : value + "px";
}
function patchEvent(eventName, lastEvent, nextEvent, domNode) {
    if (lastEvent !== nextEvent) {
        if (Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["isFunction"])(lastEvent)) {
            Object(_event__WEBPACK_IMPORTED_MODULE_5__["detachEvent"])(domNode, eventName, lastEvent);
        }
        Object(_event__WEBPACK_IMPORTED_MODULE_5__["attachEvent"])(domNode, eventName, nextEvent);
    }
}
var BASE_DEVICE_WIDTH = 750;
var isIOS = navigator.userAgent.match('iPhone');
var deviceWidth = window.screen.width || 375;
var deviceDPR = window.devicePixelRatio || 2;
var eps = 1e-4;
function rpx2px(number) {
    if (number === 0) {
        return 0;
    }
    number = number / BASE_DEVICE_WIDTH * deviceWidth;
    number = Math.floor(number + eps);
    if (number === 0) {
        if (deviceDPR === 1 || !isIOS) {
            return 1;
        }
        else {
            return 0.5;
        }
    }
    return number;
}
function transformRpx(str) {
    if (typeof str !== 'string') {
        return str;
    }
    var state = 0;
    var res = '';
    var number = '';
    for (var i = 0, l = str.length; i < l; i++) {
        var char = str[i];
        if (/[\d.]/.test(char) && i < l - 1 && state !== 2) {
            state = 3;
            number += char;
            continue;
        }
        else if (state === 1) {
            if (char === '\n' || char === '\r' || char === ' ' && res.slice(-1) === ' ') {
                continue;
            }
            if (char === '(' && res.endsWith('url')) {
                state = 2;
            }
            if (char === ';') {
                state = 0;
            }
            res += char;
        }
        else if (state === 2) {
            if (char === ')') {
                state = 1;
            }
            res += char;
        }
        else if (state === 3) {
            if (!/[\d.]/.test(char)) {
                var safeNum = Number(number);
                if (str.slice(i, i + 4).match(/rpx([\s;),}]|$)/) && !isNaN(safeNum)) {
                    res += rpx2px(safeNum) + "px";
                    i += 2;
                }
                else {
                    res += number;
                    res += char;
                }
                state = 1;
                number = '';
                continue;
            }
            number += char;
            if (i === l - 1) {
                // 结束了，number还没处理
                res += number;
            }
        }
        else {
            if (char === ':') {
                state = 1;
            }
            res += char;
        }
    }
    return res;
}
function patchStyle(lastAttrValue, nextAttrValue, dom) {
    var domStyle = dom.style;
    var style;
    var value;
    if (Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["isString"])(nextAttrValue)) {
        domStyle.cssText = transformRpx(nextAttrValue);
        return;
    }
    if (!Object(_nerv_shared__WEBPACK_IMPORTED_MODULE_1__["isNullOrUndef"])(lastAttrValue) && !Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["isString"])(lastAttrValue)) {
        for (style in nextAttrValue) {
            value = nextAttrValue[style];
            if (value !== lastAttrValue[style]) {
                setStyle(domStyle, style, value);
            }
        }
        for (style in lastAttrValue) {
            if (Object(_nerv_shared__WEBPACK_IMPORTED_MODULE_1__["isNullOrUndef"])(nextAttrValue[style])) {
                domStyle[style] = '';
            }
        }
    }
    else {
        for (style in nextAttrValue) {
            value = nextAttrValue[style];
            setStyle(domStyle, style, value);
        }
    }
}
function patchProp(domNode, prop, lastValue, nextValue, lastVnode, isSvg) {
    // fix the value update for textarea/input
    if (lastValue !== nextValue || prop === 'value') {
        if (prop === 'className') {
            prop = 'class';
        }
        if (skipProps[prop] === 1) {
        }
        else if (prop === 'class' && !isSvg) {
            domNode.className = nextValue;
        }
        else if (prop === 'dangerouslySetInnerHTML') {
            var lastHtml = lastValue && lastValue.__html;
            var nextHtml = nextValue && nextValue.__html;
            if (lastHtml !== nextHtml) {
                if (!Object(_nerv_shared__WEBPACK_IMPORTED_MODULE_1__["isNullOrUndef"])(nextHtml)) {
                    if (Object(_nerv_shared__WEBPACK_IMPORTED_MODULE_1__["isValidElement"])(lastVnode)
                        && lastVnode.children !== _nerv_shared__WEBPACK_IMPORTED_MODULE_1__["EMPTY_CHILDREN"]) {
                        Object(_unmount__WEBPACK_IMPORTED_MODULE_3__["unmountChildren"])(lastVnode.children);
                        lastVnode.children = [];
                    }
                    domNode.innerHTML = nextHtml;
                }
            }
        }
        else if (Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["isAttrAnEvent"])(prop)) {
            patchEvent(prop, lastValue, nextValue, domNode);
        }
        else if (prop === 'style') {
            patchStyle(lastValue, nextValue, domNode);
        }
        else if (Object(_nerv_shared__WEBPACK_IMPORTED_MODULE_1__["isNullOrUndef"])(nextValue) || nextValue === false) {
            domNode.removeAttribute(prop);
        }
        else {
            var namespace = _svg_property_config__WEBPACK_IMPORTED_MODULE_6__["default"].DOMAttributeNamespaces[prop];
            if (isSvg && namespace) {
                if (nextValue) {
                    domNode.setAttributeNS(namespace, prop, nextValue);
                }
                else {
                    var colonPosition = prop.indexOf(':');
                    var localName = colonPosition > -1 ? prop.substr(colonPosition + 1) : prop;
                    domNode.removeAttributeNS(namespace, localName);
                }
            }
            else {
                if (!Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["isFunction"])(nextValue)) {
                    domNode.setAttribute(prop, nextValue);
                }
                // WARNING: Non-event attributes with function values:
                // https://reactjs.org/blog/2017/09/08/dom-attributes-in-react-16.html#changes-in-detail
            }
        }
    }
}
function patchProps(domNode, nextProps, previousProps, lastVnode, isSvg) {
    for (var propName in previousProps) {
        var value = previousProps[propName];
        if (Object(_nerv_shared__WEBPACK_IMPORTED_MODULE_1__["isNullOrUndef"])(nextProps[propName]) && !Object(_nerv_shared__WEBPACK_IMPORTED_MODULE_1__["isNullOrUndef"])(value)) {
            if (Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["isAttrAnEvent"])(propName)) {
                Object(_event__WEBPACK_IMPORTED_MODULE_5__["detachEvent"])(domNode, propName, value);
            }
            else if (propName === 'dangerouslySetInnerHTML') {
                domNode.textContent = '';
            }
            else if (propName === 'className') {
                domNode.removeAttribute('class');
            }
            else {
                domNode.removeAttribute(propName);
            }
        }
    }
    for (var propName in nextProps) {
        patchProp(domNode, propName, previousProps[propName], nextProps[propName], lastVnode, isSvg);
    }
}
/* harmony default export */ __webpack_exports__["default"] = (patch);


/***/ }),

/***/ "./src/nerv/vdom/ref.ts":
/*!******************************!*\
  !*** ./src/nerv/vdom/ref.ts ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _nerv_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/nerv/utils */ "./src/nerv/utils/index.ts");
/* harmony import */ var _nerv_shared__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/nerv/shared */ "./src/nerv/shared/index.ts");
/* harmony import */ var _lifecycle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lifecycle */ "./src/nerv/lifecycle.ts");



/* harmony default export */ __webpack_exports__["default"] = ({
    update: function (lastVnode, nextVnode, domNode) {
        var prevRef = lastVnode != null && lastVnode.ref;
        var nextRef = nextVnode != null && nextVnode.ref;
        if (prevRef !== nextRef) {
            this.detach(lastVnode, prevRef, lastVnode.dom);
            this.attach(nextVnode, nextRef, domNode);
        }
    },
    attach: function (vnode, ref, domNode) {
        var node = Object(_nerv_shared__WEBPACK_IMPORTED_MODULE_1__["isComposite"])(vnode) ? vnode.component : domNode;
        if (Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["isFunction"])(ref)) {
            var componentForCatcher = Object(_nerv_shared__WEBPACK_IMPORTED_MODULE_1__["isComposite"])(vnode) ? vnode.component : vnode;
            Object(_lifecycle__WEBPACK_IMPORTED_MODULE_2__["errorCatcher"])(function () {
                ref(node);
            }, componentForCatcher);
        }
        else if (Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["isString"])(ref)) {
            var inst = vnode._owner;
            if (inst && Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["isFunction"])(inst.render)) {
                inst.refs[ref] = node;
            }
        }
        else if (Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["isObject"])(ref)) {
            ref.current = node;
        }
    },
    detach: function (vnode, ref, domNode) {
        var node = Object(_nerv_shared__WEBPACK_IMPORTED_MODULE_1__["isComposite"])(vnode) ? vnode.component : domNode;
        if (Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["isFunction"])(ref)) {
            var componentForCatcher = Object(_nerv_shared__WEBPACK_IMPORTED_MODULE_1__["isComposite"])(vnode) ? vnode.component : vnode;
            Object(_lifecycle__WEBPACK_IMPORTED_MODULE_2__["errorCatcher"])(function () {
                ref(null);
            }, componentForCatcher);
        }
        else if (Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["isString"])(ref)) {
            var inst = vnode._owner;
            if (inst.refs[ref] === node && Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["isFunction"])(inst.render)) {
                delete inst.refs[ref];
            }
        }
        else if (Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_0__["isObject"])(ref)) {
            ref.current = null;
        }
    },
});


/***/ }),

/***/ "./src/nerv/vdom/svg-property-config.ts":
/*!**********************************************!*\
  !*** ./src/nerv/vdom/svg-property-config.ts ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var NS = {
    ev: 'http://www.w3.org/2001/xml-events',
    xlink: 'http://www.w3.org/1999/xlink',
    xml: 'http://www.w3.org/XML/1998/namespace',
};
var ATTRS = {
    accentHeight: 'accent-height',
    accumulate: 0,
    additive: 0,
    alignmentBaseline: 'alignment-baseline',
    allowReorder: 'allowReorder',
    alphabetic: 0,
    amplitude: 0,
    arabicForm: 'arabic-form',
    ascent: 0,
    attributeName: 'attributeName',
    attributeType: 'attributeType',
    autoReverse: 'autoReverse',
    azimuth: 0,
    baseFrequency: 'baseFrequency',
    baseProfile: 'baseProfile',
    baselineShift: 'baseline-shift',
    bbox: 0,
    begin: 0,
    bias: 0,
    by: 0,
    calcMode: 'calcMode',
    capHeight: 'cap-height',
    clip: 0,
    clipPath: 'clip-path',
    clipRule: 'clip-rule',
    clipPathUnits: 'clipPathUnits',
    colorInterpolation: 'color-interpolation',
    colorInterpolationFilters: 'color-interpolation-filters',
    colorProfile: 'color-profile',
    colorRendering: 'color-rendering',
    contentScriptType: 'contentScriptType',
    contentStyleType: 'contentStyleType',
    cursor: 0,
    cx: 0,
    cy: 0,
    d: 0,
    decelerate: 0,
    descent: 0,
    diffuseConstant: 'diffuseConstant',
    direction: 0,
    display: 0,
    divisor: 0,
    dominantBaseline: 'dominant-baseline',
    dur: 0,
    dx: 0,
    dy: 0,
    edgeMode: 'edgeMode',
    elevation: 0,
    enableBackground: 'enable-background',
    end: 0,
    evEvent: 'ev:event',
    exponent: 0,
    externalResourcesRequired: 'externalResourcesRequired',
    fill: 0,
    fillOpacity: 'fill-opacity',
    fillRule: 'fill-rule',
    filter: 0,
    filterRes: 'filterRes',
    filterUnits: 'filterUnits',
    floodColor: 'flood-color',
    floodOpacity: 'flood-opacity',
    focusable: 0,
    fontFamily: 'font-family',
    fontSize: 'font-size',
    fontSizeAdjust: 'font-size-adjust',
    fontStretch: 'font-stretch',
    fontStyle: 'font-style',
    fontVariant: 'font-variant',
    fontWeight: 'font-weight',
    format: 0,
    from: 0,
    fx: 0,
    fy: 0,
    g1: 0,
    g2: 0,
    glyphName: 'glyph-name',
    glyphOrientationHorizontal: 'glyph-orientation-horizontal',
    glyphOrientationVertical: 'glyph-orientation-vertical',
    glyphRef: 'glyphRef',
    gradientTransform: 'gradientTransform',
    gradientUnits: 'gradientUnits',
    hanging: 0,
    horizAdvX: 'horiz-adv-x',
    horizOriginX: 'horiz-origin-x',
    ideographic: 0,
    imageRendering: 'image-rendering',
    in: 0,
    in2: 0,
    intercept: 0,
    k: 0,
    k1: 0,
    k2: 0,
    k3: 0,
    k4: 0,
    kernelMatrix: 'kernelMatrix',
    kernelUnitLength: 'kernelUnitLength',
    kerning: 0,
    keyPoints: 'keyPoints',
    keySplines: 'keySplines',
    keyTimes: 'keyTimes',
    lengthAdjust: 'lengthAdjust',
    letterSpacing: 'letter-spacing',
    lightingColor: 'lighting-color',
    limitingConeAngle: 'limitingConeAngle',
    local: 0,
    markerEnd: 'marker-end',
    markerMid: 'marker-mid',
    markerStart: 'marker-start',
    markerHeight: 'markerHeight',
    markerUnits: 'markerUnits',
    markerWidth: 'markerWidth',
    mask: 0,
    maskContentUnits: 'maskContentUnits',
    maskUnits: 'maskUnits',
    mathematical: 0,
    mode: 0,
    numOctaves: 'numOctaves',
    offset: 0,
    opacity: 0,
    operator: 0,
    order: 0,
    orient: 0,
    orientation: 0,
    origin: 0,
    overflow: 0,
    overlinePosition: 'overline-position',
    overlineThickness: 'overline-thickness',
    paintOrder: 'paint-order',
    panose1: 'panose-1',
    pathLength: 'pathLength',
    patternContentUnits: 'patternContentUnits',
    patternTransform: 'patternTransform',
    patternUnits: 'patternUnits',
    pointerEvents: 'pointer-events',
    points: 0,
    pointsAtX: 'pointsAtX',
    pointsAtY: 'pointsAtY',
    pointsAtZ: 'pointsAtZ',
    preserveAlpha: 'preserveAlpha',
    preserveAspectRatio: 'preserveAspectRatio',
    primitiveUnits: 'primitiveUnits',
    r: 0,
    radius: 0,
    refX: 'refX',
    refY: 'refY',
    renderingIntent: 'rendering-intent',
    repeatCount: 'repeatCount',
    repeatDur: 'repeatDur',
    requiredExtensions: 'requiredExtensions',
    requiredFeatures: 'requiredFeatures',
    restart: 0,
    result: 0,
    rotate: 0,
    rx: 0,
    ry: 0,
    scale: 0,
    seed: 0,
    shapeRendering: 'shape-rendering',
    slope: 0,
    spacing: 0,
    specularConstant: 'specularConstant',
    specularExponent: 'specularExponent',
    speed: 0,
    spreadMethod: 'spreadMethod',
    startOffset: 'startOffset',
    stdDeviation: 'stdDeviation',
    stemh: 0,
    stemv: 0,
    stitchTiles: 'stitchTiles',
    stopColor: 'stop-color',
    stopOpacity: 'stop-opacity',
    strikethroughPosition: 'strikethrough-position',
    strikethroughThickness: 'strikethrough-thickness',
    string: 0,
    stroke: 0,
    strokeDasharray: 'stroke-dasharray',
    strokeDashoffset: 'stroke-dashoffset',
    strokeLinecap: 'stroke-linecap',
    strokeLinejoin: 'stroke-linejoin',
    strokeMiterlimit: 'stroke-miterlimit',
    strokeOpacity: 'stroke-opacity',
    strokeWidth: 'stroke-width',
    surfaceScale: 'surfaceScale',
    systemLanguage: 'systemLanguage',
    tableValues: 'tableValues',
    targetX: 'targetX',
    targetY: 'targetY',
    textAnchor: 'text-anchor',
    textDecoration: 'text-decoration',
    textRendering: 'text-rendering',
    textLength: 'textLength',
    to: 0,
    transform: 0,
    u1: 0,
    u2: 0,
    underlinePosition: 'underline-position',
    underlineThickness: 'underline-thickness',
    unicode: 0,
    unicodeBidi: 'unicode-bidi',
    unicodeRange: 'unicode-range',
    unitsPerEm: 'units-per-em',
    vAlphabetic: 'v-alphabetic',
    vHanging: 'v-hanging',
    vIdeographic: 'v-ideographic',
    vMathematical: 'v-mathematical',
    values: 0,
    vectorEffect: 'vector-effect',
    version: 0,
    vertAdvY: 'vert-adv-y',
    vertOriginX: 'vert-origin-x',
    vertOriginY: 'vert-origin-y',
    viewBox: 'viewBox',
    viewTarget: 'viewTarget',
    visibility: 0,
    widths: 0,
    wordSpacing: 'word-spacing',
    writingMode: 'writing-mode',
    x: 0,
    xHeight: 'x-height',
    x1: 0,
    x2: 0,
    xChannelSelector: 'xChannelSelector',
    xlinkActuate: 'xlink:actuate',
    xlinkArcrole: 'xlink:arcrole',
    xlinkHref: 'xlink:href',
    xlinkRole: 'xlink:role',
    xlinkShow: 'xlink:show',
    xlinkTitle: 'xlink:title',
    xlinkType: 'xlink:type',
    xmlBase: 'xml:base',
    xmlId: 'xml:id',
    xmlns: 0,
    xmlnsXlink: 'xmlns:xlink',
    xmlLang: 'xml:lang',
    xmlSpace: 'xml:space',
    y: 0,
    y1: 0,
    y2: 0,
    yChannelSelector: 'yChannelSelector',
    z: 0,
    zoomAndPan: 'zoomAndPan',
};
var SVGPropertyConfig = {
    Properties: {},
    DOMAttributeNamespaces: {
        'ev:event': NS.ev,
        'xlink:actuate': NS.xlink,
        'xlink:arcrole': NS.xlink,
        'xlink:href': NS.xlink,
        'xlink:role': NS.xlink,
        'xlink:show': NS.xlink,
        'xlink:title': NS.xlink,
        'xlink:type': NS.xlink,
        'xml:base': NS.xml,
        'xml:id': NS.xml,
        'xml:lang': NS.xml,
        'xml:space': NS.xml,
    },
    DOMAttributeNames: {},
};
Object.keys(ATTRS).forEach(function (key) {
    SVGPropertyConfig.Properties[key] = 0;
    if (ATTRS[key]) {
        SVGPropertyConfig.DOMAttributeNames[key] = ATTRS[key];
    }
});
/* harmony default export */ __webpack_exports__["default"] = (SVGPropertyConfig);


/***/ }),

/***/ "./src/nerv/vdom/unmount.ts":
/*!**********************************!*\
  !*** ./src/nerv/vdom/unmount.ts ***!
  \**********************************/
/*! exports provided: unmountChildren, unmount */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unmountChildren", function() { return unmountChildren; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unmount", function() { return unmount; });
/* harmony import */ var _nerv_shared__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/nerv/shared */ "./src/nerv/shared/index.ts");
/* harmony import */ var _nerv_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/nerv/utils */ "./src/nerv/utils/index.ts");
/* harmony import */ var _ref__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ref */ "./src/nerv/vdom/ref.ts");
/* harmony import */ var _event__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../event */ "./src/nerv/event.ts");




function unmountChildren(children, parentDom) {
    if (Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_1__["isArray"])(children)) {
        for (var i = 0, len = children.length; i < len; i++) {
            unmount(children[i], parentDom);
        }
    }
    else {
        unmount(children, parentDom);
    }
}
function unmount(vnode, parentDom) {
    if (Object(_nerv_shared__WEBPACK_IMPORTED_MODULE_0__["isInvalid"])(vnode)) {
        return;
    }
    var vtype = vnode.vtype;
    // Bitwise operators for better performance
    // see: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators
    var dom = vnode.dom;
    if ((vtype & (4 /* Composite */)) > 0) {
        vnode.destroy();
    }
    else if ((vtype & 2 /* Node */) > 0) {
        var props = vnode.props, children = vnode.children, ref = vnode.ref;
        unmountChildren(children);
        for (var propName in props) {
            if (Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_1__["isAttrAnEvent"])(propName)) {
                Object(_event__WEBPACK_IMPORTED_MODULE_3__["detachEvent"])(dom, propName, props[propName]);
            }
        }
        if (ref !== null) {
            _ref__WEBPACK_IMPORTED_MODULE_2__["default"].detach(vnode, ref, dom);
        }
    }
    else if (vtype & 32 /* Portal */) {
        unmountChildren(vnode.children, vnode.type);
    }
    if (!Object(_nerv_shared__WEBPACK_IMPORTED_MODULE_0__["isNullOrUndef"])(parentDom) && !Object(_nerv_shared__WEBPACK_IMPORTED_MODULE_0__["isNullOrUndef"])(dom)) {
        if (Object(_nerv_utils__WEBPACK_IMPORTED_MODULE_1__["isArray"])(dom)) {
            for (var i = 0; i < dom.length; i++) {
                parentDom.removeChild(dom[i]);
            }
        }
        else {
            parentDom.removeChild(dom);
        }
    }
    // vnode.dom = null
}


/***/ }),

/***/ "./src/nerv/version.ts":
/*!*****************************!*\
  !*** ./src/nerv/version.ts ***!
  \*****************************/
/*! exports provided: version */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "version", function() { return version; });
// some library check React version
// see: https://github.com/NervJS/nerv/issues/46
var version = '15.4.2';


/***/ }),

/***/ "./src/utils/EventEmitter.js":
/*!***********************************!*\
  !*** ./src/utils/EventEmitter.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return EventEmitter; });
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _gerror__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./gerror */ "./src/utils/gerror.js");




function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }



var EventEmitter = /*#__PURE__*/function () {
  function EventEmitter() {
    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, EventEmitter);

    this.allListeners = {};
  }

  _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(EventEmitter, [{
    key: "_addListener",
    value: function _addListener(_types, listener) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      var _this = this;

      var types = _types;

      if (!Array.isArray(types)) {
        types = [types];
      }

      var allListeners = this.allListeners;
      types.forEach(function (type) {
        var fns = allListeners[type] = allListeners[type] || [];

        if (fns.indexOf(listener) !== -1) {
          return;
        }

        if (options.prepend) {
          fns.unshift(listener);
        } else {
          fns.push(listener);
        }
      });
      return {
        remove: function remove() {
          _this.removeListener(types, listener);
        }
      };
    }
  }, {
    key: "addListener",
    value: function addListener(types, listener) {
      return this._addListener(types, listener);
    }
  }, {
    key: "prependListener",
    value: function prependListener(types, listener) {
      return this._addListener(types, listener, {
        prepend: true
      });
    }
  }, {
    key: "listeners",
    value: function listeners(type) {
      return type ? this.allListeners[type] || [] : this.allListeners;
    }
  }, {
    key: "listenerCount",
    value: function listenerCount(type) {
      if (type) {
        return this.listeners(type).length;
      } else {
        var allListeners = this.allListeners;
        var keys = Object.keys(allListeners);
        var count = 0;

        for (var i = 0, l = keys.length; i < l; i++) {
          var key = keys[i];
          count += allListeners[key] && allListeners[key].length || 0;
        }

        return count;
      }
    }
  }, {
    key: "emit",
    value: function emit(_types) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      var types = _types;

      if (!Array.isArray(types)) {
        types = [types];
      }

      var loopListeners = _objectSpread({}, this.allListeners);

      types.forEach(function (type) {
        var fns = loopListeners[type];

        if (fns) {
          fns.concat().forEach(function (f) {
            try {
              f.apply(undefined, args);
            } catch (e) {
              Object(_gerror__WEBPACK_IMPORTED_MODULE_3__["default"])(e);
            }
          });
        }
      });
    }
  }, {
    key: "removeListener",
    value: function removeListener(_types, listener) {
      var types = _types;

      if (!Array.isArray(types)) {
        types = [types];
      }

      var allListeners = this.allListeners;
      types.forEach(function (type) {
        var fns = allListeners[type];

        if (fns) {
          if (listener) {
            var index = fns.indexOf(listener);

            if (index !== -1) {
              fns.splice(index, 1);
            }
          } else {
            delete allListeners[type];
          }
        }
      });
    }
  }, {
    key: "on",
    value: function on() {
      this.addListener.apply(this, arguments);
    }
  }, {
    key: "off",
    value: function off() {
      this.removeListener.apply(this, arguments);
    }
  }]);

  return EventEmitter;
}();



/***/ }),

/***/ "./src/utils/addEvents.js":
/*!********************************!*\
  !*** ./src/utils/addEvents.js ***!
  \********************************/
/*! exports provided: default, addEvent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return addEvents; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addEvent", function() { return addEvent; });
/* harmony import */ var _objectKeys__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./objectKeys */ "./src/utils/objectKeys.js");

function addEvents(target, fns) {
  var names = Object(_objectKeys__WEBPACK_IMPORTED_MODULE_0__["default"])(fns);
  names.forEach(function (name) {
    target.addEventListener(name, fns[name]);
  });
  return {
    remove: function remove() {
      names.forEach(function (name) {
        target.removeEventListener(name, fns[name]);
      });
    }
  };
}
function addEvent(target, name, fn) {
  target.addEventListener(name, fn);
  return {
    remove: function remove() {
      target.removeEventListener(name, fn);
    }
  };
}

/***/ }),

/***/ "./src/utils/addListenerToElement.js":
/*!*******************************************!*\
  !*** ./src/utils/addListenerToElement.js ***!
  \*******************************************/
/*! exports provided: default, removeListenerToElement */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return addListenerToElement; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "removeListenerToElement", function() { return removeListenerToElement; });
/* harmony import */ var _utils_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/types */ "./src/utils/types.js");
/* harmony import */ var _utils_eventReg__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/utils/eventReg */ "./src/utils/eventReg.js");
/* harmony import */ var _supportsPassive__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./supportsPassive */ "./src/utils/supportsPassive.js");
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./config */ "./src/utils/config.js");
/* eslint-disable default-case */




var EVENT_BLACK_LIST = ['click'];
var PRESS_DELAY = 350;
var TAP_DISTANCE = 5;
var TAP_BLACK_LIST = ["".concat(_config__WEBPACK_IMPORTED_MODULE_3__["UpperCasePerfix"], "-BUTTON"), "".concat(_config__WEBPACK_IMPORTED_MODULE_3__["UpperCasePerfix"], "-CHECKBOX"), "".concat(_config__WEBPACK_IMPORTED_MODULE_3__["UpperCasePerfix"], "-RADIO"), "".concat(_config__WEBPACK_IMPORTED_MODULE_3__["UpperCasePerfix"], "-MAP")];
function addListenerToElement(node, type, callback) {
  var matches = type.match(_utils_eventReg__WEBPACK_IMPORTED_MODULE_1__["default"]);

  if (!matches) {
    return;
  }

  var capture = matches[1];
  var stop = matches[2] === 'catch';
  var eventType = matches[3];

  switch (eventType) {
    case 'tap':
      // listen down and up
      if (!node.__hasTapEvent) {
        node.__hasTapEvent = true;
        addTapEvent(node, {
          stop: stop,
          capture: capture
        });
      }

      node.addEventListener("".concat(_config__WEBPACK_IMPORTED_MODULE_3__["elementPrefix"], "-tap"), function (e) {
        return callback.call(node, {
          touches: e.detail.sourceEndEvent.changedTouches,
          // touchend没有touches，可以用changedTouches
          changedTouches: e.detail.sourceEndEvent.changedTouches,
          detail: {
            x: e.detail.x,
            y: e.detail.y
          },
          currentTarget: {
            id: e.detail.sourceEndEvent.currentTarget.id,
            dataset: e.detail.sourceEndEvent.currentTarget.dataset
          },
          target: {
            id: e.detail.sourceEndEvent.target.id,
            dataset: e.detail.sourceEndEvent.target.dataset
          },
          timeStamp: e.timeStamp,
          preventDefault: function preventDefault() {
            return e.detail.sourceEndEvent.preventDefault();
          },
          stopPropagation: function stopPropagation() {
            e.stopPropagation(); // 标记一下touchend，表示这个被阻止过

            e.detail.sourceEndEvent.__catchedTap = true;
          }
        });
      });
      return;

    case 'touchstart':
    case 'touchend':
    case 'touchmove':
    case 'touchcancel':
      node.addEventListener(eventType, function (e) {
        stop && e.stopPropagation();
        if (e.__frozenBySwipeBack) return; // ios 触发了滑动返回

        var detail = {
          x: e.pageX,
          y: e.pageY
        }; // detail is a read-only property, so re-define it ....

        Object.defineProperty(e, 'detail', {
          get: function get() {
            return detail;
          },
          configurable: true
        });
        return callback.call(node, e);
      }, {
        capture: capture
      }); // 组件可能会取消touchmove事件，并用tt-touchmove替换, 主要是swiper会用到

      if (eventType === 'touchmove') {
        node.addEventListener("".concat(_config__WEBPACK_IMPORTED_MODULE_3__["elementPrefix"], "-touchmove"), function (e) {
          var srcMoveEvent = e.detail.srcMoveEvent;
          return callback.call(node, {
            touches: srcMoveEvent.touches,
            changedTouches: srcMoveEvent.changedTouches,
            detail: {
              x: srcMoveEvent.pageX,
              y: srcMoveEvent.pageY
            },
            currentTarget: {
              id: e.currentTarget.id,
              dataset: e.currentTarget.dataset
            },
            target: {
              id: e.target.id,
              dataset: e.target.dataset
            },
            timeStamp: e.timeStamp,
            preventDefault: function preventDefault() {
              return srcMoveEvent.preventDefault();
            },
            stopPropagation: function stopPropagation() {
              return e.stopPropagation();
            }
          });
        });
      }

      return;

    case 'longtap':
    case 'longpress':
      // listen down and up
      if (!node.__hasTapEvent) {
        node.__hasTapEvent = true;
        addTapEvent(node, {
          stop: stop,
          capture: capture
        });
      }

      node.addEventListener("".concat(_config__WEBPACK_IMPORTED_MODULE_3__["elementPrefix"], "-longpress"), function (e) {
        e.longpressFired();
        callback(e);
      });
      return;
  }

  if (EVENT_BLACK_LIST.indexOf(eventType) === -1) {
    node.addEventListener(eventType, callback);
  }
}

function addTapEvent(node, options) {
  // 模拟合成tap事件和longpress事件，事件名为mp-tap和mp-longpress，以区别于polymer的事件
  var pressTimer;
  var pressStart;
  var ended;
  var stop = options.stop,
      capture = options.capture;

  var touchstartHandler = function touchstartHandler(e) {
    if (e.__handledTap) {
      return;
    }

    ended = false;
    pressStart = {
      x: e.touches[0].pageX,
      y: e.touches[0].pageY
    };
    clearTimeout(pressTimer);
    pressTimer = setTimeout(function () {
      // dispatch longpress event
      var pressEvent = new Event("".concat(_config__WEBPACK_IMPORTED_MODULE_3__["elementPrefix"], "-longpress"), {
        bubbles: !stop,
        composed: true
      });
      pressEvent.detail = pressStart;

      pressEvent.longpressFired = function () {
        ended = true;
      };

      node.dispatchEvent(pressEvent);
    }, PRESS_DELAY);
    e.__handledTap = true;
  };

  var touchmoveHandler = function touchmoveHandler(e) {
    if (ended || !pressStart) {
      return;
    }

    var dx = Math.abs(e.changedTouches[0].pageX - pressStart.x);
    var dy = Math.abs(e.changedTouches[0].pageY - pressStart.y);

    if (dx > TAP_DISTANCE || dy > TAP_DISTANCE) {
      ended = true;
      clearTimeout(pressTimer);
    }
  };

  node.addEventListener('touchstart', touchstartHandler, _supportsPassive__WEBPACK_IMPORTED_MODULE_2__["default"] ? {
    passive: _supportsPassive__WEBPACK_IMPORTED_MODULE_2__["default"],
    capture: capture
  } : capture);
  node.addEventListener('touchmove', touchmoveHandler, _supportsPassive__WEBPACK_IMPORTED_MODULE_2__["default"] ? {
    passive: _supportsPassive__WEBPACK_IMPORTED_MODULE_2__["default"],
    capture: capture
  } : capture);
  node.addEventListener('touchend', function (e) {
    if (ended || !pressStart) {
      return;
    }

    ended = true;
    clearTimeout(pressTimer); // 如果没有触发touchmove的判断，这里还要再来一下

    var dx = Math.abs(e.changedTouches[0].pageX - pressStart.x);
    var dy = Math.abs(e.changedTouches[0].pageY - pressStart.y);

    if (dx > TAP_DISTANCE || dy > TAP_DISTANCE) {
      return;
    } // dispatch tap event


    if (TAP_BLACK_LIST.indexOf(node.tagName) !== -1 && node.disabled) {
      // if element is disabled, 那就不发了
      return;
    }

    var tapEvent = new Event("".concat(_config__WEBPACK_IMPORTED_MODULE_3__["elementPrefix"], "-tap"), {
      bubbles: !stop,
      composed: true
    });
    tapEvent.detail = {
      x: e.changedTouches[0].pageX,
      y: e.changedTouches[0].pageY,
      sourceEndEvent: e
    };
    node.dispatchEvent(tapEvent);
  }, {
    capture: capture
  });
  node.addEventListener('touchcancel', function (e) {
    ended = true;
    clearTimeout(pressTimer);
  }, {
    capture: capture
  });
}

function removeListenerToElement(node, type, handler) {
  var matches = type.match(_utils_eventReg__WEBPACK_IMPORTED_MODULE_1__["default"]);

  if (!matches) {
    return;
  }

  var capture = matches[1];
  var eventType = matches[3];
  node.removeEventListener(eventType, handler, capture);
}

/***/ }),

/***/ "./src/utils/callBridge.js":
/*!*********************************!*\
  !*** ./src/utils/callBridge.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return callBridge; });
function callBridge(method, param, callback) {
  var g = self;
  var JSBridge = g.JSBridge;

  function done(res) {
    if (res && res.error) {
      if (method === 'internalAPI') {
        if (param && param.method !== 'onAppPerfEvent') {
          console.error("callInternalAPI error: ".concat(param.method), param, res);
        }
      } else {
        console.error("callBridge error: ".concat(method), param, res);
      }
    }

    if (callback) {
      callback(res);
    }
  }

  if (JSBridge) {
    JSBridge.call(method, param, done);
  } else {
    document.addEventListener('JSBridgeReady', function () {
      g.JSBridge.call(method, param, done);
    });
  }
}

/***/ }),

/***/ "./src/utils/callInternalAPI.js":
/*!**************************************!*\
  !*** ./src/utils/callInternalAPI.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return callInternalAPI; });
/* harmony import */ var _framework_startupParams__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/framework/startupParams */ "./src/framework/startupParams/index.js");
/* harmony import */ var _callBridge__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./callBridge */ "./src/utils/callBridge.js");


var ddOrAp =  true || false;
function callInternalAPI(method) {
  var param = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var callback = arguments.length > 2 ? arguments[2] : undefined;

  if (ddOrAp && !Object(_framework_startupParams__WEBPACK_IMPORTED_MODULE_0__["getStartupParams"])().isInternalApp) {
    var internalParams = {
      method: method,
      param: param
    };

    if ('viewId' in param) {
      internalParams.viewId = param.viewId;
    }

    Object(_callBridge__WEBPACK_IMPORTED_MODULE_1__["default"])('internalAPI', internalParams, callback);
  } else {
    Object(_callBridge__WEBPACK_IMPORTED_MODULE_1__["default"])(method, param, callback);
  }
}

/***/ }),

/***/ "./src/utils/config.js":
/*!*****************************!*\
  !*** ./src/utils/config.js ***!
  \*****************************/
/*! exports provided: elementPrefix, UpperCasePerfix */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "elementPrefix", function() { return elementPrefix; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UpperCasePerfix", function() { return UpperCasePerfix; });
var elementPrefix = 'mp';
var UpperCasePerfix = elementPrefix.toUpperCase();

/***/ }),

/***/ "./src/utils/consts.js":
/*!*****************************!*\
  !*** ./src/utils/consts.js ***!
  \*****************************/
/*! exports provided: PendingKeyType, PendingKeyId, PendingKeyData, PendingKeyOp, PendingValuePage, PendingValueComponent, OpSet, OpSplice, PayloadKeyMountedComponents, PayloadKeyUnmountedComponents, ComponentKeyId, ComponentKeyIs, ComponentKeyDiffProps, ComponentKeyOwnerId, DiffKeyUpdated, DiffKeyDeleted, ComponentKeyName, ComponentPropsId */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PendingKeyType", function() { return PendingKeyType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PendingKeyId", function() { return PendingKeyId; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PendingKeyData", function() { return PendingKeyData; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PendingKeyOp", function() { return PendingKeyOp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PendingValuePage", function() { return PendingValuePage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PendingValueComponent", function() { return PendingValueComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OpSet", function() { return OpSet; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OpSplice", function() { return OpSplice; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PayloadKeyMountedComponents", function() { return PayloadKeyMountedComponents; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PayloadKeyUnmountedComponents", function() { return PayloadKeyUnmountedComponents; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ComponentKeyId", function() { return ComponentKeyId; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ComponentKeyIs", function() { return ComponentKeyIs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ComponentKeyDiffProps", function() { return ComponentKeyDiffProps; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ComponentKeyOwnerId", function() { return ComponentKeyOwnerId; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DiffKeyUpdated", function() { return DiffKeyUpdated; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DiffKeyDeleted", function() { return DiffKeyDeleted; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ComponentKeyName", function() { return ComponentKeyName; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ComponentPropsId", function() { return ComponentPropsId; });
var PendingKeyType = 'PendingKeyType';
var PendingKeyId = 'PendingKeyId';
var PendingKeyData = 'PendingKeyData';
var PendingKeyOp = 'PendingKeyOp';
var PendingValuePage = 1;
var PendingValueComponent = 2;
var OpSet = 1;
var OpSplice = 2;
var PayloadKeyMountedComponents = 'PayloadKeyMountedComponents';
var PayloadKeyUnmountedComponents = 'PayloadKeyUnmountedComponents';
var ComponentKeyId = 'ComponentKeyId';
var ComponentKeyIs = 'ComponentKeyIs';
var ComponentKeyDiffProps = 'ComponentKeyDiffProps';
var ComponentKeyOwnerId = 'ComponentKeyOwnerId';
var DiffKeyUpdated = 'DiffKeyUpdated';
var DiffKeyDeleted = 'DiffKeyDeleted';
var ComponentKeyName = 'ComponentKeyName';
var ComponentPropsId = 'ComponentPropsId';

/***/ }),

/***/ "./src/utils/debounce.js":
/*!*******************************!*\
  !*** ./src/utils/debounce.js ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return debounce; });
function debounce(func, wait, options) {
  var lastArgs;
  var lastThis;
  var maxWait;
  var result;
  var timerId;
  var lastCallTime;
  var lastInvokeTime = 0;
  var leading = false;
  var maxing = false;
  var trailing = true; // Bypass `requestAnimationFrame` by explicitly setting `wait=0`.

  var useRAF = !wait && wait !== 0 && typeof requestAnimationFrame === 'function';
  wait = +wait || 0;

  if (options) {
    leading = options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? Math.max(+options.maxWait || 0, wait) : maxWait;
    trailing = 'trailing' in options ? options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs;
    var thisArg = lastThis;
    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function startTimer(pendingFunc, localWait) {
    if (useRAF) {
      return requestAnimationFrame(pendingFunc);
    }

    return setTimeout(pendingFunc, localWait);
  }

  function cancelTimer(id) {
    if (useRAF) {
      return cancelAnimationFrame(id);
    }

    clearTimeout(id);
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time; // Start the timer for the trailing edge.

    timerId = startTimer(timerExpired, wait); // Invoke the leading edge.

    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime;
    var timeSinceLastInvoke = time - lastInvokeTime;
    var timeWaiting = wait - timeSinceLastCall;
    return maxing ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime;
    var timeSinceLastInvoke = time - lastInvokeTime; // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.

    return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
  }

  function timerExpired() {
    var time = Date.now();

    if (shouldInvoke(time)) {
      return trailingEdge(time);
    } // Restart the timer.


    timerId = startTimer(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined; // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.

    if (trailing && lastArgs) {
      return invokeFunc(time);
    }

    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      cancelTimer(timerId);
    }

    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(Date.now());
  }

  function pending() {
    return timerId !== undefined;
  }

  var debounced = function debounced() {
    var time = Date.now();
    var isInvoking = shouldInvoke(time);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    lastArgs = args;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }

      if (maxing) {
        // Handle invocations in a tight loop.
        timerId = startTimer(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }

    if (timerId === undefined) {
      timerId = startTimer(timerExpired, wait);
    }

    return result;
  };

  debounced.cancel = cancel;
  debounced.flush = flush;
  debounced.pending = pending;
  return debounced;
}

/***/ }),

/***/ "./src/utils/escapeLogParams.js":
/*!**************************************!*\
  !*** ./src/utils/escapeLogParams.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return escapeLogParams; });
/* harmony import */ var _objectKeys__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./objectKeys */ "./src/utils/objectKeys.js");

function escapeLogParams(params) {
  if (!params) {
    return '';
  }

  if (typeof params === 'string') {
    return params;
  }

  return Object(_objectKeys__WEBPACK_IMPORTED_MODULE_0__["default"])(params).map(function (key) {
    var escaped = "".concat(key, "=");
    escaped += String(params[key]).replace(/,/g, ';').replace(/\^/g, '@').replace(/\=/g, '~');
    return escaped;
  }).join('^');
}

/***/ }),

/***/ "./src/utils/eventReg.js":
/*!*******************************!*\
  !*** ./src/utils/eventReg.js ***!
  \*******************************/
/*! exports provided: getPropsEventName, getPropsEvent, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getPropsEventName", function() { return getPropsEventName; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getPropsEvent", function() { return getPropsEvent; });
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types */ "./src/utils/types.js");

function getPropsEventName(name) {
  var isCatch = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var capture = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var str = '';
  str += isCatch ? 'catch' : 'bind';

  if (name) {
    str += name;
  }

  if (capture) {
    str = "capture-".concat(str);
  }

  return str;
}
function getPropsEvent(name) {
  var isCatch = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var capture = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var str = '';
  str += isCatch ? 'catch' : 'bind';

  if (name) {
    str += name;
  }

  if (capture) {
    str = "capture-".concat(str);
  }

  var handler = this.props[str];

  if (typeof handler === 'function') {
    return handler;
  }

  return _types__WEBPACK_IMPORTED_MODULE_0__["noop"];
}
var eventReg = /^(capture-)?(bind|catch)?([A-Za-z_]+)/;
/* harmony default export */ __webpack_exports__["default"] = (eventReg);

/***/ }),

/***/ "./src/utils/gerror.js":
/*!*****************************!*\
  !*** ./src/utils/gerror.js ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return gerror; });
var g = self;
function gerror(e) {
  if (!e.message) {
    e = new Error(e);
  }

  if (g.onerror) {
    g.onerror(e.message, e.sourceURL, e.line, e.column, e);
  } else {
    console.error(e);
  }
}

/***/ }),

/***/ "./src/utils/isDebug.js":
/*!******************************!*\
  !*** ./src/utils/isDebug.js ***!
  \******************************/
/*! exports provided: isDebug, isDebugFramework, isDebugSupported */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isDebug", function() { return isDebug; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isDebugFramework", function() { return isDebugFramework; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isDebugSupported", function() { return isDebugSupported; });
/* harmony import */ var _startupParams__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./startupParams */ "./src/utils/startupParams/index.js");

var debugMatchCache = {};
function isDebug() {
  return !!Object(_startupParams__WEBPACK_IMPORTED_MODULE_0__["getStartupParams"])().debug;
}
function isDebugFramework() {
  return isDebugSupported('framework');
}
function isDebugSupported(type) {
  var isMatch = debugMatchCache[type];

  if (typeof isMatch === 'undefined') {
    var _getStartupParams = Object(_startupParams__WEBPACK_IMPORTED_MODULE_0__["getStartupParams"])();

    var debug = _getStartupParams.debug;

    if (debug) {
      isMatch = !!debug.match(new RegExp("\\b".concat(type, "\\b")));
      debugMatchCache[type] = isMatch;
    }
  }

  return isMatch;
}

/***/ }),

/***/ "./src/utils/log.js":
/*!**************************!*\
  !*** ./src/utils/log.js ***!
  \**************************/
/*! exports provided: default, debug */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return log; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "debug", function() { return debug; });
/* harmony import */ var _isDebug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isDebug */ "./src/utils/isDebug.js");


function internalLog(args) {
  console.log.apply(console, args);
}

function log() {
  if (Object(_isDebug__WEBPACK_IMPORTED_MODULE_0__["isDebug"])()) {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    internalLog(args);
  }
}
function debug(type) {
  if (Object(_isDebug__WEBPACK_IMPORTED_MODULE_0__["isDebugSupported"])(type)) {
    for (var _len2 = arguments.length, rest = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      rest[_key2 - 1] = arguments[_key2];
    }

    internalLog(["[".concat(type, "]")].concat(rest));
  }
}

/***/ }),

/***/ "./src/utils/mergeArray.js":
/*!*********************************!*\
  !*** ./src/utils/mergeArray.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return mergeArray; });
function mergeArray(target, from) {
  from.forEach(function (f) {
    if (target.indexOf(f) === -1) {
      target.push(f);
    }
  });
  return target;
}

/***/ }),

/***/ "./src/utils/objectKeys.js":
/*!*********************************!*\
  !*** ./src/utils/objectKeys.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return objectKeys; });
/* harmony import */ var _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/typeof */ "./node_modules/@babel/runtime/helpers/typeof.js");
/* harmony import */ var _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__);

function objectKeys(obj) {
  if (obj && _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0___default()(obj) === 'object') {
    return Object.keys(obj);
  }

  return [];
}

/***/ }),

/***/ "./src/utils/reportError.js":
/*!**********************************!*\
  !*** ./src/utils/reportError.js ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return reportError; });
/* harmony import */ var _callInternalAPI__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./callInternalAPI */ "./src/utils/callInternalAPI.js");
/* harmony import */ var _callBridge__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./callBridge */ "./src/utils/callBridge.js");
/* harmony import */ var _system__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./system */ "./src/utils/system.js");
/* harmony import */ var _escapeLogParams__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./escapeLogParams */ "./src/utils/escapeLogParams.js");




var did = '';
var version = '';
var appId = '';
var fromIDE;
var cluePID;

function stringify(obj) {
  var arr = [];

  for (var key in obj) {
    if (obj.hasOwnProperty(key)) {
      arr.push("".concat(encodeURIComponent(key), "=").concat(encodeURIComponent(obj[key])));
    }
  }

  return arr.join('&');
}

function _reportError(code, e) {
  if (appId === '') {
    var startupParams = window.JSBridge && window.JSBridge.startupParams;

    if (startupParams && startupParams.version) {
      version = startupParams.version;
      fromIDE = startupParams.fromIDE;
      appId = startupParams.appId;
    }

    if (cluePID === undefined && startupParams && startupParams.cluePID) {
      cluePID = startupParams.cluePID;
    }
  }

  if (!fromIDE && did !== 'unknown') {
    var ua = navigator.userAgent;
    var error = e.error || {};
    var col = error.column || "_".concat(e.col || '-1');
    var line = error.line || "_".concat(e.line || '-1');
    var msg = "".concat(error.message || e.msg, "^").concat(line, "^").concat(col);
    var errorUrl = error.sourceURL || "_".concat(e.url || '__errorUrl');
    var option = {
      pid: 'miniprogram',
      code: code,
      msg: msg,
      uid: did,
      page: location.href,
      ua: ua,
      rel: version,
      c1: _system__WEBPACK_IMPORTED_MODULE_2__["SDKVersion"],
      c2: appId,
      c3: _system__WEBPACK_IMPORTED_MODULE_2__["systemVersion"],
      c4: errorUrl,
      c5: error.stack
    };
    var fsp = new Image();
    fsp.src = "https://gm.mmstat.com/fsp.1.1?".concat(stringify(option));

    if (appId !== '') {
      var fspForSingleApp = new Image();
      option.pid = "miniprogram-".concat(cluePID || appId);
      fspForSingleApp.src = "https://gm.mmstat.com/fsp.1.1?".concat(stringify(option));
    }

    Object(_callBridge__WEBPACK_IMPORTED_MODULE_1__["default"])('remoteLog', {
      type: 'error',
      seedId: 'H5_CUSTOM_ERROR',
      param1: "H5_CUSTOM_ERROR_TINY_".concat(code),
      param3: Object(_escapeLogParams__WEBPACK_IMPORTED_MODULE_3__["default"])({
        errorMsg: msg,
        errorUrl: errorUrl,
        SDKVersion: _system__WEBPACK_IMPORTED_MODULE_2__["SDKVersion"]
      })
    });
  }
}

function reportError(code, e) {
  if ( true && !did) {
    Object(_callInternalAPI__WEBPACK_IMPORTED_MODULE_0__["default"])('getUserInfo', function (result) {
      if (result && result.userId) {
        did = result.userId;

        _reportError(code, e);
      } else {
        Object(_callInternalAPI__WEBPACK_IMPORTED_MODULE_0__["default"])('getConfig', {
          configKeys: ['did']
        }, function (result) {
          if (result && result.data && result.data.did) {
            did = result.data.did;
          } else {
            did = 'unknown';
          }

          _reportError(code, e);
        });
      }
    });
  } else {
    _reportError(code, e);
  }
}

/***/ }),

/***/ "./src/utils/requestAnimationFrame.js":
/*!********************************************!*\
  !*** ./src/utils/requestAnimationFrame.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
window.requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame;
/* harmony default export */ __webpack_exports__["default"] = (window.requestAnimationFrame || (window.requestAnimationFrame = function (callback) {
  typeof callback === 'function' && setTimeout(function () {
    callback();
  }, 17);
}));

/***/ }),

/***/ "./src/utils/setData.js":
/*!******************************!*\
  !*** ./src/utils/setData.js ***!
  \******************************/
/*! exports provided: default, spliceData, getOpStr, getOpFn */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return setData; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "spliceData", function() { return spliceData; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getOpStr", function() { return getOpStr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getOpFn", function() { return getOpFn; });
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _objectKeys__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./objectKeys */ "./src/utils/objectKeys.js");
/* harmony import */ var _stringToPath__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stringToPath */ "./src/utils/stringToPath.js");
/* harmony import */ var _shallowEqual__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./shallowEqual */ "./src/utils/shallowEqual.js");
/* harmony import */ var _consts__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./consts */ "./src/utils/consts.js");


function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }






function isNumber(value) {
  return typeof value === 'number';
}

function isArray(obj) {
  return Array.isArray(obj);
}

function clone(obj, assumeArray) {
  if (!obj) {
    return assumeArray ? [] : {};
  } else if (isArray(obj)) {
    return obj.slice();
  }

  return _objectSpread({}, obj);
}

function set(dest, src, path, changeCallback, deepLevel) {
  var currentPath = path[0];

  if (deepLevel && dest === src || !dest) {
    dest = clone(src, isNumber(currentPath));
  }

  if (path.length === 1) {
    return changeCallback(dest, currentPath);
  }

  if (src) {
    src = src[currentPath];
  }

  dest[currentPath] = set(dest[currentPath], src, path.slice(1), changeCallback, true);
  return dest;
}

function setData(data, changedData) {
  var ret = _objectSpread({}, data);

  Object(_objectKeys__WEBPACK_IMPORTED_MODULE_1__["default"])(changedData).forEach(function (pathString) {
    var path = Object(_stringToPath__WEBPACK_IMPORTED_MODULE_2__["default"])(pathString);
    set(ret, ret, path, function (clonedObj, finalPath) {
      clonedObj[finalPath] = changedData[pathString];
      return clonedObj;
    });
  });

  if (Object(_shallowEqual__WEBPACK_IMPORTED_MODULE_3__["default"])(ret, data)) {
    return data;
  }

  return ret;
}
function spliceData(data, changedData) {
  var ret = _objectSpread({}, data);

  Object(_objectKeys__WEBPACK_IMPORTED_MODULE_1__["default"])(changedData).forEach(function (pathString) {
    var path = Object(_stringToPath__WEBPACK_IMPORTED_MODULE_2__["default"])(pathString);
    set(ret, ret, path, function (clonedObj, finalPath) {
      var arr = clonedObj[finalPath];

      if (Array.isArray(arr)) {
        arr = arr.concat();
        arr.splice.apply(arr, changedData[pathString]);
        clonedObj[finalPath] = arr;
      }

      return clonedObj;
    });
  });

  if (Object(_shallowEqual__WEBPACK_IMPORTED_MODULE_3__["default"])(ret, data)) {
    return data;
  }

  return ret;
}
function getOpStr(op) {
  return op === setData ? _consts__WEBPACK_IMPORTED_MODULE_4__["OpSet"] : _consts__WEBPACK_IMPORTED_MODULE_4__["OpSplice"];
}
function getOpFn(op) {
  return op === _consts__WEBPACK_IMPORTED_MODULE_4__["OpSet"] ? setData : spliceData;
}

/***/ }),

/***/ "./src/utils/shallowEqual.js":
/*!***********************************!*\
  !*** ./src/utils/shallowEqual.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return shallowEqual; });
/* harmony import */ var _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/typeof */ "./node_modules/@babel/runtime/helpers/typeof.js");
/* harmony import */ var _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _objectKeys__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./objectKeys */ "./src/utils/objectKeys.js");


function shallowEqual(objA, objB) {
  if (objA === objB) {
    return true;
  }

  if (_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0___default()(objA) !== 'object' || objA === null || _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0___default()(objB) !== 'object' || objB === null) {
    return false;
  }

  var keysA = Object(_objectKeys__WEBPACK_IMPORTED_MODULE_1__["default"])(objA);
  var keysB = Object(_objectKeys__WEBPACK_IMPORTED_MODULE_1__["default"])(objB);
  var len = keysA.length;

  if (len !== keysB.length) {
    return false;
  }

  for (var i = 0; i < len; i++) {
    var key = keysA[i];

    if (!objB.hasOwnProperty(key)) {
      return false;
    }

    var valueA = objA[key];
    var valueB = objB[key];

    if (valueA !== valueB) {
      return false;
    }
  }

  return true;
}

/***/ }),

/***/ "./src/utils/startsWith.js":
/*!*********************************!*\
  !*** ./src/utils/startsWith.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return startsWith; });
function startsWith(str, prefix) {
  if (!str || !prefix) {
    return false;
  }

  return str.slice(0, prefix.length) === prefix;
}

/***/ }),

/***/ "./src/utils/startupParams/index.js":
/*!******************************************!*\
  !*** ./src/utils/startupParams/index.js ***!
  \******************************************/
/*! exports provided: getStartupParams, setStartupParams */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getStartupParams", function() { return getStartupParams; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setStartupParams", function() { return setStartupParams; });
/* harmony import */ var _startupParamsHolder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./startupParamsHolder */ "./src/utils/startupParams/startupParamsHolder.js");

var g = self;
function getStartupParams() {
  if (g.__mpStartupParams) {
    return g.__mpStartupParams;
  }

  return Object(_startupParamsHolder__WEBPACK_IMPORTED_MODULE_0__["getValue"])() || {};
}
var setStartupParams = _startupParamsHolder__WEBPACK_IMPORTED_MODULE_0__["setValue"];

/***/ }),

/***/ "./src/utils/startupParams/startupParamsHolder.js":
/*!********************************************************!*\
  !*** ./src/utils/startupParams/startupParamsHolder.js ***!
  \********************************************************/
/*! exports provided: setValue, getValue */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setValue", function() { return setValue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getValue", function() { return getValue; });
/* harmony import */ var _objectKeys__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../objectKeys */ "./src/utils/objectKeys.js");

var v;
function setValue(o) {
  if (Object(_objectKeys__WEBPACK_IMPORTED_MODULE_0__["default"])(o).length) {
    v = o;
  }
}
function getValue() {
  return v;
}
self.__getStartupParams = getValue;

/***/ }),

/***/ "./src/utils/stringToPath.js":
/*!***********************************!*\
  !*** ./src/utils/stringToPath.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return stringToPath; });
var reLeadingDot = /^\./; // a..b
// a[][]b

var rePropName = /[^.[\]]+|\[(?:(-?\d+)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
/** Used to match backslashes in property paths. */

var reEscapeChar = /\\(\\)?/g;
var stringToPathCache = {};
function stringToPath(stringPath) {
  if (stringToPathCache[stringPath]) {
    return stringToPathCache[stringPath];
  }

  var result = [];

  if (reLeadingDot.test(stringPath)) {
    result.push('');
  }

  stringPath.replace(rePropName, function (match, num, quote, str) {
    var part = match;

    if (quote) {
      part = str.replace(reEscapeChar, '$1');
    } else if (num) {
      part = parseInt(num, 10);
    }

    result.push(part);
  });
  stringToPathCache[stringPath] = result;
  return result;
}

/***/ }),

/***/ "./src/utils/supportsPassive.js":
/*!**************************************!*\
  !*** ./src/utils/supportsPassive.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// Test via a getter in the options object to see if the passive property is accessed
var supportsPassive = false;

try {
  var n = null;
  var opts = Object.defineProperty({}, 'passive', {
    get: function get() {
      supportsPassive = true;
    }
  });
  window.addEventListener('testPassive', n, opts);
  window.removeEventListener('testPassive', n, opts);
} catch (e) {}

/* harmony default export */ __webpack_exports__["default"] = (supportsPassive);

/***/ }),

/***/ "./src/utils/system.js":
/*!*****************************!*\
  !*** ./src/utils/system.js ***!
  \*****************************/
/*! exports provided: systemVersion, UCVersion, isAndroid, isIOS, isIDE, SDKVersion, isUC, isNativeComponent, compareVersion, logSystemInfo, compareSystemVersion, compareUCVersion, iOSVersion */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "systemVersion", function() { return systemVersion; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UCVersion", function() { return UCVersion; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isAndroid", function() { return isAndroid; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isIOS", function() { return isIOS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isIDE", function() { return isIDE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SDKVersion", function() { return SDKVersion; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isUC", function() { return isUC; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isNativeComponent", function() { return isNativeComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "compareVersion", function() { return compareVersion; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "logSystemInfo", function() { return logSystemInfo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "compareSystemVersion", function() { return compareSystemVersion; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "compareUCVersion", function() { return compareUCVersion; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "iOSVersion", function() { return iOSVersion; });
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./log */ "./src/utils/log.js");

var ua = navigator.userAgent || navigator.swuserAgent;

var _systemVersion = ua.match(/AlipayClient\/(\d+\.\d+\.\d+)/);

var _UCVersion = ua.match(/UCBS\/(\d+\.\d+)/); // expose all functions for ant fortune app


var systemVersion = _systemVersion && _systemVersion[1] || '100.0.0';
var UCVersion = _UCVersion && _UCVersion[1] || '2.12';
var isAndroid = ua.indexOf('Android') > -1;
var isIOS = !!ua.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/);
var isIDE = ua.indexOf('AlipayIDE') > -1;
var SDKVersion = '0.0.1';
var caches = {};
var cacheIntArray = {};
var isUC = !!(_UCVersion && _UCVersion[1]);
var isNativeComponent = isUC || isIOS;
var iOSVersion = /iPhone OS (\d{2})/.exec(ua);

function toIntArray(v) {
  if (cacheIntArray[v]) {
    return cacheIntArray[v];
  }

  var ret = [];
  var version = v.split('.');

  for (var i = 0; i < version.length; i += 1) {
    ret.push(parseInt(version[i], 10));
  }

  cacheIntArray[v] = ret;
  return ret;
}

function compareVersion(version, targetVersion) {
  if (version && targetVersion) {
    var key = "".concat(version, "__").concat(targetVersion);

    if (key in caches) {
      return caches[key];
    }

    version = toIntArray(version);
    targetVersion = toIntArray(targetVersion);

    for (var i = 0, n1, n2; i < version.length; i += 1) {
      n1 = targetVersion[i] || 0;
      n2 = version[i] || 0;

      if (n1 > n2) {
        caches[key] = -1;
        break;
      }

      if (n1 < n2) {
        caches[key] = 1;
        break;
      }
    }

    caches[key] = caches[key] || 0;
    return caches[key];
  }

  return 0;
}

function logSystemInfo() {
  Object(_log__WEBPACK_IMPORTED_MODULE_0__["default"])('version: '.concat(SDKVersion));
}

function compareSystemVersion(targetVersion) {
  return compareVersion(systemVersion, targetVersion);
}

function compareUCVersion(targetVersion) {
  return compareVersion(UCVersion, targetVersion);
}



/***/ }),

/***/ "./src/utils/trackerStore.js":
/*!***********************************!*\
  !*** ./src/utils/trackerStore.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ({});

/***/ }),

/***/ "./src/utils/types.js":
/*!****************************!*\
  !*** ./src/utils/types.js ***!
  \****************************/
/*! exports provided: isArray, isObject, noop, getType */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isArray", function() { return isArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isObject", function() { return isObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "noop", function() { return noop; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getType", function() { return getType; });
function isArray(obj) {
  return Object.prototype.toString.call(obj) === '[object Array]';
}
function isObject(obj) {
  return Object.prototype.toString.call(obj) === '[object Object]';
}
function noop() {
  /* no opration */
}
/**
 * 获取类型名字
 * @param x
 */

function getType(x) {
  return Object.prototype.toString.call(x).slice(8, -1);
}

/***/ }),

/***/ "./src/web-components/button.js":
/*!**************************************!*\
  !*** ./src/web-components/button.js ***!
  \**************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _babel_runtime_helpers_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/taggedTemplateLiteral */ "./node_modules/@babel/runtime/helpers/taggedTemplateLiteral.js");
/* harmony import */ var _babel_runtime_helpers_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/get */ "./node_modules/@babel/runtime/helpers/get.js");
/* harmony import */ var _babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _polymer_polymer__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @polymer/polymer */ "./node_modules/@polymer/polymer/polymer-element.js");
/* harmony import */ var _utils_config__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @/utils/config */ "./src/utils/config.js");
/* harmony import */ var _mixins__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./mixins */ "./src/web-components/mixins/index.js");








var _templateObject;

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_6___default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_6___default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_5___default()(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }




var documentContainer = document.createElement('div');
documentContainer.setAttribute('style', 'display: none;');
documentContainer.innerHTML = "<dom-module id=\"button-style\">\n  <template>\n    <style>\n      ::slotted(*) {\n        -webkit-user-select: none;\n        user-select: none;\n      }\n\n      :host {\n        position: relative;\n        display: block;\n        margin-left: auto;\n        margin-right: auto;\n        padding-left: 14px;\n        padding-right: 14px;\n        box-sizing: border-box;\n        font-size: 18px;\n        text-align: center;\n        text-decoration: none;\n        line-height: 2.55555556;\n        border-radius: 5px;\n        color: rgba(0,0,0,1);\n        background-color: rgba(244,245,246,1);\n        border-color: rgba(216,216,216,1);\n        -webkit-tap-highlight-color: transparent;\n        -webkit-user-select: none;\n        user-select: none;\n      }\n\n      :host:after {\n        content: \" \";\n        width: 200%;\n        height: 200%;\n        position: absolute;\n        top: 0;\n        left: 0;\n        border: 1px solid rgba(0, 0, 0, 0.2);\n        -webkit-transform: scale(0.5) translateZ(0);\n        transform: scale(0.5) translateZ(0);\n        -webkit-transform-origin: 0 0;\n        transform-origin: 0 0;\n        box-sizing: border-box;\n        border-radius: 10px;\n      }\n\n      :host([type=primary]) {\n        color: rgba(255,255,255,1);\n        border-color: rgba(248,89,89,1);\n        background-color: rgba(248,89,89,1);\n      }\n  \n      :host([type=warn]) {\n        color: #FFFFFF;\n        background-color: #E64340;\n      }\n\n      host[disabled][type=default] */\n      :host([disabled]:not([type])) {\n        opacity: 0.6;\n        background-color: rgba(244,245,246,1);\n        color: rgba(0, 0, 0, 0.3);\n      }\n\n      :host([disabled][type=primary]) {\n        background-color: rgba(252,192,193,1);\n        color: rgba(255,255,255,0.4)\n      }\n\n      :host([disabled][type=warn]) {\n        background-color: #EC8B89;\n      }\n      \n      :host([type=primary][plain]) {\n        color: rgba(248,89,89,1);\n        border: 1px solid rgba(248,89,89,1);\n        background-color: transparent;\n      }\n\n      :host([type=primary][plain][disabled]) {\n        color: rgba(0, 0, 0, 0.2);\n        border-color: rgba(0, 0, 0, 0.2);\n      }\n\n      :host([type=primary][plain]):after {\n        border-width: 0;\n      }\n\n      :host([type=default][plain]) {\n        color: rgba(0,0,0,1);\n        border: 1px solid rgba(0, 0, 0, 0.2);\n        background-color: transparent;\n      }\n\n      :host([type=default][plain][disabled]) {\n        color: rgba(0, 0, 0, 0.2);\n        border-color: rgba(0, 0, 0, 0.2);\n      }\n\n\n      :host([type=default][plain]):after {\n        border-width: 0;\n      }\n\n      :host([plain]) {\n        color: #353535;\n        border: 1px solid #353535;\n        background-color: transparent;\n      }\n\n      :host([plain][disabled]) {\n        color: rgba(0, 0, 0, 0.2);\n        border-color: rgba(0, 0, 0, 0.2);\n      }\n\n      :host([plain]):after {\n        border-width: 0;\n      }\n    \n      :host([type=warn][plain]) {\n        color: #e64340;\n        border: 1px solid #e64340;\n        background-color: transparent;\n      }\n\n      :host([type=warn][plain][disabled]) {\n        color: rgba(0, 0, 0, 0.2);\n        border-color: rgba(0, 0, 0, 0.2);\n      }\n\n      :host([type=warn][plain]):after {\n        border-width: 0;\n      }\n    \n      :host([size=mini]) {\n        display: inline-block;\n        line-height: 2.3;\n        font-size: 14px;\n        padding: 0 1.34em;\n      }\n\n      :host([loading][type=primary]) {\n        color: rgba(255, 255, 255, 0.6);\n        background-color: rgba(222,79,79,1);\n      }\n      :host([loading][type=primary][plain]) {\n        color: rgba(248,89,89,1);\n        background-color: transparent;\n      }\n\n      :host([loading][type=default]) {\n        color: rgba(34,34,34,0.6);\n        background-color: rgba(219,220,220,1);\n        border-color: rgba(216,216,216,1);\n      }\n      \n      :host([loading][type=default][plain]) {\n        color: #353535;\n        background-color: transparent;\n      }\n      \n      :host([loading][type=warn]) {\n        color: rgba(255, 255, 255, 0.6);\n        background-color: #CE3C39;\n      }\n\n      :host([loading][type=warn][plain]) {\n        color: #e64340;\n        background-color: transparent;\n      }\n    \n      @-webkit-keyframes button-loading-animate {\n        0% {\n          -webkit-transform: rotate3d(0, 0, 1, 0deg);\n          transform: rotate3d(0, 0, 1, 0deg);\n        }\n\n        100% {\n          -webkit-transform: rotate3d(0, 0, 1, 360deg);\n          transform: rotate3d(0, 0, 1, 360deg);\n        }\n      }\n\n      @keyframes button-loading-animate {\n        0% {\n          -webkit-transform: rotate3d(0, 0, 1, 0deg);\n          transform: rotate3d(0, 0, 1, 0deg);\n        }\n\n        100% {\n          -webkit-transform: rotate3d(0, 0, 1, 360deg);\n          transform: rotate3d(0, 0, 1, 360deg);\n        }\n      }\n\n      :host(.button-hover) {\n        color: rgba(34,34,34,0.6);\n        background-color: rgba(219,220,220,1);\n        border-color: rgba(216,216,216,1);\n      }\n      \n      :host(.button-hover[plain]) {\n        color: rgba(53, 53, 53, 0.6);\n        border-color: rgba(53, 53, 53, 0.6);\n        background-color: transparent;\n      }\n      \n\n      :host(.button-hover[type=primary]) {\n        color: rgba(255, 255, 255, 0.6);\n        background-color: rgba(222,79,79,1);\n      }\n\n      :host(.button-hover[type=primary][plain]) {\n        color: rgba(248,89,89,0.6);\n        border-color: rgba(248,89,89,0.6);\n        background-color: transparent;\n      }\n\n      :host(.button-hover[loading][type=primary][plain]) {\n        color: rgba(248,89,89,1);\n      }\n\n      :host(.button-hover[type=default][plain]) {\n        color: rgba(34,34,34,0.6);\n        border: 1px solid rgba(0, 0, 0, 0.1);\n        background-color: transparent;\n      }\n\n      :host(.button-hover[loading][type=default][plain]) {\n        color: rgba(34,34,34,1);\n      }\n    \n      :host(.button-hover[type=warn]) {\n        color: rgba(255, 255, 255, 0.6);\n        background-color: #CE3C39;\n      }\n\n      :host(.button-hover[type=warn][plain]) {\n        color: rgba(230, 67, 64, 0.6);\n        border-color: rgba(230, 67, 64, 0.6);\n        background-color: transparent;\n      }\n    \n\n      #icon {\n        display: none;\n      }\n      :host([loading]) #icon {\n        display: inline-block;\n        width: 18px;\n        height: 18px;\n        vertical-align: middle;\n        -webkit-animation: button-loading-animate 1s steps(12, end) infinite;\n        animation: button-loading-animate 1s steps(12, end) infinite;\n        background: transparent url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACwAAAAsCAYAAAAehFoBAAAAAXNSR0IArs4c6QAABQ9JREFUWAntmF2IVVUUx+9k5ViJn1MWJpMoioMyZRYYFEVCWVFPvQmCpeiLr74HvYojKUSPPkovvYiiGNijVA8SxkRphR/5nVpO5fT7Xc46s+/cc+7HjPdeH1zwn33O3vus9TvrrLP3uVOpPLDOZqBvuu7Hx8efxsdLaDlagAbQQvQQuoKuocvoR3Sir6/vd9op25SAgZxDxLfRy2gQ6UdA24cbnDvnDPoaHQTeG2rLDNCyAdrP5HfRe8jjRoAzJo3HebRjjB9QgN+mbclaBgZ2HR43o3nI65plVDDnBGBZ5i2ZT4E+StvUmgID6pz30QfI4wAIYLoqp9BJ9Cu6iqxZzZq2ngfRq+hF9CjSzyNZ67H6HO0DfJy21JxYasDq/CNkdjXnmyntJvoS+SK19Ejx9zjz30L6XIQCNvwepm8X/v6mLbRS4CyzH3NVwMYj/Y++r9ChRo4Lo2Wd+J7F4Sak/3gX4skJvbMs042AfblUPHod/on24myUdtoG+Bqc7EWxDMpjHGOM0NZZITCOhpm5FcW47Xk0gqO2lyKuKzViWRrW70oUwM7fQaxDHqRm9moMBzPp+BBZ/HezwRu0e+41rL7xaSJMTryoQsv1CSzWfI3VATP6OnoMWatqDO3HsW9/RyyD3oHzSJBx3EG3eZBaDTB3NJtBgTUvNsu+XD/b0Ukjxrf4/wyZ4dB2mKzv3GqA6X0FuRqYWWEthWOoW/YFgdxIZJDNBG5BuU0GHmJE0JDZvZPP7vABsVzPd6OU6500bD5A6t2VBtC/mQQ9ibptbkY+YXdCMz0E23O0VcuBOVuFIrMOjnLHpTuOEzphxHSt/wZFHdtujFgpsOuh2fVl8w5PoV7ZEQLL5iainkdVM+VhFnia4Ysx0IP2NDEjmWb4mWBIgV2kza7SXCF6ZW4mwSbw4gCJTs8jwzHWS+BzQAiqlWb4n2wwnVi9ogd/ZEiTGeVR0+nbOR9Zx9oTqGtrcDXixB93t7MTp5Vf4ji9C0tgbjYgtMCXs/NuN9bwm0nQfHlNgc1wZNe5biRnPOiBCVgYO68NJljorsPWshpEvTJ3uZBJzTnzAzpHM7pYixezJc7M+rrWENMXTskWx7HUTpCzJfqVdAEJHBNWcNxtM6NmV2B3OdAmfkmnGWas8hMSNrK8jjv24q5Yll1/oBZmV4jJwN/TZ8Fby0pYfyh2y1JYY5ttv2tyqwEm9X6P+uUfGbZ9gTt/Kr+iQwfZk/TzIOrXSHdgivKsRq4BrvZUKt/R3kIB7R2+gUOddcTwba36LzB5zKoSvG7jqgPmjlzSTqC0ll0tNnQCGp/C+cMhWGyFvZ2+bJxXzYFCw5HfoMMoMu0N/IWO4+gS7bSNGP04CdioVd+dm8TwX2F11gjYsdfQIBJah7Y+AT/uT+NU520boGbRElD60G88UcvxWlF26a+m3rbQsse1nsElKBw71wBm4Af0G869iaaGP2t1DjKrJkQ/4VdgYS+VwTLWGNgJBNHxahS/+XSsCWlAM/8Hcmv3JlwW/eeLY/730+XJ5cqPqfiRENelrR9a1xvBMt4c2Eka4M/SrEXxcsQjNEMex3l6I/alpZQCxjyvvwBoYc0yVmNmr2UD2mwtQ8uR4AJE4KkA+/JeAdZrW7K2gMMj4C5zS5Ebio9b8MnAnqvIcNSqm5PfLdaqfW3ZlIDTCMBbl08ifxNas75YtsK68AtoTfvIrwJZtxnQ/8Dumwz8D1o3mfMxYRE2AAAAAElFTkSuQmCC) no-repeat;  background-size: 100%;\n      }\n\n      :host([loading][plain]) #icon {\n        background: transparent url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACwAAAAsCAYAAAAehFoBAAAAAXNSR0IArs4c6QAACChJREFUWAntmVtsVVUax/fal9Me2tMDnnMqmmIYkmGSNl4GbaVIx2g0UQejT8YXk0lUiIWmJRCYN0hMjAED2NKakHmYB5/IxBdfiEaDBNNwadQHIEwwM15I6c1TSm+nZ1/m96127zmHnpZy6eHFle6z9l6X7/uvb323tWoYv5fllYC6W/IdHR0P5X2/Sfn+H6GV8g0jYwRBWpmmaSj1W+C6o7SPGKb57wrHOX348OGrd8PzjgDv3bs3OT4+/jKMn/aDYK2SYhgm3yowDJtHmUr+lPJc19bdLCAIApPGnxj7jeM4/wL8b7cL/rYA79+/v3JwcHALbF+Fe6UAcYPAVkEgAhVACqnaSFi6LPnxfF8DZoylF0S79DNuhhV+mk6nP4Xu5FKBLxlwa3t7o+F5f4PwKgEGMy1BVwCJREsABpTp+74GDmBbL4hxc4BtWQBzR1GXD7o7O79aCuhbAhYmra2tr5mW9bpsNcyswi1HJYTPBQD1IdBfeLK2bY9Io+u6Kc+y0qbrruXzL+j3UzCM8S6q4+idEJo89B3rOXq0h/maIG0ly6KA2aoYKvAOMxuVxY4CngWIZESk41D+zM3lTh87dmxJW7p79+6q6enpl1CYdwLfXw04oSdS1roP/S9qa2v/Dt/pkmiF70IdQqitre1d6kYZA7hZYzJND6l+PpVOn/jnIoQXoivtO3fujOfz+beg+S4qo20B5dC6zRq+ONrV1b6QpBcEvH379i3Q3uJh2SIJfizA30AKXT09PVcWA7TUvvb29sfyrtsF8DT0Z43WMCxAdXV3d3eWoiOWO6+0dnQ8wZa9KSYhK8XAxOyvxmKxA11dXXflRwuZnTlzZqCxsfEEYDfDoJY+E7CCaWNzc/Nl+ucJRnxnUUENKpTrviFA6fANH3MwjDGvuvrjO/GbRcRLfLBb19i5rXRpQxVV5DFRu/dF52+eMg+w53nPId0VzPL0Y1kzKh7/5JMPP8zePPlefQtofF8rQvLFuDFow/e8h6amprbdzKMI8J49exK4yedkkEymkuWeOPrRR/+5eeK9/kbVvoNpN/x0iBQA8Hhv165d6UJeRYAJt89gZDb65FEHIB5j3teFE5bzPZNK/QO2o3gOwWDyJHCDbxfyLAJMRwPLIm5qIwvYphOsPFc4YTnf50L0YYwHpZj1uYD+ayHPCDBuLEVnBrCuPAzKEef7CgeX472qquozdlU22OGRsN+wY8eOP4S8I8BsQz36g6UpUQUpVxaLOLND7v3vgQMHbqC/3yJlcVMCSZ5XQk4RYCsWW21Zlkt08Gn0UIcL4aCy177/pQQSpAsMnfX9OcSg8wL5IAFPsBJd5JvEZVDq+1HwVJdJS7UwUVOR9MMhjggwSKtQBd+wba0RnuOMhYPKXYPxGjxnkyzfR9BGXYjh/4BxIeQJwVxkMx5OJO4bYHa3n+ChHTERT/xyJOFIh1lBnocDRCAW6o2MjMjK7kuprq4WQ7MBa2OAFlse4YwkzDbcAN0DsyqDbvh+Nd9l88GFkpmcnEyD4+eoTan/hu8RYBCOkUOsFAUW0CxJAOuEJBxcrpoD6jXyiBdCfhhhlNBHgEXCAjTUA/QjxYSfwknlrA8dOjQNlpK8o3y4qampBr15BAX3AO07BMezZ89eKifQkBdgY5lMxmpoaLA2b95srlu3zrh48SLerVCZbfsKeiuOQhfe6yQ3DomUq4a5EoMfGhoyScZUNptVx48f1662CPCRI0dGOe0OkI9y7WD6HhJ2TfNP5QIa8uFAa5OTO+vXrzfXrFljtbS0IHB9mNBDInchX6zuR3EPImIdxD2vcevWrU5IbLlrYXvq1Kn49evXTYxOyVNRURFJV/gXAeYk+4Ov1DThUPyxi9I4lZWVjy030JD+tm3b4uiuWVdXx0ZbTjwet/v7+72wX+rI6OSjr68v39TcLEmHRBYdxjmqrN60adNVDoQTMma5iuwkAqtZuXJlMDY2pgBtJBKJHBmjBLSoFElYWh+vr/+exgluHZGxK6DJQ/znSx0IIyp3+YJRWTU1Nat4zIGBAXt4eNjmpKH27ds3L3DNA8y2cFXgnhbDE2XnJ8h7XsXExMSLywEaCdonT57MEN00FlTBTKVSCn6ThcYWyqRIJcLG8+fPZ5/cuDEg5NWSdgZijUSfGAtZ+0RLy2Bfb++SrqZCegvVgJXb0AcB5sxYlspzbxfjEpTvCS5SpkrNQ11LF7HY99ransVrrBWPwSgOI0RCpfJGLHYhk0xehqEcpW67MM/Ez8ot6CouZ1x0N5jk4IB0A8d1Jzj2jwqvUoQXBCyDIWwPZbObMLxHuEdyhQi37TrXgNq4o9SlmZmZX/GdRYZRipG0ia729vYm0c8Mvpb7GjfA97sClOKzixOdnZ3DC4EVGosClgEQkuvWR9HpeiGEjwn9Yl4cNsmIuJ0hGPczZjyZTEqiMlNfXx8ALuYmk46ZzcYx3Gr6q3K5nJYkUuVy3g1wm7pesWLFCDdL1xcDK3huCVgGSQH0GvA9CUFtHCIRAEhUFJ8tiwAT+k5eLe1IUF9tIDXxMlE7ILkylitmA1v2tISpB1CDcdpuWUoaXalZ586dG9uwYcOPgBGg+hYeRpyobAEmZ0DRb5kq3kXnJLwHc9sdtQt45utvAsMIfrf/4MGD89yXDChVlizhwsmSFAF2HcwfBLBsd4D1aTeIXudlW1mAaIzopZYwY0hNzABVmGTOKBfXw3ditHcEuBD83K16LQtIoJwx/pFhASwGMAGcwwtM0jfDnHGknS3nTVIhzt/flyqB/wF0ZB0uacxUuQAAAABJRU5ErkJggg==) no-repeat;  background-size: 100%;\n      }\n\n      :host #mask {\n        position: absolute;\n        top: 0;\n        bottom: 0;\n        left: 0;\n        right: 0;\n        background: rgba(255,255,255,.775);\n      }\n      \n    </style>\n  </template>\n</dom-module>";
document.head.appendChild(documentContainer);

var Button = /*#__PURE__*/function (_Hover) {
  _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_4___default()(Button, _Hover);

  var _super = _createSuper(Button);

  function Button() {
    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, Button);

    return _super.apply(this, arguments);
  }

  _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(Button, [{
    key: "listeners",
    get: function get() {
      return {
        tap: '_onButtonTap'
      };
    }
  }, {
    key: "connectedCallback",
    value: function connectedCallback() {
      _babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_3___default()(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_6___default()(Button.prototype), "connectedCallback", this).call(this);

      this._defaultHoverClass = 'button-hover';
    }
  }, {
    key: "_onButtonTap",
    value: function _onButtonTap() {
      var _this2 = this;

      if (this.disabled) {
        return;
      }

      if (this.formType) {
        if (this.formType === 'submit') {
          this.dispatchEvent(new CustomEvent('formSubmit', {
            bubbles: true,
            composed: true
          }));
        }

        if (this.formType === 'reset') {
          this.dispatchEvent(new CustomEvent('formReset', {
            bubbles: true,
            composed: true
          }));
        }
      }

      if (!this._lock && this.openType) {
        this._lock = true;
        setTimeout(function () {
          _this2._lock = false;
        }, 1000);

        if (this.openType === 'share') {} else if (this.openType === 'getPhoneNumber') {} else if (this.openType === 'launchApp') {} else if (this.openType === 'contact') {}
      }
    }
  }, {
    key: "showMask",
    value: function showMask(disabled, type) {
      return disabled && type === 'default';
    }
  }], [{
    key: "is",
    get: function get() {
      return "".concat(_utils_config__WEBPACK_IMPORTED_MODULE_8__["elementPrefix"], "-button");
    }
  }, {
    key: "properties",
    get: function get() {
      return {
        type: {
          type: String,
          value: 'default',
          reflectToAttribute: true
        },
        size: {
          type: String,
          value: 'default',
          reflectToAttribute: true
        },
        disabled: {
          type: Boolean,
          reflectToAttribute: true
        },
        plain: {
          type: Boolean,
          reflectToAttribute: true
        },
        loading: {
          type: Boolean,
          reflectToAttribute: true
        },
        formType: {
          type: String
        },
        openType: {
          type: String,
          value: ''
        },
        hoverStartTime: {
          type: Number,
          value: 20
        },
        hoverStayTime: {
          type: Number,
          value: 70
        },
        hoverClass: {
          type: String,
          value: 'button-hover',
          observer: '_hoverClassChange'
        }
      };
    }
  }, {
    key: "template",
    get: function get() {
      return Object(_polymer_polymer__WEBPACK_IMPORTED_MODULE_7__["html"])(_templateObject || (_templateObject = _babel_runtime_helpers_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0___default()(["\n      <style include=\"button-style\">\n      </style>\n      <i id=\"icon\" if=\"[[loading]]\"></i>\n      <slot></slot>\n      <template is=\"dom-if\" if=\"[[showMask(disabled, type)]]\">\n        <div id=\"mask\"></div>\n      </template>\n    "])));
    }
  }]);

  return Button;
}(Object(_mixins__WEBPACK_IMPORTED_MODULE_9__["Hover"])(Object(_mixins__WEBPACK_IMPORTED_MODULE_9__["Base"])(_polymer_polymer__WEBPACK_IMPORTED_MODULE_7__["PolymerElement"])));

window.customElements.define(Button.is, Button);

/***/ }),

/***/ "./src/web-components/checkbox-group.js":
/*!**********************************************!*\
  !*** ./src/web-components/checkbox-group.js ***!
  \**********************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _babel_runtime_helpers_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/taggedTemplateLiteral */ "./node_modules/@babel/runtime/helpers/taggedTemplateLiteral.js");
/* harmony import */ var _babel_runtime_helpers_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _polymer_polymer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @polymer/polymer */ "./node_modules/@polymer/polymer/polymer-element.js");
/* harmony import */ var _utils_config__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @/utils/config */ "./src/utils/config.js");
/* harmony import */ var _mixins__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./mixins */ "./src/web-components/mixins/index.js");







var _templateObject;

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5___default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5___default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4___default()(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }





var CheckboxGroup = /*#__PURE__*/function (_Group) {
  _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3___default()(CheckboxGroup, _Group);

  var _super = _createSuper(CheckboxGroup);

  function CheckboxGroup() {
    var _this;

    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, CheckboxGroup);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));
    _this.value = [];
    return _this;
  }

  _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(CheckboxGroup, [{
    key: "childItemType",
    get: function get() {
      return "".concat(_utils_config__WEBPACK_IMPORTED_MODULE_7__["elementPrefix"], "-checkbox");
    }
  }, {
    key: "addItem",
    value: function addItem(e) {
      if (e.checked) {
        this.value.push(e.value);
      }
    }
  }, {
    key: "removeItem",
    value: function removeItem(e) {
      if (e.checked) {
        var t = this.value.indexOf(e.value);
        t >= 0 && this.value.splice(t, 1);
      }
    }
  }, {
    key: "renameItem",
    value: function renameItem(e, t, n) {
      if (e.checked) {
        var i = this.value.indexOf(n);
        i >= 0 && (this.value[i] = t);
      }
    }
  }, {
    key: "changed",
    value: function changed(e) {
      if (e.checked) {
        this.value.push(e.value);
      } else {
        var t = this.value.indexOf(e.value);

        if (t >= 0) {
          this.value.splice(t, 1);
        }
      }
    }
  }], [{
    key: "is",
    get: function get() {
      return "".concat(_utils_config__WEBPACK_IMPORTED_MODULE_7__["elementPrefix"], "-checkbox-group");
    }
  }, {
    key: "template",
    get: function get() {
      return Object(_polymer_polymer__WEBPACK_IMPORTED_MODULE_6__["html"])(_templateObject || (_templateObject = _babel_runtime_helpers_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0___default()(["\n      <style>\n        :host {\n          display: block;\n        }\n      </style>\n      <slot></slot>\n    "])));
    }
  }]);

  return CheckboxGroup;
}(Object(_mixins__WEBPACK_IMPORTED_MODULE_8__["Group"])(Object(_mixins__WEBPACK_IMPORTED_MODULE_8__["Data"])(Object(_mixins__WEBPACK_IMPORTED_MODULE_8__["Base"])(_polymer_polymer__WEBPACK_IMPORTED_MODULE_6__["PolymerElement"]))));

window.customElements.define(CheckboxGroup.is, CheckboxGroup);

/***/ }),

/***/ "./src/web-components/checkbox.js":
/*!****************************************!*\
  !*** ./src/web-components/checkbox.js ***!
  \****************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _babel_runtime_helpers_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/taggedTemplateLiteral */ "./node_modules/@babel/runtime/helpers/taggedTemplateLiteral.js");
/* harmony import */ var _babel_runtime_helpers_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _polymer_polymer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @polymer/polymer */ "./node_modules/@polymer/polymer/polymer-element.js");
/* harmony import */ var _utils_config__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @/utils/config */ "./src/utils/config.js");
/* harmony import */ var _mixins__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./mixins */ "./src/web-components/mixins/index.js");







var _templateObject;

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5___default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5___default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4___default()(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }




var documentContainer = document.createElement('div');
documentContainer.setAttribute('style', 'display: none;');
documentContainer.innerHTML = "<dom-module id=\"checkbox-style\">\n  <template>\n    <style>\n        :host {\n          -webkit-tap-highlight-color: transparent;\n          display: inline-block;\n        }\n        :host .checkbox-wrapper {\n          display: -webkit-inline-flex;\n          display: inline-flex;\n          -webkit-align-items: center;\n          align-items: center;\n          vertical-align: middle;\n        }\n\n        :host .checkbox-input {\n          margin-right: 5px;\n          -webkit-appearance: none;\n          appearance: none;\n          outline: 0;\n          background-color: #FFF;\n          border: 1px solid #E8E8E8;\n          border-radius: 100%;\n          width: 22px;\n          height: 22px;\n          position: relative;\n        }\n\n        :host .checkbox-input.checkbox-input-checked:before {\n          font: normal normal normal 14px/1 \"ttui\";\n          content: \"\\e601\";\n          font-size: 28px;\n          color: #FFFFFF;\n          position: absolute;\n          top: 50%;\n          left: 50%;\n          transform: translate(-50%, -48%) scale(0.73);\n          -webkit-transform: translate(-50%, -48%) scale(0.73);\n        }\n    </style>\n  </template>\n</dom-module>";
document.head.appendChild(documentContainer);

var Checkbox = /*#__PURE__*/function (_Disabled) {
  _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3___default()(Checkbox, _Disabled);

  var _super = _createSuper(Checkbox);

  function Checkbox() {
    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, Checkbox);

    return _super.apply(this, arguments);
  }

  _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(Checkbox, [{
    key: "listeners",
    get: function get() {
      return {
        tap: 'handleBoxTap'
      };
    }
  }, {
    key: "handleBoxTap",
    value: function handleBoxTap() {
      if (this.disabled) {
        return;
      }

      this.checked = !this.checked;
      this.changedByTap();
    }
  }, {
    key: "handleLabelTap",
    value: function handleLabelTap() {
      this.handleBoxTap();
    }
  }, {
    key: "hasCheckedClass",
    value: function hasCheckedClass(checked) {
      return checked ? "".concat(_utils_config__WEBPACK_IMPORTED_MODULE_7__["elementPrefix"], "-checkbox-input-checked") : '';
    }
  }, {
    key: "hasDisabledClass",
    value: function hasDisabledClass(disabled) {
      return disabled ? "".concat(_utils_config__WEBPACK_IMPORTED_MODULE_7__["elementPrefix"], "-checkbox-input-disabled") : '';
    }
  }, {
    key: "_getColor",
    value: function _getColor(checked, color) {
      return checked ? color : '';
    }
  }, {
    key: "judgeDisableColor",
    value: function judgeDisableColor(color) {
      return this.disabled ? '#E8E8E8E' : color;
    }
  }], [{
    key: "is",
    get: function get() {
      return "".concat(_utils_config__WEBPACK_IMPORTED_MODULE_7__["elementPrefix"], "-checkbox");
    }
  }, {
    key: "properties",
    get: function get() {
      return {
        color: {
          type: String,
          value: '#F85959'
        },
        checkedColor: {
          type: String,
          computed: '_getColor(checked, color)'
        }
      };
    }
  }, {
    key: "template",
    get: function get() {
      return Object(_polymer_polymer__WEBPACK_IMPORTED_MODULE_6__["html"])(_templateObject || (_templateObject = _babel_runtime_helpers_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0___default()(["\n      <style include=\"checkbox-style\"></style>\n      <div class=\"checkbox-wrapper\">\n        <div\n          id=\"input\" \n          class$=\"checkbox-input [[hasCheckedClass(checked)]] [[hasDisabledClass(disabled)]]\" \n          style$=\"border-color: [[judgeDisableColor(color)]];background-color: [[judgeDisableColor(checkedColor)]];\"\n        >\n        </div>\n        <slot></slot>\n      </div>\n    "])));
    }
  }]);

  return Checkbox;
}(Object(_mixins__WEBPACK_IMPORTED_MODULE_8__["Disabled"])(Object(_mixins__WEBPACK_IMPORTED_MODULE_8__["Item"])(Object(_mixins__WEBPACK_IMPORTED_MODULE_8__["LabelTarget"])(Object(_mixins__WEBPACK_IMPORTED_MODULE_8__["Base"])(_polymer_polymer__WEBPACK_IMPORTED_MODULE_6__["PolymerElement"])))));

window.customElements.define(Checkbox.is, Checkbox);

/***/ }),

/***/ "./src/web-components/form.js":
/*!************************************!*\
  !*** ./src/web-components/form.js ***!
  \************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _babel_runtime_helpers_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/taggedTemplateLiteral */ "./node_modules/@babel/runtime/helpers/taggedTemplateLiteral.js");
/* harmony import */ var _babel_runtime_helpers_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ "./node_modules/@babel/runtime/helpers/asyncToGenerator.js");
/* harmony import */ var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/get */ "./node_modules/@babel/runtime/helpers/get.js");
/* harmony import */ var _babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js");
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var _polymer_polymer__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @polymer/polymer */ "./node_modules/@polymer/polymer/polymer-element.js");
/* harmony import */ var _utils_config__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @/utils/config */ "./src/utils/config.js");
/* harmony import */ var _mixins__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./mixins */ "./src/web-components/mixins/index.js");
/* harmony import */ var _utils_uuid__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./utils/uuid */ "./src/web-components/utils/uuid.js");










var _templateObject;



function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_8___default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_8___default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_7___default()(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }






var Form = /*#__PURE__*/function (_Base) {
  _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_6___default()(Form, _Base);

  var _super = _createSuper(Form);

  function Form() {
    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_3___default()(this, Form);

    return _super.apply(this, arguments);
  }

  _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_4___default()(Form, [{
    key: "listeners",
    get: function get() {
      return {
        formSubmit: '__submitHandler',
        formReset: '__resetHandler'
      };
    }
  }, {
    key: "ready",
    value: function ready() {
      _babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_5___default()(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_8___default()(Form.prototype), "ready", this).call(this);

      this.__submitHandler = this.submitHandler.bind(this);
      this.__resetHandler = this.resetHandler.bind(this);
    } // every components under should ipl
    // resetFormData and getFormData func;

  }, {
    key: "submitHandler",
    value: function () {
      var _submitHandler = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2___default()( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_9___default.a.mark(function _callee(e) {
        var target, value, formId;
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_9___default.a.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                target = {
                  id: '',
                  dataset: _objectSpread({}, e.target.dataset),
                  offsetLeft: e.target.offsetLeft,
                  offsetTop: e.target.offsetTop
                };
                _context.next = 3;
                return this.collectInput();

              case 3:
                value = _context.sent;
                _context.next = 6;
                return this.getFormId();

              case 6:
                formId = _context.sent;
                this.triggerEvent('submit', {
                  target: target,
                  value: value,
                  formId: formId
                });

              case 8:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function submitHandler(_x) {
        return _submitHandler.apply(this, arguments);
      }

      return submitHandler;
    }()
  }, {
    key: "resetHandler",
    value: function resetHandler(e) {
      var inputEls = this._dfs(this);

      inputEls.forEach(function (input) {
        input.resetFormData();
      });
      this.triggerEvent('reset', {
        target: {
          id: '',
          dataset: _objectSpread({}, e.target.dataset),
          offsetLeft: e.target.offsetLeft,
          offsetTop: e.target.offsetTop
        }
      });
    }
  }, {
    key: "_dfs",
    value: function _dfs(el) {
      var _this = this;

      var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

      if (!el) {
        return result;
      } // has data behaviour


      if (typeof el.getFormData === 'function') {
        result.push(el);
      }

      if (!el.children || !el.children.length) {
        return result;
      }

      Array.from(el.children).forEach(function (child) {
        _this._dfs(child, result);
      });
      return result;
    }
  }, {
    key: "collectInput",
    value: function () {
      var _collectInput = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2___default()( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_9___default.a.mark(function _callee2() {
        var inputEls, formData, _loop, i, l;

        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_9___default.a.wrap(function _callee2$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                inputEls = this._dfs(this);
                formData = {};
                _loop = /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_9___default.a.mark(function _loop(i, l) {
                  var input, name, val;
                  return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_9___default.a.wrap(function _loop$(_context2) {
                    while (1) {
                      switch (_context2.prev = _context2.next) {
                        case 0:
                          input = inputElsn[i];
                          name = input.name;

                          if (!name) {
                            _context2.next = 7;
                            break;
                          }

                          _context2.next = 5;
                          return new Promise(function (resolve) {
                            input.getFormData(resolve);
                          });

                        case 5:
                          val = _context2.sent;

                          if (!formData[name]) {
                            formData[name] = val;
                          } else {
                            formData[name] = [].concat(formData[name], val);
                          }

                        case 7:
                        case "end":
                          return _context2.stop();
                      }
                    }
                  }, _loop);
                });
                i = 0, l = inputEls.length;

              case 4:
                if (!(i < l)) {
                  _context3.next = 9;
                  break;
                }

                return _context3.delegateYield(_loop(i, l), "t0", 6);

              case 6:
                i++;
                _context3.next = 4;
                break;

              case 9:
                return _context3.abrupt("return", formData);

              case 10:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee2, this);
      }));

      function collectInput() {
        return _collectInput.apply(this, arguments);
      }

      return collectInput;
    }()
  }, {
    key: "getFormId",
    value: function () {
      var _getFormId = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2___default()( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_9___default.a.mark(function _callee3() {
        var formId;
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_9___default.a.wrap(function _callee3$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                if (!this.reportSubmit) {
                  _context4.next = 3;
                  break;
                }

                formId = Object(_utils_uuid__WEBPACK_IMPORTED_MODULE_13__["default"])();
                return _context4.abrupt("return", new Promise(function (resolve) {
                  resolve(formId);
                }));

              case 3:
                return _context4.abrupt("return", '');

              case 4:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee3, this);
      }));

      function getFormId() {
        return _getFormId.apply(this, arguments);
      }

      return getFormId;
    }()
  }], [{
    key: "is",
    get: function get() {
      return "".concat(_utils_config__WEBPACK_IMPORTED_MODULE_11__["elementPrefix"], "-form");
    }
  }, {
    key: "properties",
    get: function get() {
      return {
        reportSubmit: {
          type: Boolean,
          value: false
        }
      };
    }
  }, {
    key: "template",
    get: function get() {
      return Object(_polymer_polymer__WEBPACK_IMPORTED_MODULE_10__["html"])(_templateObject || (_templateObject = _babel_runtime_helpers_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0___default()(["\n      <style>\n        :host {\n          display: block;\n        }\n      </style>\n      <slot></slot>\n    "])));
    }
  }]);

  return Form;
}(Object(_mixins__WEBPACK_IMPORTED_MODULE_12__["Base"])(_polymer_polymer__WEBPACK_IMPORTED_MODULE_10__["PolymerElement"]));

window.customElements.define(Form.is, Form);

/***/ }),

/***/ "./src/web-components/icon.js":
/*!************************************!*\
  !*** ./src/web-components/icon.js ***!
  \************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _babel_runtime_helpers_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/taggedTemplateLiteral */ "./node_modules/@babel/runtime/helpers/taggedTemplateLiteral.js");
/* harmony import */ var _babel_runtime_helpers_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _polymer_polymer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @polymer/polymer */ "./node_modules/@polymer/polymer/polymer-element.js");
/* harmony import */ var _utils_config__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @/utils/config */ "./src/utils/config.js");
/* harmony import */ var _mixins__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./mixins */ "./src/web-components/mixins/index.js");







var _templateObject;

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5___default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5___default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4___default()(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }




var documentContainer = document.createElement('div');
documentContainer.setAttribute('style', 'display: none;');
documentContainer.innerHTML = "<dom-module id=\"icon-style\">\n  <template>\n    <style>\n      :host {\n        display: inline-block;\n        font-size: 0;\n      }\n\n      :host([hidden]) {\n        display: none;\n      }\n\n      #icon {\n        font: normal normal normal 14px/1 \"mpui\";\n      }\n\n      #icon[class^=\"icon-\"]:before,\n      #icon[class*=\" icon-\"]:before {\n        margin: 0;\n        box-sizing: border-box;\n      }\n\n      .icon-success { color: #F95959; }\n      .icon-success:before { content: \"\\e613\"; }\n      .icon-success_no_circle { color: #F95959;}\n      .icon-success_no_circle:before { content: \"\\e610\";}\n      .icon-info { color: #CACACA; }\n      .icon-info:before { content: \"\\e60d\"; }\n      .icon-warn { color: #F5A623;}\n      .icon-warn:before { content: \"\\e614\";}\n      .icon-waiting { color: #50ABF9;}\n      .icon-waiting:before { content: \"\\e612\";}\n      .icon-clear { color: #F95959;}\n      .icon-clear:before { content: \"\\e615\";}\n      .icon-cancel { color: #222222;}\n      .icon-cancel:before { content: \"\\e611\";}\n      .icon-download { color: #222222;}\n      .icon-download:before { content: \"\\e60f\";}\n      .icon-search { color: #222222;}\n      .icon-search:before { content: \"\\e60e\";}\n    </style>\n  </template>\n</dom-module>";
document.head.appendChild(documentContainer);

var Icon = /*#__PURE__*/function (_Base) {
  _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3___default()(Icon, _Base);

  var _super = _createSuper(Icon);

  function Icon() {
    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, Icon);

    return _super.apply(this, arguments);
  }

  _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(Icon, null, [{
    key: "is",
    get: function get() {
      return "".concat(_utils_config__WEBPACK_IMPORTED_MODULE_7__["elementPrefix"], "-icon");
    }
  }, {
    key: "properties",
    get: function get() {
      return {
        type: {
          type: String
        },
        color: {
          type: String
        },
        size: {
          type: Number,
          value: 24
        }
      };
    }
  }, {
    key: "template",
    get: function get() {
      return Object(_polymer_polymer__WEBPACK_IMPORTED_MODULE_6__["html"])(_templateObject || (_templateObject = _babel_runtime_helpers_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0___default()(["\n      <style include=\"icon-style\"></style>\n      <i id=\"icon\" class$=\"icon-[[ type ]]\" style$=\"color: [[ color ]]; font-size: [[ size ]]px\"></i>\n    "])));
    }
  }]);

  return Icon;
}(Object(_mixins__WEBPACK_IMPORTED_MODULE_8__["Base"])(_polymer_polymer__WEBPACK_IMPORTED_MODULE_6__["PolymerElement"]));

window.customElements.define(Icon.is, Icon);

/***/ }),

/***/ "./src/web-components/image.js":
/*!*************************************!*\
  !*** ./src/web-components/image.js ***!
  \*************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _babel_runtime_helpers_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/taggedTemplateLiteral */ "./node_modules/@babel/runtime/helpers/taggedTemplateLiteral.js");
/* harmony import */ var _babel_runtime_helpers_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/assertThisInitialized.js");
/* harmony import */ var _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/get */ "./node_modules/@babel/runtime/helpers/get.js");
/* harmony import */ var _babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _polymer_polymer__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @polymer/polymer */ "./node_modules/@polymer/polymer/polymer-element.js");
/* harmony import */ var _utils_config__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @/utils/config */ "./src/utils/config.js");
/* harmony import */ var _framework_utils_resolvePageUrl__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @/framework/utils/resolvePageUrl */ "./src/framework/utils/resolvePageUrl.js");
/* harmony import */ var _framework_App__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @/framework/App */ "./src/framework/App/index.js");
/* harmony import */ var _mixins__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./mixins */ "./src/web-components/mixins/index.js");
/* harmony import */ var _utils_scrollUtil__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./utils/scrollUtil */ "./src/web-components/utils/scrollUtil.js");









var _templateObject;

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_7___default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_7___default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_6___default()(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

/* eslint-disable default-case */






var documentContainer = document.createElement('div');
documentContainer.setAttribute('style', 'display: none;');
documentContainer.innerHTML = "\n  <dom-module id=\"image-style\">\n    <template>\n      <style>\n        #imageWrapper {\n          height: 100%;\n          width: 100%;\n        }\n      </style>\n    </template>\n  </dom-module>\n";
document.head.appendChild(documentContainer);

var Image = /*#__PURE__*/function (_Base) {
  _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_5___default()(Image, _Base);

  var _super = _createSuper(Image);

  function Image() {
    var _this;

    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, Image);

    _this = _super.call(this);
    _this._attached = false;
    _this._changeId = 0;
    _this.__pageReRenderCallback = _this._pageReRenderCallback.bind(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_3___default()(_this));
    return _this;
  }

  _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(Image, [{
    key: "connectedCallback",
    value: function connectedCallback(e) {
      var _this2 = this;

      _babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_4___default()(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_7___default()(Image.prototype), "connectedCallback", this).call(this);

      this._attached = true;
      this._originalHeight = this.style.height || '';

      if (this.src) {
        setTimeout(function () {
          return _this2._initialize(_this2.lazyLoad);
        });
      }
    }
  }, {
    key: "disconnectedCallback",
    value: function disconnectedCallback() {
      _babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_4___default()(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_7___default()(Image.prototype), "disconnectedCallback", this).call(this);

      this._attached = false;

      if (this.lazyLoad) {
        _utils_scrollUtil__WEBPACK_IMPORTED_MODULE_13__["default"].deregisterInstance(this);
      }

      document.removeEventListener('pageReRender', this.__pageReRenderCallback);
    }
  }, {
    key: "srcChanged",
    value: function srcChanged(old, newOne) {
      var _this3 = this;

      if (this._attached && old !== newOne) {
        setTimeout(function () {
          _this3._changeId++;
          document.removeEventListener('pageReRender', _this3.__pageReRenderCallback);

          _this3._showImage(_this3._changeId);
        });
      }
    }
  }, {
    key: "modeChanged",
    value: function modeChanged(type, oldMode) {
      // not giving mode
      if (!this._checkMode(type)) {
        this._disableSizePositionRepeat = false;
        return;
      }

      if (oldMode === 'widthFix') {
        this.style.height = this._originalHeight;
      }

      this._disableSizePositionRepeat = true;
      this.$.imageWrapper.style.backgroundSize = 'auto auto';
      this.$.imageWrapper.style.backgroundPosition = '0% 0%';
      this.$.imageWrapper.style.backgroundRepeat = 'no-repeat';

      switch (type) {
        case 'scaleToFill':
          this.$.imageWrapper.style.backgroundSize = '100% 100%';
          break;

        case 'aspectFit':
          this.$.imageWrapper.style.backgroundSize = 'contain';
          this.$.imageWrapper.style.backgroundPosition = 'center center';
          break;

        case 'aspectFill':
          this.$.imageWrapper.style.backgroundSize = 'cover';
          this.$.imageWrapper.style.backgroundPosition = 'center center';
          break;

        case 'widthFix':
          this.$.imageWrapper.style.backgroundSize = '100% 100%';
          break;

        case 'top':
          this.$.imageWrapper.style.backgroundPosition = 'top center';
          break;

        case 'bottom':
          this.$.imageWrapper.style.backgroundPosition = 'bottom center';
          break;

        case 'center':
          this.$.imageWrapper.style.backgroundPosition = 'center center';
          break;

        case 'left':
          this.$.imageWrapper.style.backgroundPosition = 'center left';
          break;

        case 'right':
          this.$.imageWrapper.style.backgroundPosition = 'center right';
          break;

        case 'top left':
          this.$.imageWrapper.style.backgroundPosition = 'top left';
          break;

        case 'top right':
          this.$.imageWrapper.style.backgroundPosition = 'top right';
          break;

        case 'bottom left':
          this.$.imageWrapper.style.backgroundPosition = 'bottom left';
          break;

        case 'bottom right':
          this.$.imageWrapper.style.backgroundPosition = 'bottom right';
      }
    }
  }, {
    key: "getWidth",
    value: function getWidth() {
      var e = this.$.imageWrapper.offsetWidth;
      var t = window.getComputedStyle(this.$.imageWrapper);
      return e - ((parseFloat(t.borderLeftWidth) || 0) + (parseFloat(t.borderRightWidth) || 0)) - ((parseFloat(t.paddingLeft) || 0) + (parseFloat(t.paddingRight) || 0));
    }
  }, {
    key: "backgroundSizeChanged",
    value: function backgroundSizeChanged(e, t) {
      if (!this._disableSizePositionRepeat) {
        this.$.imageWrapper.style.backgroundSize = e;
      }
    }
  }, {
    key: "backgroundPositionChanged",
    value: function backgroundPositionChanged(e, t) {
      if (!this._disableSizePositionRepeat) {
        this.$.imageWrapper.style.backgroundPosition = e;
      }
    }
  }, {
    key: "backgroundRepeatChanged",
    value: function backgroundRepeatChanged(e, t) {
      if (!this._disableSizePositionRepeat) {
        this.$.imageWrapper.style.backgroundRepeat = e;
      }
    }
  }, {
    key: "lazyLoadChanged",
    value: function lazyLoadChanged(e, t) {
      e !== t && t && this._initialize(e);
    }
  }, {
    key: "_checkMode",
    value: function _checkMode(mode) {
      var modes = ['scaleToFill', 'aspectFit', 'aspectFill', 'top', 'bottom', 'center', 'left', 'right', 'top left', 'top right', 'bottom left', 'bottom right'];
      return !!modes.filter(function (m) {
        return m === mode;
      }).length;
    }
  }, {
    key: "_initialize",
    value: function _initialize(lazyLoad) {
      if (!lazyLoad || _utils_scrollUtil__WEBPACK_IMPORTED_MODULE_13__["default"].isNodeVisible(this)) {
        this._showImage(this._changeId);
      } else {
        _utils_scrollUtil__WEBPACK_IMPORTED_MODULE_13__["default"].registerInstance(this);
      }
    }
  }, {
    key: "_showImage",
    value: function _showImage(id) {
      var _this4 = this;

      this._getImagePath(this.src, function (src) {
        _this4.$.imageWrapper.style.backgroundImage = "url('".concat(src, "')");
        var img = new Image();

        img.onerror = function (e) {
          e.stopPropagation();

          if (id === this._changeId) {
            img = null;
            this.triggerEvent('error', {
              errMsg: "GET ".concat(src, " 404 (Not Found)")
            });
          }
        };

        img.onload = function (e) {
          e.stopPropagation();

          if (id === this._changeId) {
            this.ratio = img.naturalWidth / img.naturalHeight;
            var radio = this.ratio;

            if (this.mode === 'widthFix') {
              this.style.height = "".concat(this.getWidth() / radio, "px");
              this.triggerReRender();
            }

            document.addEventListener('pageReRender', this.__pageReRenderCallback);
            this.triggerEvent('load', {
              width: img.naturalWidth,
              height: img.naturalHeight
            });
          }
        };

        _utils_scrollUtil__WEBPACK_IMPORTED_MODULE_13__["default"].deregisterInstance(_this4);
        img.src = src;
      });
    }
  }, {
    key: "_pageReRenderCallback",
    value: function _pageReRenderCallback() {
      if (this.mode === 'widthFix' && this.ratio !== null) {
        this.style.height = "".concat(this.getWidth() / this.ratio, "px");
      }

      _utils_scrollUtil__WEBPACK_IMPORTED_MODULE_13__["default"].checkUnloadedImages();
    }
  }, {
    key: "_getImagePath",
    value: function _getImagePath(source, callback) {
      var src;

      if (typeof source === 'string' && source.trim()) {
        if (source.indexOf('http://') === 0 || source.indexOf('https://') === 0 || source.indexOf('file://') === 0 || source.indexOf('data:image') === 0 // base64
        || source.indexOf('myfile://') === 0 // support custom protocol of IDE
        || source.indexOf('local://') === 0 // support custom protocol of IDE
        || source.indexOf('temp://') === 0 // support custom protocol of IDE
        ) {
            src = source;
          } else {
          src = Object(_framework_utils_resolvePageUrl__WEBPACK_IMPORTED_MODULE_10__["default"])(source, Object(_framework_App__WEBPACK_IMPORTED_MODULE_11__["getCurrentPageImpl"])());
          var _self = self,
              mpRuntimeConfig = _self.mpRuntimeConfig;

          if (mpRuntimeConfig && mpRuntimeConfig.contextPath) {
            src = "".concat(mpRuntimeConfig.contextPath, "/").concat(src);
          } else {
            src = "/".concat(src);
          }
        }
      }

      callback(src);
    }
  }, {
    key: "__widthChanged",
    value: function __widthChanged(val) {
      if (val) {
        var numberVal = Number(val);

        if (numberVal) {
          val += 'px';
        }

        this.style.width = val;
      }
    }
  }, {
    key: "__heightChanged",
    value: function __heightChanged(val) {
      if (val) {
        var numberVal = Number(val);

        if (numberVal) {
          val += 'px';
        }

        this.style.height = val;
      }
    }
  }], [{
    key: "is",
    get: function get() {
      return "".concat(_utils_config__WEBPACK_IMPORTED_MODULE_9__["elementPrefix"], "-image");
    }
  }, {
    key: "properties",
    get: function get() {
      return {
        src: {
          type: String,
          observer: 'srcChanged',
          reflectToAttribute: true
        },
        mode: {
          type: String,
          observer: 'modeChanged'
        },
        backgroundSize: {
          type: String,
          observer: 'backgroundSizeChanged'
        },
        backgroundPosition: {
          type: String,
          observer: 'backgroundPositionChanged'
        },
        backgroundRepeat: {
          type: String,
          observer: 'backgroundRepeatChanged'
        },
        _disableSizePositionRepeat: {
          type: Boolean
        },
        width: {
          type: String,
          observer: '__widthChanged'
        },
        height: {
          type: String,
          observer: '__heightChanged'
        },
        lazyLoad: {
          type: Boolean,
          observer: 'lazyLoadChanged'
        }
      };
    }
  }, {
    key: "template",
    get: function get() {
      return Object(_polymer_polymer__WEBPACK_IMPORTED_MODULE_8__["html"])(_templateObject || (_templateObject = _babel_runtime_helpers_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0___default()(["\n      <style include=\"image-style\">\n        :host {\n          width: 300px;\n          height: 225px;\n          display: inline-block;\n          overflow: hidden;\n        }\n\n        :host([ hidden ]) {\n          display: none;\n        }\n\n      </style>\n      <div \n        style=\"background-size:100% 100%; border-radius:inherit; background-repeat:no-repeat;\" \n        id=\"imageWrapper\"\n      ></div>\n    "])));
    }
  }]);

  return Image;
}(Object(_mixins__WEBPACK_IMPORTED_MODULE_12__["Base"])(_polymer_polymer__WEBPACK_IMPORTED_MODULE_8__["PolymerElement"]));

window.customElements.define(Image.is, Image);

/***/ }),

/***/ "./src/web-components/index.js":
/*!*************************************!*\
  !*** ./src/web-components/index.js ***!
  \*************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _polymer_polymer_lib_elements_dom_repeat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @polymer/polymer/lib/elements/dom-repeat */ "./node_modules/@polymer/polymer/lib/elements/dom-repeat.js");
/* harmony import */ var _polymer_polymer_lib_elements_dom_if__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @polymer/polymer/lib/elements/dom-if */ "./node_modules/@polymer/polymer/lib/elements/dom-if.js");
/* harmony import */ var _polymer_polymer_lib_elements_dom_module__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @polymer/polymer/lib/elements/dom-module */ "./node_modules/@polymer/polymer/lib/elements/dom-module.js");
/* harmony import */ var _styles_index_less__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./styles/index.less */ "./src/web-components/styles/index.less");
/* harmony import */ var _styles_index_less__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_styles_index_less__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _page__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./page */ "./src/web-components/page.js");
/* harmony import */ var _view__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./view */ "./src/web-components/view.js");
/* harmony import */ var _button__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./button */ "./src/web-components/button.js");
/* harmony import */ var _text__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./text */ "./src/web-components/text.js");
/* harmony import */ var _label__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./label */ "./src/web-components/label.js");
/* harmony import */ var _form__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./form */ "./src/web-components/form.js");
/* harmony import */ var _input__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./input */ "./src/web-components/input.js");
/* harmony import */ var _checkbox__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./checkbox */ "./src/web-components/checkbox.js");
/* harmony import */ var _checkbox_group__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./checkbox-group */ "./src/web-components/checkbox-group.js");
/* harmony import */ var _radio__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./radio */ "./src/web-components/radio.js");
/* harmony import */ var _radio_group__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./radio-group */ "./src/web-components/radio-group.js");
/* harmony import */ var _icon__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./icon */ "./src/web-components/icon.js");
/* harmony import */ var _image__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./image */ "./src/web-components/image.js");
/* harmony import */ var _scroll_view__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./scroll-view */ "./src/web-components/scroll-view.js");
/* harmony import */ var _slider__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./slider */ "./src/web-components/slider.js");
/* harmony import */ var _progress__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./progress */ "./src/web-components/progress.js");
/* harmony import */ var _switch__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./switch */ "./src/web-components/switch.js");
/* harmony import */ var _swiper__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./swiper */ "./src/web-components/swiper.js");
/* harmony import */ var _swiper_item__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./swiper-item */ "./src/web-components/swiper-item.js");
























/***/ }),

/***/ "./src/web-components/input.js":
/*!*************************************!*\
  !*** ./src/web-components/input.js ***!
  \*************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _babel_runtime_helpers_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/taggedTemplateLiteral */ "./node_modules/@babel/runtime/helpers/taggedTemplateLiteral.js");
/* harmony import */ var _babel_runtime_helpers_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/get */ "./node_modules/@babel/runtime/helpers/get.js");
/* harmony import */ var _babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _polymer_polymer__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @polymer/polymer */ "./node_modules/@polymer/polymer/polymer-element.js");
/* harmony import */ var _polymer_polymer_lib_mixins_gesture_event_listeners__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @polymer/polymer/lib/mixins/gesture-event-listeners */ "./node_modules/@polymer/polymer/lib/mixins/gesture-event-listeners.js");
/* harmony import */ var _utils_config__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @/utils/config */ "./src/utils/config.js");
/* harmony import */ var _mixins__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./mixins */ "./src/web-components/mixins/index.js");








var _templateObject;

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_6___default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_6___default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_5___default()(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }





var documentContainer = document.createElement('div');
documentContainer.setAttribute('style', 'display: none;');
documentContainer.innerHTML = "<dom-module id=\"input-style\">\n  <template>\n    <style>\n      :host {\n        display: block;\n        height: 1.4rem;\n        text-overflow: clip;\n        overflow: hidden;\n        white-space: nowrap;\n        font-family: PingFang SC, -apple-system, helvetica, sans-serif;;\n        min-height: 1.4rem;\n        -webkit-tap-highlight-color: transparent;\n      }\n\n      :host input {\n        position: relative;\n        min-height: 1.4rem;\n        border: none;\n        height: inherit;\n        width: 100%;\n        font-size: inherit;\n        font-weight: inherit;\n        color: inherit;\n        background: transparent;\n        display: inherit;\n        padding: 0;\n        margin: 0;\n        outline: none;\n        vertical-align: middle;\n        text-align: inherit;\n        overflow: inherit;\n        white-space: inherit;\n        text-overflow: inherit;\n        -webkit-tap-highlight-color: transparent;\n        z-index: 2;\n      }\n\n      :host([ hidden ]) {\n        display: none;\n      }\n\n      :host div {\n        position: relative;\n        min-height: 1.4rem;\n        text-overflow: inherit;\n        border: none;\n        height: 100%;\n        font-size: inherit;\n        font-weight: inherit;\n        font-family: PingFang SC, -apple-system, helvetica, sans-serif;;\n        color: inherit;\n        /*background: inherit;*/\n        padding: 0;\n        margin: 0;\n        outline: none;\n        text-align: inherit;\n        -webkit-tap-highlight-color: transparent;\n        white-space: nowrap;\n        overflow: hidden;\n      }\n\n      :host div.input-placeholder {\n        color: #CACACA;\n      }\n\n      :host div[type=password] div {\n        color: black;\n      }\n\n      :host div div {\n        position: absolute;\n        left: 0;\n        top: 0;\n        width: 100%;\n        height: 100%;\n        line-height: 100%;\n        height: inherit;\n        min-height: 1.4rem;\n        white-space: pre;\n        text-align: inherit;\n        overflow: hidden;\n        vertical-align: middle;\n        z-index: 1;\n      }\n    </style>\n  </template>\n</dom-module>";
document.head.appendChild(documentContainer);
var webInputId = 0;

function castNumber(e) {
  e = Number(e);
  return isNaN(e) ? -1 : e;
}

var WebInput = /*#__PURE__*/function (_Data) {
  _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_4___default()(WebInput, _Data);

  var _super = _createSuper(WebInput);

  function WebInput() {
    var _this;

    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, WebInput);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));
    _this.webInputId = webInputId++;
    return _this;
  }

  _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(WebInput, [{
    key: "focus",
    get: function get() {
      return this.$$focus;
    },
    set: function set(newValue) {
      this.$$focus = this._deserializeValue(newValue, Boolean);

      this._couldFocus(this.$$focus);
    }
  }, {
    key: "ready",
    value: function ready() {
      _babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_3___default()(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_6___default()(WebInput.prototype), "ready", this).call(this);

      if (typeof this.$$focus === 'undefined') {
        this.$$focus = false;
      }
    }
  }, {
    key: "getFormData",
    value: function getFormData(fn) {
      typeof fn === 'function' && fn(this.filteredValue);
    }
  }, {
    key: "resetFormData",
    value: function resetFormData() {
      this.value = '';
    }
  }, {
    key: "_event",
    value: function _event(type) {
      var target = {
        id: this.id || '',
        offsetLeft: this.offsetLeft,
        offsetTop: this.offsetTop,
        dataset: this.dataset
      };
      return {
        type: type,
        currentTarget: target,
        target: target,
        timsStamp: 0
      };
    }
  }, {
    key: "connectedCallback",
    value: function connectedCallback() {
      _babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_3___default()(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_6___default()(WebInput.prototype), "connectedCallback", this).call(this);

      this._attached = true;
      this.setProperty();

      this._checkAutoFocus();

      this.styles = this.getComputedStyleString(); // this.$.inputElement.addEventListener('input', this._onInput.bind(this));
      // this.__setKeyboardValueId = this.onSetKeyboardValue.bind(this);
      // document.addEventListener('setKeyboardValue', this.__setKeyboardValueId);
      // this.__pageReRenderCallback = this.pageReRenderCallback.bind(this);
      // document.addEventListener('pageReRender', this.__pageReRenderCallback);
    }
  }, {
    key: "onSetKeyboardValue",
    value: function onSetKeyboardValue(e) {
      // 处理bindinput 返回值的情况
      if (e.detail.inputId === this.webInputId) {
        var keyBoardValue = e.detail.value; // 如果没有返回值不需要重写value

        if (typeof keyBoardValue === 'undefined') {
          return;
        }

        var inputEle = this.$.inputElement;
        inputEle && (inputEle.value = keyBoardValue);
      }
    }
  }, {
    key: "setProperty",
    value: function setProperty() {
      var isUsePassword = this.password;

      if (isUsePassword) {
        this.type = 'password';
      }

      this.$.inputElement.setAttribute('type', this.type);
      this.$.inputElement.setAttribute('maxlength', this.maxlength);

      if (this.type === 'number') {
        this.$.inputElement.setAttribute('type', 'text');
        this.$.inputElement.setAttribute('pattern', '\d*');
      }
    }
  }, {
    key: "getComputedStyleString",
    value: function getComputedStyleString() {
      var style = window.getComputedStyle(this);
      return Object.keys(style).filter(function (name) {
        return ['fontFamily', 'fontSize', 'color', 'backgroundColor'].indexOf(name) > -1;
      }).reduce(function (current, next) {
        if (next && style[next]) {
          return "".concat(current).concat(next, ": ").concat(style[next], ";");
        } else {
          return current;
        }
      }, this.style);
    }
  }, {
    key: "_passwordChange",
    value: function _passwordChange(password) {
      if (password) {
        this.type = 'password';
      } else {
        this.type = this.type === 'password' ? 'text' : this.type;
      }
    }
  }, {
    key: "maxlengthChanged",
    value: function maxlengthChanged(newValue) {
      // 由于 maxLength 这个 property 设置了 type: number，所以只会为 number/NaN
      if (isNaN(newValue)) {
        this.maxlength = 140;
      } else if (newValue < 0) {
        this.maxlength = +Infinity;
      } else {
        this.maxlength = newValue;
      }

      this.$.inputElement.setAttribute('maxlength', this.maxlength);
    }
  }, {
    key: "defaultTypeChange",
    value: function defaultTypeChange(newValue, oldValue) {
      this.$.inputElement.setAttribute('pattern', '');
    }
  }, {
    key: "filterValue",
    value: function filterValue(val, maxlength) {
      if (!val) {
        return '';
      }

      if (maxlength > 0) {
        return val.slice(0, maxlength);
      }

      return val;
    }
  }, {
    key: "_onInput",
    value: function _onInput(e) {
      e.stopPropagation();
      this.value = this.$.inputElement.value;
      var value = this.value;

      if (value.length > this.maxlength) {
        this.value = value.slice(0, this.maxlength);
      }

      this.triggerEvent('input', {
        value: this.value,
        cursor: this.value.length,
        keyCode: keyCode
      }); // const data = this.getEventTargetData();
      // tt.publish('onKeyboardValueChange', {
      //   value,
      //   inputId: this.webInputId,
      //   data,
      //   cursor: value.length,
      // });
    }
  }, {
    key: "pageReRenderCallback",
    value: function pageReRenderCallback() {
      this.styles = this.getComputedStyleString();
    }
  }, {
    key: "getEventTargetData",
    value: function getEventTargetData() {
      if (!this.bindinput) {
        return '';
      }

      var pid = this.parentCustomComponent(); // method from base

      var e = {
        bindinput: this.bindinput,
        target: {
          id: this.id || '',
          dataset: this.dataset,
          offsetTop: this.$.wrapper.offsetTop,
          offsetLeft: this.$.wrapper.offsetLeft
        },
        isCustomComponent: pid !== null,
        nodeId: pid
      };
      e.currentTarget = e.target;
      return JSON.stringify(e);
    }
  }, {
    key: "_onKeyDown",
    value: function _onKeyDown() {
      this.value = this.$.inputElement.value;

      if (this.value.length > this.maxlength) {
        return false;
      }
    }
  }, {
    key: "_onKeyUp",
    value: function _onKeyUp(e) {
      if (e.keyCode === 13) {
        this.value = this.$.inputElement.value;
        this.triggerEvent('confirm', {
          value: this.value
        });
        this.$.inputElement.blur();
      }
    }
  }, {
    key: "_onFocus",
    value: function _onFocus(e) {
      e.stopPropagation();
      this.value = this.$.inputElement.value;
      this.triggerEvent('focus', {
        value: this.value
      });
    }
  }, {
    key: "_onBlur",
    value: function _onBlur(e) {
      e.stopPropagation();
      this.value = this.$.inputElement.value;
      this.triggerEvent('blur', {
        value: this.value
      });
    }
  }, {
    key: "_checkPlaceholderStyle",
    value: function _checkPlaceholderStyle() {
      var $input = this.$.inputElement;
      $input.classList.remove('input-placeholder');
    }
  }, {
    key: "_checkAutoFocus",
    value: function _checkAutoFocus() {
      if (this.autoFocus || this.focus) {
        this._couldFocus(true);
      }
    }
  }, {
    key: "_couldFocus",
    value: function _couldFocus(focus) {
      var that = this;

      if (this._attached) {
        if (focus) {
          window.requestAnimationFrame(function () {
            that.selectionStart = castNumber(that.selectionStart);
            that.selectionEnd = castNumber(that.selectionEnd);
            that.cursor = castNumber(that.cursor);

            that._inputFocus(that.cursor, that.selectionStart, that.selectionEnd);
          });
        } else {
          this.$.inputElement.blur();
        }
      }
    }
  }, {
    key: "_inputFocus",
    value: function _inputFocus(cursor, selectionStart, selectionEnd) {
      if (!this.disabled) {
        this._focusInputWithSelection(cursor, selectionStart, selectionEnd);
      }
    }
  }, {
    key: "_focusInputWithSelection",
    value: function _focusInputWithSelection(cursor, selectionStart, selectionEnd) {
      this.triggerEvent('focus', {
        value: this.value,
        height: 0
      });
      this.$.inputElement.focus();

      if (typeof selectionStart === 'number' && typeof selectionEnd === 'number' && selectionStart !== -1) {
        this.$.inputElement.setSelectionRange(selectionStart, selectionEnd);
      } else if (typeof cursor === 'number') {
        this.$.inputElement.setSelectionRange(cursor, cursor);
      }

      this.selectionStart = -1;
      this.selectionEnd = -1;
      this.cursor = -1;
    }
  }, {
    key: "_placeholderStyleChange",
    value: function _placeholderStyleChange(newValue, oldValue) {
      if (newValue && newValue !== oldValue) {
        var styleArray = this.shadowRoot.querySelectorAll('style');
        var lastStyleElm = styleArray[styleArray.length - 1];

        if (!lastStyleElm.innerHTML) {
          lastStyleElm.innerHTML = '';
        }

        lastStyleElm.innerHTML += "\n        input::placeholder: {".concat(newValue, "}\n        input::-webkit-input-placeholder{").concat(newValue, "}\n      ");
      }
    }
  }, {
    key: "defaultValueChange",
    value: function defaultValueChange(newValue, oldValue) {
      newValue = newValue || '';
      newValue = newValue.slice(0, this.maxlength);
      this.setAttribute('value', newValue);

      this._checkPlaceholderStyle();
    }
  }, {
    key: "destoryEvents",
    value: function destoryEvents() {
      this.$.inputElement.removeEventListener('input', this._onInput.bind(this));
    }
  }, {
    key: "disconnectedCallback",
    value: function disconnectedCallback() {
      _babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_3___default()(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_6___default()(WebInput.prototype), "disconnectedCallback", this).call(this);

      this.destoryEvents();
    }
  }], [{
    key: "is",
    get: function get() {
      return "".concat(_utils_config__WEBPACK_IMPORTED_MODULE_9__["elementPrefix"], "-input");
    }
  }, {
    key: "properties",
    get: function get() {
      return {
        autoFocus: {
          type: Boolean,
          value: false
        },
        placeholder: {
          type: String,
          value: ''
        },
        placeholderStyle: {
          type: String,
          value: '',
          observer: '_placeholderStyleChange'
        },
        placeholderClass: {
          type: String,
          value: ''
        },
        dropdownStyle: {
          type: Object,
          value: {}
        },
        value: {
          type: String,
          "default": '',
          observer: 'defaultValueChange',
          reflectToAttribute: true
        },
        filteredValue: {
          type: String,
          computed: 'filterValue(value, maxlength)'
        },
        showValue: {
          type: String,
          value: ''
        },
        maxlength: {
          type: Number,
          value: 140,
          reflectToAttribute: true,
          observer: 'maxlengthChanged'
        },
        type: {
          type: String,
          value: 'text',
          observer: 'defaultTypeChange'
        },
        password: {
          type: Boolean,
          value: false,
          observer: '_passwordChange'
        },
        disabled: {
          type: Boolean,
          value: false
        },
        cursorSpacing: {
          type: Number,
          value: 0
        },
        cursor: {
          type: null,
          value: -1
        },
        selectionStart: {
          type: Number,
          value: -1
        },
        selectionEnd: {
          type: Number,
          value: -1
        },
        style: {
          type: String,
          defaultValue: ''
        }
      };
    }
  }, {
    key: "template",
    get: function get() {
      return Object(_polymer_polymer__WEBPACK_IMPORTED_MODULE_7__["html"])(_templateObject || (_templateObject = _babel_runtime_helpers_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0___default()(["\n      <style include=\"input-style\">\n      </style>\n      <div id=\"wrapper\">\n        <input id=\"inputElement\"\n          disabled$=\"[[ disabled ]]\"\n          class$=\"input-placeholder [[ _prefixedPlaceholderClass ]]\"\n          on-input=\"__onChange\"\n          on-focus=\"_onFocus\"\n          on-blur=\"_onBlur\"\n          on-keyDown=\"_onKeyDown\"\n          on-keyUp=\"_onKeyUp\"\n          placeholder$=\"[[placeholder]]\"\n          maxlength=\"[[maxlength]]\"\n          type$=\"[[type]]\"\n          value=\"[[value]]\"\n          style=\"[[styles]]\"\n        >\n      </div>\n    "])));
    }
  }]);

  return WebInput;
}(Object(_mixins__WEBPACK_IMPORTED_MODULE_10__["Data"])(Object(_polymer_polymer_lib_mixins_gesture_event_listeners__WEBPACK_IMPORTED_MODULE_8__["GestureEventListeners"])(Object(_mixins__WEBPACK_IMPORTED_MODULE_10__["Base"])(_polymer_polymer__WEBPACK_IMPORTED_MODULE_7__["PolymerElement"]))));

window.customElements.define(WebInput.is, WebInput);

/***/ }),

/***/ "./src/web-components/label.js":
/*!*************************************!*\
  !*** ./src/web-components/label.js ***!
  \*************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _babel_runtime_helpers_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/taggedTemplateLiteral */ "./node_modules/@babel/runtime/helpers/taggedTemplateLiteral.js");
/* harmony import */ var _babel_runtime_helpers_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _polymer_polymer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @polymer/polymer */ "./node_modules/@polymer/polymer/polymer-element.js");
/* harmony import */ var _utils_config__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @/utils/config */ "./src/utils/config.js");
/* harmony import */ var _mixins__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./mixins */ "./src/web-components/mixins/index.js");







var _templateObject;

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5___default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5___default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4___default()(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }





var Label = /*#__PURE__*/function (_Base) {
  _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3___default()(Label, _Base);

  var _super = _createSuper(Label);

  function Label() {
    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, Label);

    return _super.apply(this, arguments);
  }

  _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(Label, [{
    key: "listeners",
    get: function get() {
      return {
        tap: 'onTap'
      };
    }
  }, {
    key: "onTap",
    value: function onTap(e) {
      var labelTarget;
      var labelFor = this.htmlFor; // tma-html-compiler会把for输出到htmlFor

      if (labelFor) {
        labelTarget = this.querySelector("#".concat(labelFor)) || document.getElementById(labelFor);
      } else {
        labelTarget = this._dfs(this);
      }

      if (labelTarget && labelTarget.handleLabelTap && e.target !== labelTarget) {
        labelTarget.handleLabelTap(e);
      }
    }
  }, {
    key: "_dfs",
    value: function _dfs(parent) {
      // 查找子节点中isLabelTarget为true的结点
      if (parent.isLabelTarget) {
        return parent;
      }

      var children = Array.from(parent.children);

      for (var i = 0; i < children.length; i += 1) {
        var target = this._dfs(children[i]);

        if (target) {
          return target;
        }
      }
    }
  }], [{
    key: "is",
    get: function get() {
      return "".concat(_utils_config__WEBPACK_IMPORTED_MODULE_7__["elementPrefix"], "-label");
    }
  }, {
    key: "properties",
    get: function get() {
      return {};
    }
  }, {
    key: "template",
    get: function get() {
      return Object(_polymer_polymer__WEBPACK_IMPORTED_MODULE_6__["html"])(_templateObject || (_templateObject = _babel_runtime_helpers_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0___default()(["\n      <style>\n        :host {\n          -webkit-tap-highlight-color: rgba(0,0,0,0);\n        }     \n      </style>     \n      <slot></slot>\n    "])));
    }
  }]);

  return Label;
}(Object(_mixins__WEBPACK_IMPORTED_MODULE_8__["Base"])(_polymer_polymer__WEBPACK_IMPORTED_MODULE_6__["PolymerElement"]));

window.customElements.define(Label.is, Label);

/***/ }),

/***/ "./src/web-components/mixins/base.js":
/*!*******************************************!*\
  !*** ./src/web-components/mixins/base.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Base; });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/get */ "./node_modules/@babel/runtime/helpers/get.js");
/* harmony import */ var _babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _utils_addListenerToElement__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/utils/addListenerToElement */ "./src/utils/addListenerToElement.js");







function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5___default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5___default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4___default()(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

/* eslint-disable no-inner-declarations */

/* eslint-disable func-names */

function Base(SuperClass) {
  return /*#__PURE__*/function (_SuperClass) {
    _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3___default()(_class, _SuperClass);

    var _super = _createSuper(_class);

    function _class() {
      _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default()(this, _class);

      return _super.apply(this, arguments);
    }

    _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1___default()(_class, [{
      key: "connectedCallback",
      value: function connectedCallback() {
        _babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_2___default()(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5___default()(_class.prototype), "connectedCallback", this).call(this);
      }
    }, {
      key: "ready",
      value: function ready() {
        _babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_2___default()(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5___default()(_class.prototype), "ready", this).call(this);

        if (this.listeners) {
          var loop = function loop(i, l) {
            var _this = this;

            var item = eventKeys[i];
            var eventHandler = this.listeners[item];
            var m = item.split('.');
            var eventTarget = m.length > 1 ? m[0] : null;
            var eventKey = eventTarget ? m[1] : m[0];
            Object(_utils_addListenerToElement__WEBPACK_IMPORTED_MODULE_6__["default"])(eventTarget ? this.$[eventTarget] : this, eventKey, function (e) {
              return _this[eventHandler].call(_this, e);
            });
          };

          var eventKeys = Object.keys(this.listeners);

          for (var i = 0, l = eventKeys.length; i < l; i += 1) {
            loop.call(this, i, l);
          }
        }
      }
    }, {
      key: "hasBehavior",
      value: function hasBehavior(type) {
        // simple mock of hasBehavior method
        if (type === 'base') {
          return true;
        }

        return false;
      }
    }, {
      key: "triggerEvent",
      value: function triggerEvent(eventName) {
        var detail = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        // 这个api用来触发组件自己独有的事件，比如swiper的change，input的focus，
        var e = new CustomEvent(eventName, {
          detail: detail,
          bubbles: false,
          // 微信的做法，这些事件都不会冒泡
          composed: false
        });
        this.dispatchEvent(e);
      }
    }, {
      key: "_deserializeValue",
      value: function _deserializeValue(value, type) {
        if (type === Boolean) {
          return !!value;
        }

        if (type === String) {
          if (value === undefined || value === null) {
            return '';
          } // compiler会把value=""编译成value: true, 兼容一下


          if (typeof value === 'boolean' && value) {
            return '';
          }

          return value.toString();
        }

        return _babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_2___default()(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5___default()(_class.prototype), "_deserializeValue", this).call(this, value, type);
      }
    }], [{
      key: "properties",
      get: function get() {
        return {
          hidden: {
            type: Boolean,
            reflectToAttribute: true
          }
        };
      }
    }]);

    return _class;
  }(SuperClass);
}

/***/ }),

/***/ "./src/web-components/mixins/data.js":
/*!*******************************************!*\
  !*** ./src/web-components/mixins/data.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Data; });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/get */ "./node_modules/@babel/runtime/helpers/get.js");
/* harmony import */ var _babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _utils_config__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/utils/config */ "./src/utils/config.js");







function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5___default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5___default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4___default()(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }


function Data(superClass) {
  return /*#__PURE__*/function (_superClass) {
    _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3___default()(_class, _superClass);

    var _super = _createSuper(_class);

    function _class() {
      _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default()(this, _class);

      return _super.apply(this, arguments);
    }

    _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1___default()(_class, [{
      key: "getFormData",
      value: function getFormData(fn) {
        fn(this.value || '');
      }
    }, {
      key: "resetFormData",
      value: function resetFormData() {// will be overwritten by subClass
      }
    }, {
      key: "hasBehavior",
      value: function hasBehavior(type) {
        if (type === "".concat(_utils_config__WEBPACK_IMPORTED_MODULE_6__["elementPrefix"], "-data")) {
          return true;
        }

        return _babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_2___default()(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5___default()(_class.prototype), "hasBehavior", this).call(this, type);
      }
    }], [{
      key: "properties",
      get: function get() {
        return {
          name: {
            type: String
          }
        };
      }
    }]);

    return _class;
  }(superClass);
}

/***/ }),

/***/ "./src/web-components/mixins/disabled.js":
/*!***********************************************!*\
  !*** ./src/web-components/mixins/disabled.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Disabled; });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__);






function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4___default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4___default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3___default()(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function Disabled(superClass) {
  return /*#__PURE__*/function (_superClass) {
    _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2___default()(_class, _superClass);

    var _super = _createSuper(_class);

    function _class() {
      _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default()(this, _class);

      return _super.apply(this, arguments);
    }

    _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1___default()(_class, null, [{
      key: "properties",
      get: function get() {
        return {
          disabled: {
            type: Boolean,
            value: false
          }
        };
      }
    }]);

    return _class;
  }(superClass);
}

/***/ }),

/***/ "./src/web-components/mixins/group.js":
/*!********************************************!*\
  !*** ./src/web-components/mixins/group.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Group; });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/get */ "./node_modules/@babel/runtime/helpers/get.js");
/* harmony import */ var _babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _utils_config__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/utils/config */ "./src/utils/config.js");







function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5___default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5___default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4___default()(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }


function Group(superClass) {
  return /*#__PURE__*/function (_superClass) {
    _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3___default()(_class, _superClass);

    var _super = _createSuper(_class);

    function _class() {
      _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default()(this, _class);

      return _super.apply(this, arguments);
    }

    _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1___default()(_class, [{
      key: "ready",
      value: function ready() {
        _babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_2___default()(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5___default()(_class.prototype), "ready", this).call(this);

        this.addEventListener('itemValueChanged', this._handleItemValueChanged);
        this.addEventListener('itemAdded', this._handleItemAdded);
        this.addEventListener('itemCheckedChanged', this._handleItemCheckedChanged);
        this.addEventListener('itemRemoved', this._handleItemRemoved);
        this.addEventListener('itemChangedByTap', this._handleChangedByTap);
      }
    }, {
      key: "_handleItemValueChanged",
      value: function _handleItemValueChanged(e) {
        this.renameItem(e.detail.item, e.detail.newVal, e.detail.oldVal);
      }
    }, {
      key: "_handleItemCheckedChanged",
      value: function _handleItemCheckedChanged(e) {
        this.changed(e.detail.item);
      }
    }, {
      key: "_handleItemAdded",
      value: function _handleItemAdded(e) {
        if (!e.detail.item._relatedGroup) {
          e.detail.item._relatedGroup = this;
          this.addItem(e.detail.item);
        }

        return false;
      }
    }, {
      key: "_handleItemRemoved",
      value: function _handleItemRemoved(e) {
        this.removeItem(e.detail.item);
        return false;
      }
    }, {
      key: "_handleChangedByTap",
      value: function _handleChangedByTap() {
        this.triggerEvent('change', {
          value: this.value
        });
      }
    }, {
      key: "resetFormData",
      value: function resetFormData() {
        if (this.hasBehavior("".concat(_utils_config__WEBPACK_IMPORTED_MODULE_6__["elementPrefix"], "-data"))) {
          !function dfs(t) {
            t.childNodes && Array.from(t.childNodes).forEach(function (t) {
              if (t.hasBehavior) {
                if (t.hasBehavior("".concat(_utils_config__WEBPACK_IMPORTED_MODULE_6__["elementPrefix"], "-group"))) {
                  return;
                }

                if (t.hasBehavior("".concat(_utils_config__WEBPACK_IMPORTED_MODULE_6__["elementPrefix"], "-item"))) {
                  return t.resetFormData();
                }
              }

              dfs(t);
            });
          }(this);
        }
      }
    }, {
      key: "addItem",
      value: function addItem() {}
    }, {
      key: "removeItem",
      value: function removeItem() {}
    }, {
      key: "renameItem",
      value: function renameItem() {}
    }, {
      key: "changed",
      value: function changed() {}
    }, {
      key: "hasBehavior",
      value: function hasBehavior(type) {
        if (type === "".concat(_utils_config__WEBPACK_IMPORTED_MODULE_6__["elementPrefix"], "-group")) {
          return true;
        }

        return _babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_2___default()(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5___default()(_class.prototype), "hasBehavior", this).call(this, type);
      }
    }]);

    return _class;
  }(superClass);
}

/***/ }),

/***/ "./src/web-components/mixins/hover.js":
/*!********************************************!*\
  !*** ./src/web-components/mixins/hover.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Hover; });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/get */ "./node_modules/@babel/runtime/helpers/get.js");
/* harmony import */ var _babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _utils_supportsPassive__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/utils/supportsPassive */ "./src/utils/supportsPassive.js");







function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5___default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5___default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4___default()(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }


var PASSIVE_TOUCH = _utils_supportsPassive__WEBPACK_IMPORTED_MODULE_6__["default"] ? {
  passive: true
} : undefined;
function Hover(SuperClass) {
  return /*#__PURE__*/function (_SuperClass) {
    _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3___default()(_class, _SuperClass);

    var _super = _createSuper(_class);

    function _class() {
      var _this;

      _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default()(this, _class);

      _this = _super.call(this);
      _this._hoverClass = [];
      return _this;
    }

    _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1___default()(_class, [{
      key: "hasBehavior",
      value: function hasBehavior(type) {
        // simple mock of hasBehavior method
        if (type === 'hover') {
          return true;
        }

        if (_babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_2___default()(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5___default()(_class.prototype), "hasBehavior", this)) {
          return _babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_2___default()(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5___default()(_class.prototype), "hasBehavior", this).call(this, type);
        }
      }
    }, {
      key: "bindHover",
      value: function bindHover() {
        if (!this._bindHover) {
          this._bindHover = true;
          this._hoverTouchStartId = this.hoverTouchStart.bind(this);
          this._hoverTouchEndId = this.hoverTouchEnd.bind(this);
          this._hoverCancelId = this.hoverCancel.bind(this);
          this.addEventListener('touchstart', this._hoverTouchStartId, PASSIVE_TOUCH);
          this.addEventListener('touchend', this._hoverTouchEndId);
          this.addEventListener('touchcancel', this._hoverCancelId);
          this.addEventListener('touchmove', this._hoverCancelId, PASSIVE_TOUCH);
        }
      }
    }, {
      key: "unbindHover",
      value: function unbindHover() {
        if (this._bindHover) {
          this._bindHover = false;
          this.removeEventListener('touchstart', this._hoverTouchStartId);
          this.removeEventListener('touchend', this._hoverTouchEndId);
          this.removeEventListener('touchcancel', this._hoverCancelId);
          this.removeEventListener('touchmove', this._hoverCancelId);
        }
      }
    }, {
      key: "hoverTouchStart",
      value: function hoverTouchStart(e) {
        var _this2 = this;

        if (!e._hoverPropagationStopped) {
          if (this.hoverStopPropagation) {
            e._hoverPropagationStopped = true;
          }

          if (this._hoverTouch && e.touches.length > 1 && !this._hovering) {
            this.hoverCancel();
            return;
          }

          this._hoverTouch = true;

          if (this.hoverClass === 'none' || this.disabled) {
            return;
          }

          this._hoverStyleTimeId = setTimeout(function () {
            _this2._hovering = true;

            if (_this2._hoverClass.length > 0) {
              for (var _e = 0; _e < _this2._hoverClass.length; _e++) {
                _this2.classList.toggle(_this2._hoverClass[_e], true);
              }
            }

            if (!_this2._hoverTouch) {
              window.requestAnimationFrame(function () {
                clearTimeout(_this2._hoverStayTimeId);
                _this2._hoverStayTimeId = setTimeout(function () {
                  _this2._hoverReset();
                }, _this2.hoverStayTime);
              });
            }
          }, this.hoverStartTime);
        }
      }
    }, {
      key: "hoverTouchEnd",
      value: function hoverTouchEnd() {
        var _this3 = this;

        this._hoverTouch = false;

        if (this._hovering) {
          window.requestAnimationFrame(function () {
            clearTimeout(_this3._hoverStayTimeId);
            _this3._hoverStayTimeId = setTimeout(function () {
              _this3._hoverReset();
            }, _this3.hoverStayTime);
          });
        }
      }
    }, {
      key: "hoverCancel",
      value: function hoverCancel() {
        this._hoverTouch = false;
        clearTimeout(this._hoverStyleTimeId);

        this._hoverReset();
      }
    }, {
      key: "_hoverClassChange",
      value: function _hoverClassChange(targetClassName) {
        if (!targetClassName) {
          return;
        }

        var classes = targetClassName.split(/\s/);
        this._hoverClass = []; // remove hover effects

        if (targetClassName === 'none' && !this.hoverStopPropagation) {
          return this.unbindHover();
        }

        for (var n = 0; n < classes.length; n += 1) {
          classes[n] && this._hoverClass.push(classes[n]);
        }

        this.bindHover();
      }
    }, {
      key: "_hoverStopChange",
      value: function _hoverStopChange(e) {
        if (this.hoverClass === 'none' && !e) {
          return this.unbindHover();
        }

        this.bindHover();
      }
    }, {
      key: "_hoverReset",
      value: function _hoverReset() {
        if (this._hovering) {
          this._hovering = false;

          if (this.hoverClass !== 'none' && this._hoverClass.length > 0) {
            for (var e = 0; e < this._hoverClass.length; e++) {
              if (this.classList.contains(this._hoverClass[e])) {
                this.classList.toggle(this._hoverClass[e], false);
              }
            }
          }
        }
      }
    }], [{
      key: "properties",
      get: function get() {
        return {
          hoverStartTime: {
            type: Number,
            value: 50
          },
          hoverStayTime: {
            type: Number,
            value: 400
          },
          hoverClass: {
            type: String,
            observer: '_hoverClassChange'
          },
          hoverStopPropagation: {
            type: Boolean,
            observer: '_hoverStopChange'
          }
        };
      }
    }]);

    return _class;
  }(SuperClass);
}

/***/ }),

/***/ "./src/web-components/mixins/index.js":
/*!********************************************!*\
  !*** ./src/web-components/mixins/index.js ***!
  \********************************************/
/*! exports provided: Base, Hover, LabelTarget, Item, Disabled, Group, Data, TouchTrack */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ "./src/web-components/mixins/base.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Base", function() { return _base__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _hover__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./hover */ "./src/web-components/mixins/hover.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Hover", function() { return _hover__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _label_target__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./label-target */ "./src/web-components/mixins/label-target.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LabelTarget", function() { return _label_target__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _item__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./item */ "./src/web-components/mixins/item.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Item", function() { return _item__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _disabled__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./disabled */ "./src/web-components/mixins/disabled.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Disabled", function() { return _disabled__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _group__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./group */ "./src/web-components/mixins/group.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Group", function() { return _group__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony import */ var _data__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./data */ "./src/web-components/mixins/data.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Data", function() { return _data__WEBPACK_IMPORTED_MODULE_6__["default"]; });

/* harmony import */ var _touch_track__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./touch-track */ "./src/web-components/mixins/touch-track.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TouchTrack", function() { return _touch_track__WEBPACK_IMPORTED_MODULE_7__["default"]; });











/***/ }),

/***/ "./src/web-components/mixins/item.js":
/*!*******************************************!*\
  !*** ./src/web-components/mixins/item.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Item; });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/get */ "./node_modules/@babel/runtime/helpers/get.js");
/* harmony import */ var _babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _utils_config__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/utils/config */ "./src/utils/config.js");







function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5___default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5___default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4___default()(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }


function Item(superClass) {
  return /*#__PURE__*/function (_superClass) {
    _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3___default()(_class, _superClass);

    var _super = _createSuper(_class);

    function _class() {
      _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default()(this, _class);

      return _super.apply(this, arguments);
    }

    _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1___default()(_class, [{
      key: "hasBehavior",
      value: function hasBehavior(type) {
        if (type === "".concat(_utils_config__WEBPACK_IMPORTED_MODULE_6__["elementPrefix"], "-item")) {
          return true;
        }

        return _babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_2___default()(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5___default()(_class.prototype), "hasBehavior", this).call(this, type);
      }
    }, {
      key: "connectedCallback",
      value: function connectedCallback() {
        _babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_2___default()(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5___default()(_class.prototype), "connectedCallback", this).call(this);

        this.dispatchEvent(new CustomEvent('itemAdded', {
          detail: {
            item: this
          },
          bubbles: true
        }));
      }
    }, {
      key: "disconnectedCallback",
      value: function disconnectedCallback() {
        _babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_2___default()(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5___default()(_class.prototype), "disconnectedCallback", this).call(this);

        if (this._relatedGroup) {
          this._relatedGroup.dispatchEvent(new CustomEvent('itemRemoved', {
            detail: {
              item: this
            }
          }));

          this._relatedGroup = null;
        }
      }
    }, {
      key: "moved",
      value: function moved() {
        if (this._relatedGroup) {
          this._relatedGroup.dispatchEvent(new CustomEvent('itemRemoved'));

          this._relatedGroup = null;
        }

        this.dispatchEvent(new CustomEvent('itemAdded', {
          detail: {
            item: this
          },
          bubbles: true
        }));
      }
    }, {
      key: "valueChange",
      value: function valueChange(newVal, oldVal) {
        if (this._relatedGroup) {
          this._relatedGroup.dispatchEvent(new CustomEvent('itemValueChanged', {
            detail: {
              item: this,
              newVal: newVal,
              oldVal: oldVal
            }
          }));
        }
      }
    }, {
      key: "checkedChange",
      value: function checkedChange(newValue, oldValue) {
        if (typeof oldValue !== 'undefined' && newValue !== oldValue && this._relatedGroup) {
          this._relatedGroup.dispatchEvent(new CustomEvent('itemCheckedChanged', {
            detail: {
              item: this
            }
          }));
        }
      }
    }, {
      key: "changedByTap",
      value: function changedByTap() {
        if (this._relatedGroup) {
          this._relatedGroup.dispatchEvent(new CustomEvent('itemChangedByTap'));
        }
      }
    }, {
      key: "resetFormData",
      value: function resetFormData() {
        this.checked = false;
      }
    }], [{
      key: "properties",
      get: function get() {
        return {
          value: {
            type: String,
            observer: 'valueChange'
          },
          checked: {
            type: Boolean,
            value: false,
            observer: 'checkedChange'
          }
        };
      }
    }]);

    return _class;
  }(superClass);
}

/***/ }),

/***/ "./src/web-components/mixins/label-target.js":
/*!***************************************************!*\
  !*** ./src/web-components/mixins/label-target.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return LabelTarget; });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__);






function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4___default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4___default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3___default()(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function LabelTarget(superClass) {
  return /*#__PURE__*/function (_superClass) {
    _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2___default()(_class, _superClass);

    var _super = _createSuper(_class);

    function _class() {
      _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default()(this, _class);

      return _super.apply(this, arguments);
    }

    _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1___default()(_class, [{
      key: "isLabelTarget",
      get: function get() {
        return true;
      }
    }, {
      key: "handleLabelTap",
      value: function handleLabelTap(e) {// do nothing
      }
    }]);

    return _class;
  }(superClass);
}

/***/ }),

/***/ "./src/web-components/mixins/touch-track.js":
/*!**************************************************!*\
  !*** ./src/web-components/mixins/touch-track.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return TouchTrack; });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__);






function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4___default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4___default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3___default()(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

/* eslint-disable no-multi-assign */
function TouchTrack(superClass) {
  return /*#__PURE__*/function (_superClass) {
    _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2___default()(_class, _superClass);

    var _super = _createSuper(_class);

    function _class() {
      _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default()(this, _class);

      return _super.apply(this, arguments);
    }

    _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1___default()(_class, [{
      key: "touchtrack",
      value: function touchtrack(el, method, n) {
        var _this = this;

        var startX = 0;
        var startY = 0;
        var dx = 0;
        var dy = 0;

        var handleEvent = function handleEvent(e, state, pageX, pageY) {
          if (_this[method].call(_this, {
            target: e.target,
            currentTarget: e.currentTarget,
            preventDefault: e.preventDefault.bind(e),
            stopPropagation: e.stopPropagation.bind(e),
            touches: e.touches,
            changedTouches: e.changedTouches,
            detail: {
              state: state,
              x: pageX,
              y: pageY,
              dx: pageX - startX,
              dy: pageY - startY,
              ddx: pageX - dx,
              ddy: pageY - dy,
              timeStamp: e.timeStamp
            }
          }) === false) {
            return false;
          }
        };

        var originalEvent = null;
        el.addEventListener('touchstart', function (e) {
          if (e.touches && e.touches.length === 1 && !originalEvent) {
            originalEvent = e;
            startX = dx = e.touches[0].pageX;
            startY = dy = e.touches[0].pageY;
            handleEvent(e, 'start', startX, startY);
          }
        });
        el.addEventListener('touchmove', function (e) {
          if (e.touches && e.touches.length === 1 && originalEvent) {
            var t = handleEvent(e, 'move', e.touches[0].pageX, e.touches[0].pageY);
            dx = e.touches[0].pageX;
            dy = e.touches[0].pageY;
            return t;
          }
        });
        el.addEventListener('touchend', function (e) {
          if (e.touches && e.touches.length === 0 && originalEvent) {
            originalEvent = null;
            return handleEvent(e, 'end', e.changedTouches[0].pageX, e.changedTouches[0].pageY);
          }
        });
        el.addEventListener('touchcancel', function (e) {
          if (originalEvent) {
            var t = originalEvent;
            originalEvent = null;
            return handleEvent(e, n ? 'cancel' : 'end', t.touches[0].pageX, t.touches[0].pageY);
          }
        });
      }
    }]);

    return _class;
  }(superClass);
}

/***/ }),

/***/ "./src/web-components/page.js":
/*!************************************!*\
  !*** ./src/web-components/page.js ***!
  \************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _babel_runtime_helpers_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/taggedTemplateLiteral */ "./node_modules/@babel/runtime/helpers/taggedTemplateLiteral.js");
/* harmony import */ var _babel_runtime_helpers_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _polymer_polymer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @polymer/polymer */ "./node_modules/@polymer/polymer/polymer-element.js");
/* harmony import */ var _utils_config__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @/utils/config */ "./src/utils/config.js");







var _templateObject;

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5___default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5___default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4___default()(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }




var Page = /*#__PURE__*/function (_PolymerElement) {
  _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3___default()(Page, _PolymerElement);

  var _super = _createSuper(Page);

  function Page() {
    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, Page);

    return _super.apply(this, arguments);
  }

  _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(Page, null, [{
    key: "is",
    get: function get() {
      return "".concat(_utils_config__WEBPACK_IMPORTED_MODULE_7__["elementPrefix"], "-page");
    }
  }, {
    key: "template",
    get: function get() {
      return Object(_polymer_polymer__WEBPACK_IMPORTED_MODULE_6__["html"])(_templateObject || (_templateObject = _babel_runtime_helpers_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0___default()(["\n      <style>      \n        :host {\n          cursor: default;\n          -webkit-user-select: none;\n          user-select: none;\n          -webkit-touch-callout: none;\n          width: 100%;\n          overflow-x: hidden;\n          -webkit-text-size-adjust: none;\n          text-size-adjust: none;\n        }\n      </style>\n      <slot></slot>\n    "])));
    }
  }]);

  return Page;
}(_polymer_polymer__WEBPACK_IMPORTED_MODULE_6__["PolymerElement"]);

window.customElements.define(Page.is, Page);

/***/ }),

/***/ "./src/web-components/progress.js":
/*!****************************************!*\
  !*** ./src/web-components/progress.js ***!
  \****************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _babel_runtime_helpers_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/taggedTemplateLiteral */ "./node_modules/@babel/runtime/helpers/taggedTemplateLiteral.js");
/* harmony import */ var _babel_runtime_helpers_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/get */ "./node_modules/@babel/runtime/helpers/get.js");
/* harmony import */ var _babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _polymer_polymer__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @polymer/polymer */ "./node_modules/@polymer/polymer/polymer-element.js");
/* harmony import */ var _utils_config__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @/utils/config */ "./src/utils/config.js");
/* harmony import */ var _mixins__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./mixins */ "./src/web-components/mixins/index.js");








var _templateObject;

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_6___default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_6___default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_5___default()(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }




var documentContainer = document.createElement('div');
documentContainer.setAttribute('style', 'display: none;');
documentContainer.innerHTML = "\n  <dom-module id=\"progress-style\">\n    <template>\n      <style>\n          :host {\n              display: -webkit-flex;\n              display: flex;\n              -webkit-align-items: center;\n                      align-items: center;\n              width: 100%;\n          }\n          :host .progress-wrapper {\n            flex: 1;\n            overflow: hidden;\n          }\n          :host .progress-inner{\n              width: 0;\n              height: 100%;\n          }\n          :host .progress-info {\n            margin-top: 0;\n            margin-bottom: 0;\n            min-width: 2em;\n            margin-left: 15px;\n          }\n      </style>\n    </template>\n  </dom-module>\n";
document.head.appendChild(documentContainer);
var DEFAULT_BACKGROUND_COLOR = '#EBEBEB';
var DEFAULT_ACTIVE_COLOR = '#F85959';
var BACKWARDS = 'backwards';
var FORWARDS = 'forwards';

var Progress = /*#__PURE__*/function (_Base) {
  _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_4___default()(Progress, _Base);

  var _super = _createSuper(Progress);

  function Progress() {
    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, Progress);

    return _super.apply(this, arguments);
  }

  _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(Progress, [{
    key: "percentChange",
    value: function percentChange(newValue, oldValue) {
      if (newValue < 0) {
        this.percent = 0;
      }

      if (newValue > 100) {
        this.percent = 100;
      }

      if (this.timerid) {
        clearInterval(this.timerid);
      } // 第一次执行percentChange时，参数oldValue一定为undefined;
      // 如果将undefined赋值给lastPercent,会影响下方timer函数（line: 99）的执行
      // 所以令lastPercent = percent


      this.lastPercent = oldValue === undefined ? this.percent : oldValue;
      this.activeChange(this.active);
    }
  }, {
    key: "activeChange",
    value: function activeChange(newValue) {
      // false => true
      if (newValue) {
        var timer = function timer() {
          if (this.percent <= this.currentPercent + 1) {
            this.currentPercent = this.percent;
            clearInterval(this.timerid);
          } else {
            ++this.currentPercent;
          }
        };

        this.currentPercent = FORWARDS === this.activeMode ? this.lastPercent : 0;
        this.timerid = setInterval(timer.bind(this), 30);
        timer.call(this);
      } else {
        this.currentPercent = this.percent;
      }
    }
  }, {
    key: "connectedCallback",
    value: function connectedCallback(e) {
      _babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_3___default()(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_6___default()(Progress.prototype), "connectedCallback", this).call(this);

      this.lastPercent = this.percent || 0;
    }
  }, {
    key: "disconnectedCallback",
    value: function disconnectedCallback(e) {
      _babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_3___default()(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_6___default()(Progress.prototype), "disconnectedCallback", this).call(this);

      if (this.timerid) {
        clearInterval(this.timerid);
      }
    }
  }], [{
    key: "is",
    get: function get() {
      return "".concat(_utils_config__WEBPACK_IMPORTED_MODULE_8__["elementPrefix"], "-progress");
    }
  }, {
    key: "properties",
    get: function get() {
      return {
        percent: {
          type: Number,
          value: 0,
          observer: 'percentChange'
        },
        currentPercent: {
          type: Number
        },
        strokeWidth: {
          type: Number,
          value: 6
        },
        showInfo: {
          type: Boolean,
          value: false
        },
        color: {
          type: String,
          value: DEFAULT_ACTIVE_COLOR
        },
        activeColor: {
          type: String,
          value: DEFAULT_ACTIVE_COLOR
        },
        backgroundColor: {
          type: String,
          value: DEFAULT_BACKGROUND_COLOR
        },
        active: {
          type: Boolean,
          value: false,
          observer: 'activeChange'
        },
        activeMode: {
          type: String,
          value: BACKWARDS
        }
      };
    }
  }, {
    key: "template",
    get: function get() {
      return Object(_polymer_polymer__WEBPACK_IMPORTED_MODULE_7__["html"])(_templateObject || (_templateObject = _babel_runtime_helpers_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0___default()(["\n      <style include=\"progress-style\">\n      </style>\n\n      <div class=\"progress-wrapper\" style$=\"background-color: [[backgroundColor]]; height: [[strokeWidth]]px;\">\n        <div class=\"progress-inner\" style$=\"width: [[currentPercent]]%; background-color: [[activeColor]]; \">\n        </div>\n      </div>\n\n      <template is=\"dom-if\" if=\"{{showInfo}}\">\n        <div class=\"progress-info\">\n          [[currentPercent]]%\n        </div>\n      </template>\n    "])));
    }
  }]);

  return Progress;
}(Object(_mixins__WEBPACK_IMPORTED_MODULE_9__["Base"])(_polymer_polymer__WEBPACK_IMPORTED_MODULE_7__["PolymerElement"]));

window.customElements.define(Progress.is, Progress);

/***/ }),

/***/ "./src/web-components/radio-group.js":
/*!*******************************************!*\
  !*** ./src/web-components/radio-group.js ***!
  \*******************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _babel_runtime_helpers_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/taggedTemplateLiteral */ "./node_modules/@babel/runtime/helpers/taggedTemplateLiteral.js");
/* harmony import */ var _babel_runtime_helpers_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _polymer_polymer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @polymer/polymer */ "./node_modules/@polymer/polymer/polymer-element.js");
/* harmony import */ var _utils_config__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @/utils/config */ "./src/utils/config.js");
/* harmony import */ var _mixins__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./mixins */ "./src/web-components/mixins/index.js");







var _templateObject;

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5___default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5___default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4___default()(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }





var RadioGroup = /*#__PURE__*/function (_Group) {
  _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3___default()(RadioGroup, _Group);

  var _super = _createSuper(RadioGroup);

  function RadioGroup() {
    var _this;

    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, RadioGroup);

    _this = _super.call(this);
    _this._selectedItem = null;
    return _this;
  }

  _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(RadioGroup, [{
    key: "childItemType",
    get: function get() {
      return "".concat(_utils_config__WEBPACK_IMPORTED_MODULE_7__["elementPrefix"], "-radio");
    }
  }, {
    key: "addItem",
    value: function addItem(e) {
      if (e.checked) {
        if (this._selectedItem) {
          this._selectedItem.checked = false;
        }

        this.value = e.value;
        this._selectedItem = e;
      }
    }
  }, {
    key: "removeItem",
    value: function removeItem(e) {
      if (this._selectedItem === e) {
        this.value = '';
        this._selectedItem = null;
      }
    }
  }, {
    key: "renameItem",
    value: function renameItem(e, t) {
      this._selectedItem === e && (this.value = t);
    }
  }, {
    key: "changed",
    value: function changed(e) {
      if (this._selectedItem === e) {
        this.removeItem(e);
      } else {
        this.addItem(e);
      }
    }
  }], [{
    key: "is",
    get: function get() {
      return "".concat(_utils_config__WEBPACK_IMPORTED_MODULE_7__["elementPrefix"], "-radio-group");
    }
  }, {
    key: "properties",
    get: function get() {
      return {
        value: {
          type: String
        }
      };
    }
  }, {
    key: "template",
    get: function get() {
      return Object(_polymer_polymer__WEBPACK_IMPORTED_MODULE_6__["html"])(_templateObject || (_templateObject = _babel_runtime_helpers_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0___default()(["\n      <style>\n        :host {\n          display: block;\n        }\n        :host([ hidden ]) {\n          display: none;\n        }\n      </style>\n      <slot></slot>\n    "])));
    }
  }]);

  return RadioGroup;
}(Object(_mixins__WEBPACK_IMPORTED_MODULE_8__["Group"])(Object(_mixins__WEBPACK_IMPORTED_MODULE_8__["Data"])(Object(_mixins__WEBPACK_IMPORTED_MODULE_8__["Base"])(_polymer_polymer__WEBPACK_IMPORTED_MODULE_6__["PolymerElement"]))));

window.customElements.define(RadioGroup.is, RadioGroup);

/***/ }),

/***/ "./src/web-components/radio.js":
/*!*************************************!*\
  !*** ./src/web-components/radio.js ***!
  \*************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _babel_runtime_helpers_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/taggedTemplateLiteral */ "./node_modules/@babel/runtime/helpers/taggedTemplateLiteral.js");
/* harmony import */ var _babel_runtime_helpers_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _polymer_polymer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @polymer/polymer */ "./node_modules/@polymer/polymer/polymer-element.js");
/* harmony import */ var _utils_config__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @/utils/config */ "./src/utils/config.js");
/* harmony import */ var _mixins__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./mixins */ "./src/web-components/mixins/index.js");







var _templateObject;

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5___default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5___default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4___default()(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }




var documentContainer = document.createElement('div');
documentContainer.setAttribute('style', 'display: none;');
documentContainer.innerHTML = "<dom-module id=\"radio-style\">\n  <template>\n    <style>\n      :host {\n        -webkit-tap-highlight-color: transparent;\n        display: inline-block;\n      }\n      :host([ hidden ]) {\n        display: none;\n      }\n      :host .radio-wrapper {\n        display: -webkit-inline-flex;\n        display: inline-flex;\n        -webkit-align-items: center;\n                align-items: center;\n        vertical-align: middle;\n      }\n      :host .radio-input {\n        -webkit-appearance: none;\n                appearance: none;\n        margin-right: 5px;\n        outline: 0;\n        border: 1px solid #E8E8E8;\n        border-radius: 50%;\n        background-color: #FFFFFF;\n        width: 22px;\n        height: 22px;\n        position: relative;\n      }\n     \n      :host .radio-input.radio-input-checked:before {\n        font: normal normal normal 14px/1 \"ttui\";\n        content: \"\\e601\";\n        color: #ffffff;\n        font-size: 28px;\n        position: absolute;\n        top: 50%;\n        left: 50%;\n        transform: translate(-50%, -48%) scale(0.73);\n        -webkit-transform: translate(-50%, -48%) scale(0.73);\n      }\n    </style>\n  </template>\n</dom-module>";
document.head.appendChild(documentContainer);

var Radio = /*#__PURE__*/function (_Disabled) {
  _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3___default()(Radio, _Disabled);

  var _super = _createSuper(Radio);

  function Radio() {
    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, Radio);

    return _super.apply(this, arguments);
  }

  _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(Radio, [{
    key: "listeners",
    get: function get() {
      return {
        tap: 'onInputTap'
      };
    }
  }, {
    key: "onInputTap",
    value: function onInputTap() {
      if (this.disabled) {
        return;
      }

      if (!this.checked) {
        this.checked = true;
        this.changedByTap();
      }
    }
  }, {
    key: "handleLabelTap",
    value: function handleLabelTap() {
      this.onInputTap();
    }
  }, {
    key: "hasCheckedClass",
    value: function hasCheckedClass(checked) {
      return checked ? 'radio-input-checked' : '';
    }
  }, {
    key: "hasDisabledClass",
    value: function hasDisabledClass(disabled) {
      return disabled ? 'radio-input-disabled' : '';
    }
  }, {
    key: "_getColor",
    value: function _getColor(e, t) {
      return e ? t : '';
    }
  }, {
    key: "judgeDisableColor",
    value: function judgeDisableColor(color) {
      return this.disabled ? '#e8e8e8' : color;
    }
  }], [{
    key: "is",
    get: function get() {
      return "".concat(_utils_config__WEBPACK_IMPORTED_MODULE_7__["elementPrefix"], "-radio");
    }
  }, {
    key: "properties",
    get: function get() {
      return {
        color: {
          type: String,
          value: '#F85959'
        },
        checkedColor: {
          type: String,
          computed: '_getColor(checked, color)'
        }
      };
    }
  }, {
    key: "template",
    get: function get() {
      return Object(_polymer_polymer__WEBPACK_IMPORTED_MODULE_6__["html"])(_templateObject || (_templateObject = _babel_runtime_helpers_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0___default()(["\n      <style include=\"radio-style\">\n      </style>\n      <div class=\"radio-wrapper\">\n        <div id=\"input\" class$=\"radio-input [[hasCheckedClass(checked)]] [[hasDisabledClass(disabled)]]\" style$=\"background-color: [[judgeDisableColor(checkedColor)]]; border-color: [[judgeDisableColor(checkedColor)]]\">\n        </div>\n        <slot></slot>\n      </div>\n    "])));
    }
  }]);

  return Radio;
}(Object(_mixins__WEBPACK_IMPORTED_MODULE_8__["Disabled"])(Object(_mixins__WEBPACK_IMPORTED_MODULE_8__["Item"])(Object(_mixins__WEBPACK_IMPORTED_MODULE_8__["LabelTarget"])(Object(_mixins__WEBPACK_IMPORTED_MODULE_8__["Base"])(_polymer_polymer__WEBPACK_IMPORTED_MODULE_6__["PolymerElement"])))));

window.customElements.define(Radio.is, Radio);

/***/ }),

/***/ "./src/web-components/scroll-view.js":
/*!*******************************************!*\
  !*** ./src/web-components/scroll-view.js ***!
  \*******************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _babel_runtime_helpers_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/taggedTemplateLiteral */ "./node_modules/@babel/runtime/helpers/taggedTemplateLiteral.js");
/* harmony import */ var _babel_runtime_helpers_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ "./node_modules/@babel/runtime/helpers/asyncToGenerator.js");
/* harmony import */ var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/assertThisInitialized.js");
/* harmony import */ var _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/get */ "./node_modules/@babel/runtime/helpers/get.js");
/* harmony import */ var _babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js");
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var _polymer_polymer__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @polymer/polymer */ "./node_modules/@polymer/polymer/polymer-element.js");
/* harmony import */ var _utils_config__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @/utils/config */ "./src/utils/config.js");
/* harmony import */ var _mixins__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./mixins */ "./src/web-components/mixins/index.js");
/* harmony import */ var _utils_bezier__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./utils/bezier */ "./src/web-components/utils/bezier.js");










var _templateObject;



function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_8___default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_8___default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_7___default()(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }





var easyOutEasing = Object(_utils_bezier__WEBPACK_IMPORTED_MODULE_13__["default"])(0, 0, 0.58, 1);

var ScrollView = /*#__PURE__*/function (_TouchTrack) {
  _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_6___default()(ScrollView, _TouchTrack);

  var _super = _createSuper(ScrollView);

  function ScrollView() {
    var _this;

    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_2___default()(this, ScrollView);

    _this = _super.call(this);
    _this._handleScroll = _this._handleScroll.bind(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4___default()(_this));
    _this.__pageRerender = _this._pageRerender.bind(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4___default()(_this));
    _this.__handleTouchStart = _this.__handleTouchStart.bind(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4___default()(_this));
    _this.__handleTouchMove = _this.__handleTouchMove.bind(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4___default()(_this));
    _this.__handleTouchEnd = _this.__handleTouchEnd.bind(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4___default()(_this));
    _this.__handleScroll = _this.__handleScroll.bind(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4___default()(_this));
    return _this;
  }

  _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_3___default()(ScrollView, [{
    key: "scrollTop",
    get: function get() {
      return this.$$scrollTop;
    },
    set: function set(newValue) {
      var old = this.$$scrollTop;
      this.$$scrollTop = this._deserializeValue(newValue, Number);

      if (this._attached) {
        this._scrollTopChanged(this.$$scrollTop, old);
      }
    }
  }, {
    key: "scrollLeft",
    get: function get() {
      return this.$$scrollLeft;
    },
    set: function set(newValue) {
      var old = this.$$scrollLeft;
      this.$$scrollLeft = this._deserializeValue(newValue, Number);

      if (this._attached) {
        this._scrollLeftChanged(this.$$scrollLeft, old);
      }
    }
  }, {
    key: "scrollIntoView",
    get: function get() {
      return this.$$scrollIntoView;
    },
    set: function set(newValue) {
      var old = this.$$scrollIntoView;
      this.$$scrollIntoView = this._deserializeValue(newValue, String);

      if (this._attached) {
        this._scrollIntoViewChanged(this.$$scrollIntoView, old);
      }
    }
  }, {
    key: "ready",
    value: function ready() {
      _babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_5___default()(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_8___default()(ScrollView.prototype), "ready", this).call(this);

      this.touchtrack(this.$.main, '_handleTrack');
    }
  }, {
    key: "connectedCallback",
    value: function connectedCallback() {
      _babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_5___default()(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_8___default()(ScrollView.prototype), "connectedCallback", this).call(this);

      this._attached = true;
      this._lastScrollTop = this.scrollTop || 0;
      this._lastScrollLeft = this.scrollLeft || 0;
      this._lastScrollToUpperTime = 0;
      this._lastScrollToLowerTime = 0;

      this._scrollXChanged(this.scrollX);

      this._scrollYChanged(this.scrollY);

      this._scrollTopChanged(this.scrollTop);

      this._scrollLeftChanged(this.scrollLeft);

      this._scrollIntoViewChanged(this.scrollIntoView);

      this.$.main.addEventListener('touchstart', this.__handleTouchStart);
      this.$.main.addEventListener('touchmove', this.__handleTouchMove);
      this.$.main.addEventListener('touchend', this.__handleTouchEnd);
      this.$.main.addEventListener('scroll', this.__handleScroll);
    }
  }, {
    key: "disconnectedCallback",
    value: function disconnectedCallback() {
      _babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_5___default()(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_8___default()(ScrollView.prototype), "disconnectedCallback", this).call(this);

      this.$.main.removeEventListener('scroll', this.__handleScroll);
      this.$.main.removeEventListener('touchstart', this.__handleTouchStart);
      this.$.main.removeEventListener('touchmove', this.__handleTouchMove);
      this.$.main.removeEventListener('touchend', this.__handleTouchEnd);
    }
  }, {
    key: "__handleTouchMove",
    value: function __handleTouchMove(e) {
      var _this2 = this;

      // 如果当前在做scrollTop的动画，直接清除动画。
      if (this.__rafId) {
        this.__currentAnimCanceled = true;
        setTimeout(function () {
          _this2.__currentAnimCanceled = false;
        }, 50);
      }

      if (this.__hasKeyboard) {
        // 解决ios的bug
        this.__hasKeyboard = false; // this.invoke('endEditing');
      }
    }
  }, {
    key: "__handleTouchStart",
    value: function __handleTouchStart(e) {
      var $main = this.$.main;

      if ($main.scrollHeight > $main.offsetHeight) {// this.invoke('disableScrollBounce', {
        //   disable: true,
        // });
      }
    }
  }, {
    key: "__handleTouchEnd",
    value: function __handleTouchEnd(e) {
      // e.target不指向main，所以此处手动指定
      this._handleScroll({
        target: this.$.main,
        timeStamp: e.timeStamp
      }, true); // this.invoke('disableScrollBounce', {
      //   disable: false,
      // });

    }
  }, {
    key: "__handleScroll",
    value: function __handleScroll(e) {
      e.preventDefault();
      e.stopPropagation();

      this._handleScroll(e);

      document.dispatchEvent(new CustomEvent("".concat(_utils_config__WEBPACK_IMPORTED_MODULE_11__["elementPrefix"], "-scroll-view")));
    }
  }, {
    key: "scrollTo",
    value: function () {
      var _scrollTo = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1___default()( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_9___default.a.mark(function _callee(scrollTop, direction) {
        var _this$$, main, content, r, getTransformStr;

        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_9___default.a.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (this.__rafId) {
                  _context.next = 13;
                  break;
                }

                _this$$ = this.$, main = _this$$.main, content = _this$$.content;

                if (scrollTop < 0) {
                  scrollTop = 0;
                } else if (direction === 'x' && scrollTop > main.scrollWidth - main.offsetWidth) {
                  scrollTop = main.scrollWidth - main.offsetWidth;
                } else if (direction === 'y' && scrollTop > main.scrollHeight - main.offsetHeight) {
                  scrollTop = main.scrollHeight - main.offsetHeight;
                }

                r = 0;

                if (direction === 'x') {
                  r = main.scrollLeft - scrollTop;
                } else if (direction === 'y') {
                  r = main.scrollTop - scrollTop;
                }

                if (!(r !== 0)) {
                  _context.next = 13;
                  break;
                }

                getTransformStr = function getTransformStr() {
                  return '';
                };

                if (direction === 'x') {
                  getTransformStr = function getTransformStr(val) {
                    return "translateX(".concat(val, "px) translateZ(0)");
                  };
                } else if (direction === 'y') {
                  getTransformStr = function getTransformStr(val) {
                    return "translateY(".concat(val, "px) translateZ(0)");
                  };
                }

                this.__transitionEnd = this._transitionEnd.bind(this, scrollTop, direction);

                if (direction === 'x') {
                  main.style.overflowX = 'hidden';
                } else if (direction === 'y') {
                  main.style.overflowY = 'hidden';
                }

                _context.next = 12;
                return this._doScrollTopChangeAnimate(content, r, getTransformStr);

              case 12:
                this.__transitionEnd();

              case 13:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function scrollTo(_x, _x2) {
        return _scrollTo.apply(this, arguments);
      }

      return scrollTo;
    }()
  }, {
    key: "_doScrollTopChangeAnimate",
    value: function _doScrollTopChangeAnimate(content, scrollTop, getTransformStr) {
      var _this3 = this;

      return new Promise(function (resolve) {
        _this3.__rafId = null;
        var duration = 300;
        var start;

        var animate = function animate() {
          var ts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
          start = start || ts;
          var dt = ts - start;
          var percent = Math.min(dt / duration, 1);
          var curTransform = getTransformStr(easyOutEasing(percent) * scrollTop);
          content.style.transform = curTransform;
          content.style.webkitTransform = curTransform;

          if (dt >= duration || this.__currentAnimCanceled) {
            window.cancelAnimationFrame(this.__rafId);
            this.__rafId = null;
            resolve();
          } else {
            this.__rafId = window.requestAnimationFrame(animate);
          }
        };

        animate();
      });
    }
  }, {
    key: "_getStyle",
    value: function _getStyle(overflowX, overflowY) {
      return "overflow-x: ".concat(overflowX ? 'auto' : 'hidden', "; overflow-y: ").concat(overflowY ? 'auto' : 'hidden', ";");
    }
  }, {
    key: "_handleTrack",
    value: function _handleTrack(e) {
      if (e.detail.state === 'start') {
        this._noBubble = null;
        return;
      }

      if (e.detail.state === 'end') {
        this._noBubble = false;
      }

      if (this._noBubble === null && this.scrollY) {
        if (Math.abs(e.detail.ddy) / Math.abs(e.detail.ddx) > 1) {
          this._noBubble = true;
        } else {
          this._noBubble = false;
        }
      }

      if (this._noBubble === null && this.scrollX) {
        if (Math.abs(e.detail.ddx) / Math.abs(e.detail.ddy) > 1) {
          this._noBubble = true;
        } else {
          this._noBubble = false;
        }
      }

      if (this._noBubble) {
        e.stopPropagation(); // 发个别的事件，避免需要touchmove的场景得不到应有的事件

        this.dispatchEvent(new CustomEvent("".concat(_utils_config__WEBPACK_IMPORTED_MODULE_11__["elementPrefix"], "-touchmove"), {
          detail: {
            srcMoveEvent: e
          },
          bubbles: true,
          composed: true
        }));
      }
    }
  }, {
    key: "_handleScroll",
    value: function _handleScroll(e) {
      var fireByTouchEnd = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (!(e.timeStamp - this._lastScrollTime < 20) || fireByTouchEnd) {
        this._lastScrollTime = e.timeStamp;
        var _e$target = e.target,
            scrollTop = _e$target.scrollTop,
            scrollHeight = _e$target.scrollHeight,
            scrollWidth = _e$target.scrollWidth,
            scrollLeft = _e$target.scrollLeft,
            offsetHeight = _e$target.offsetHeight,
            offsetWidth = _e$target.offsetWidth;

        if (!fireByTouchEnd) {
          this.triggerEvent('scroll', {
            scrollLeft: scrollLeft,
            scrollTop: scrollTop,
            scrollHeight: scrollHeight,
            scrollWidth: scrollWidth,
            deltaX: this._lastScrollLeft - scrollLeft,
            deltaY: this._lastScrollTop - scrollTop
          });
        }

        if (this.scrollY) {
          var n = this._lastScrollTop - scrollTop > 0;
          var i = this._lastScrollTop - scrollTop < 0;

          if (Math.floor(scrollTop) <= this.upperThreshold && n && e.timeStamp - this._lastScrollToUpperTime > 200) {
            this.triggerEvent('scrolltoupper', {
              direction: 'top'
            });
            this._lastScrollToUpperTime = e.timeStamp;
          }

          if (Math.ceil(scrollTop) + offsetHeight + this.lowerThreshold >= scrollHeight && i && e.timeStamp - this._lastScrollToLowerTime > 200) {
            this.triggerEvent('scrolltolower', {
              direction: 'bottom'
            });
            this._lastScrollToLowerTime = e.timeStamp;
          }
        }

        if (this.scrollX) {
          var r = this._lastScrollLeft - scrollLeft > 0;
          var o = this._lastScrollLeft - scrollLeft < 0;

          if (Math.floor(scrollLeft) <= this.upperThreshold && r && e.timeStamp - this._lastScrollToUpperTime > 200) {
            this.triggerEvent('scrolltoupper', {
              direction: 'top'
            });
            this._lastScrollToUpperTime = e.timeStamp;
          }

          if (Math.ceil(scrollLeft) + offsetWidth + this.lowerThreshold >= scrollWidth && o && e.timeStamp - this._lastScrollToLowerTime > 200) {
            this.triggerEvent('scrolltolower', {
              direction: 'bottom'
            });
            this._lastScrollToLowerTime = e.timeStamp;
          }
        }

        this._lastScrollTop = scrollTop;
        this._lastScrollLeft = scrollLeft;
      }
    }
  }, {
    key: "_scrollXChanged",
    value: function _scrollXChanged(e) {
      if (e) {
        if (this.scrollY) {
          document.removeEventListener('pageReRender', this.__pageRerender);
          this.$.main.style.overflowX = 'auto';
          this.$.main.style.paddingBottom = '';
          this.$.wrap.style.overflowY = '';
          this.$.wrap.style.height = '';
          this.$.content.style.height = '100%';
          return;
        }

        undefined === this._isAutoHeight && this._checkIsAutoHeight();
        this.$.main.style.overflowX = 'auto';
        this.$.main.style.paddingBottom = '20px';
        this.$.wrap.style.overflowY = 'hidden';

        if (this._isAutoHeight) {
          this.$.wrap.style.height = "".concat(this.$.content.offsetHeight, "px");
          this.$.content.style.height = '';
        } else {
          this.$.wrap.style.height = '';
          this.$.content.style.height = "".concat(this.offsetHeight, "px");
        }

        document.addEventListener('pageReRender', this.__pageRerender);
      } else {
        document.removeEventListener('pageReRender', this.__pageRerender);
        this.$.main.style.overflowX = 'hidden';
        this.$.main.style.paddingBottom = '';
        this.$.wrap.style.overflowY = '';
        this.$.wrap.style.height = '';
        this.$.content.style.height = '100%';
      }
    }
  }, {
    key: "_scrollYChanged",
    value: function _scrollYChanged(e) {
      this.$.main.style.overflowY = e ? 'auto' : 'hidden';
    }
  }, {
    key: "_checkIsAutoHeight",
    value: function _checkIsAutoHeight() {
      this.$.wrap.style.height = 0;
      var e = getComputedStyle(this);
      var t = parseFloat(e.borderBottomWidth) || 0;
      var n = parseFloat(e.borderTopWidth) || 0;
      var i = parseFloat(e.paddingTop) || 0;
      var r = parseFloat(e.paddingBottom) || 0;
      this._isAutoHeight = this.offsetHeight === t + n + i + r;
      var o = 1e4 * Math.random() | 0;
      this.$.wrap.style.height = "".concat(o, "px");
      e = getComputedStyle(this);
      t = parseFloat(e.borderBottomWidth) || 0;
      n = parseFloat(e.borderTopWidth) || 0;
      i = parseFloat(e.paddingTop) || 0;
      r = parseFloat(e.paddingBottom) || 0;
      this._isAutoHeight = this._isAutoHeight || this.offsetHeight === t + n + i + r + o;
    }
  }, {
    key: "_scrollTopChanged",
    value: function _scrollTopChanged(scrollTop) {
      var _this4 = this;

      if (isNaN(scrollTop)) {
        scrollTop = 0;
      }

      if (this.scrollY) {
        Promise.resolve().then(function () {
          _this4.scrollWithAnimation ? _this4.scrollTo(scrollTop, 'y') : _this4.$.main.scrollTop = scrollTop;
        });
      }
    }
  }, {
    key: "_scrollLeftChanged",
    value: function _scrollLeftChanged(scrollLeft) {
      var _this5 = this;

      if (isNaN(scrollLeft)) {
        scrollLeft = 0;
      }

      if (this.scrollX) {
        Promise.resolve().then(function () {
          _this5.scrollWithAnimation ? _this5.scrollTo(scrollLeft, 'x') : _this5.$.main.scrollLeft = scrollLeft;
        });
      }
    }
  }, {
    key: "_scrollIntoViewChanged",
    value: function _scrollIntoViewChanged(targetId) {
      var _this6 = this;

      if (!targetId) {
        return;
      }

      if (!/^[_a-zA-Z][-_a-zA-Z0-9:]*$/.test(targetId)) {
        console.warn("scroll-into-view=\"".concat(targetId, "\" \u6709\u8BEF"));
        console.warn('target id 属性值格式错误');
        return;
      } // wait for detached tree ready


      setTimeout(function () {
        var targetEle = _this6.querySelector("#".concat(targetId));

        if (!targetEle) {
          return;
        }

        var mainStyle = _this6.$.main.getBoundingClientRect();

        var targetStyle = targetEle.getBoundingClientRect();

        if (_this6.scrollX) {
          var gapX = targetStyle.left - mainStyle.left;
          var mainLeft = _this6.$.main.scrollLeft;
          var scrollLeft = mainLeft + gapX;
          _this6.scrollWithAnimation ? _this6.scrollTo(scrollLeft, 'x') : _this6.$.main.scrollLeft = scrollLeft;
        }

        if (_this6.scrollY) {
          var gapY = targetStyle.top - mainStyle.top;
          var mainScrollTop = _this6.$.main.scrollTop;
          var scrollTop = mainScrollTop + gapY;
          _this6.scrollWithAnimation ? _this6.scrollTo(scrollTop, 'y') : _this6.$.main.scrollTop = scrollTop;
        }
      }, 10);
    }
  }, {
    key: "getScrollPosition",
    value: function getScrollPosition() {
      var e = this.$.main;
      return {
        scrollLeft: e.scrollLeft,
        scrollTop: e.scrollTop
      };
    }
  }, {
    key: "_transitionEnd",
    value: function _transitionEnd(e, oldOne) {
      var _this$$2 = this.$,
          main = _this$$2.main,
          content = _this$$2.content;
      content.style.transform = '';
      content.style.webkitTransform = '';

      if (oldOne === 'x') {
        main.style.overflowX = this.scrollX ? 'auto' : 'hidden';
        main.scrollLeft = e;
      } else if (oldOne === 'y') {
        main.style.overflowY = this.scrollY ? 'auto' : 'hidden';
        main.scrollTop = e;
      }
    }
  }, {
    key: "_pageRerender",
    value: function _pageRerender() {
      var _this7 = this;

      window.requestAnimationFrame(function () {
        if (!(_this7.offsetHeight === _this7._lastOutterHeight && _this7.$.content.offsetHeight === _this7._lastContenHeight)) {
          _this7._checkIsAutoHeight();

          if (_this7._isAutoHeight) {
            _this7.$.wrap.style.height = "".concat(_this7.$.content.offsetHeight, "px");
            _this7.$.content.style.height = '';
          } else {
            _this7.$.wrap.style.height = '';
            _this7.$.content.style.height = "".concat(_this7.offsetHeight, "px");
          }

          _this7._lastOutterHeight = _this7.offsetHeight;
          _this7._lastContenHeight = _this7.$.content.offsetHeight;
        }
      });
    }
  }], [{
    key: "is",
    get: function get() {
      return "".concat(_utils_config__WEBPACK_IMPORTED_MODULE_11__["elementPrefix"], "-scroll-view");
    }
  }, {
    key: "properties",
    get: function get() {
      return {
        scrollX: {
          type: Boolean,
          value: false,
          observer: '_scrollXChanged',
          reflectToAttribute: true
        },
        scrollY: {
          type: Boolean,
          value: false,
          observer: '_scrollYChanged',
          reflectToAttribute: true
        },
        upperThreshold: {
          type: Number,
          value: 50
        },
        lowerThreshold: {
          type: Number,
          value: 50
        },
        scrollWithAnimation: {
          type: Boolean,
          value: false,
          reflectToAttribute: true
        }
      };
    }
  }, {
    key: "template",
    get: function get() {
      return Object(_polymer_polymer__WEBPACK_IMPORTED_MODULE_10__["html"])(_templateObject || (_templateObject = _babel_runtime_helpers_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0___default()(["\n      <style>\n        :host {\n          display: block;\n          width: 100%;\n        }\n\n        :host([ hidden ]) {\n          display: none;\n        }\n\n        .scroll {\n          position: relative;\n          -webkit-overflow-scrolling: touch;\n          height: 100%;\n          width: 100%;\n          max-height: inherit;\n        }\n\n        .scroll::-webkit-scrollbar {\n          display: none;\n        }\n      </style>\n\n      <div id=\"wrap\" class=\"scroll\">\n        <div id=\"main\" style=\"overflow-x: hidden; overflow-y: hidden;\" class=\"scroll\">\n          <div id=\"content\">\n            <slot></slot>\n          </div>\n        </div>\n      </div>\n    "])));
    }
  }]);

  return ScrollView;
}(Object(_mixins__WEBPACK_IMPORTED_MODULE_12__["TouchTrack"])(Object(_mixins__WEBPACK_IMPORTED_MODULE_12__["Base"])(_polymer_polymer__WEBPACK_IMPORTED_MODULE_10__["PolymerElement"])));

window.customElements.define(ScrollView.is, ScrollView);

/***/ }),

/***/ "./src/web-components/slider.js":
/*!**************************************!*\
  !*** ./src/web-components/slider.js ***!
  \**************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _babel_runtime_helpers_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/taggedTemplateLiteral */ "./node_modules/@babel/runtime/helpers/taggedTemplateLiteral.js");
/* harmony import */ var _babel_runtime_helpers_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/get */ "./node_modules/@babel/runtime/helpers/get.js");
/* harmony import */ var _babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _polymer_polymer__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @polymer/polymer */ "./node_modules/@polymer/polymer/polymer-element.js");
/* harmony import */ var _utils_config__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @/utils/config */ "./src/utils/config.js");
/* harmony import */ var _mixins__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./mixins */ "./src/web-components/mixins/index.js");








var _templateObject;

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_6___default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_6___default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_5___default()(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }




var documentContainer = document.createElement('div');
documentContainer.setAttribute('style', 'display: none;');
documentContainer.innerHTML = "<dom-module id=\"slider-style\">\n  <template>\n    <style>\n      :host {\n        margin: 10px 18px;\n        padding: 0;\n        display: block;\n      }\n\n      :host([hidden]) {\n        display: none;\n      }\n\n      :host * {\n        -webkit-tap-highlight-color: rgba(0,0,0,0);\n      }\n\n      :host .slider-wrapper {\n        display: -webkit-flex;\n        display: flex;\n        -webkit-align-items: center;\n                align-items: center;\n        min-height: 16px;\n      }\n      :host .slider-tap-area {\n        -webkit-flex: 1;\n                flex: 1;\n        padding: 8px 0;\n      }\n      :host .slider-handle-wrapper {\n        position: relative;\n        height: 2px;\n        border-radius: 5px;\n        background-color: #e9e9e9;\n        cursor: pointer;\n        transition: background-color 0.3s ease;\n        -webkit-tap-highlight-color: transparent;\n      }\n      :host .slider-track {\n        height: 100%;\n        border-radius: 6px;\n        background-color: #1aad19;\n        transition: background-color 0.3s ease;\n      }\n      :host .slider-handle,\n      :host .slider-thumb {\n        position: absolute;\n        left: 50%;\n        top: 50%;\n        cursor: pointer;\n        border-radius: 50%;\n        transition: border-color 0.3s ease;\n      }\n      :host .slider-handle {\n        width: 28px;\n        height: 28px;\n        margin-top: -14px;\n        margin-left: -14px;\n        background-color: transparent;\n        z-index: 3;\n        border: 0 solid rgba(0,0,0,0.04);\n        /*box-shadow: 0 3px 8px 0 rgba(0,0,0,0.15);*/\n      }\n      :host .slider-thumb {\n        z-index: 2;\n        /*box-shadow: 0 0 4px rgba(0, 0, 0, 0.2);*/\n        box-shadow: 0 3px 8px rgba(0, 0, 0, 0.2);\n      }\n      :host .slider-step {\n        position: absolute;\n        width: 100%;\n        height: 2px;\n        background: transparent;\n        z-index: 1;\n      }\n      :host .slider-value {\n        color: #888;\n        font-size: 14px;\n        margin-left: 1em;\n      }\n      :host .slider-disabled .slider-track {\n        background-color: #ccc;\n      }\n      :host .slider-disabled .slider-thumb {\n        background-color: #FFF;\n        border-color: #ccc;\n      }\n      :host * {\n        margin: 0;\n      }\n    </style>\n  </template>\n</dom-module>";
document.head.appendChild(documentContainer);

var Slider = /*#__PURE__*/function (_TouchTrack) {
  _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_4___default()(Slider, _TouchTrack);

  var _super = _createSuper(Slider);

  function Slider() {
    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, Slider);

    return _super.apply(this, arguments);
  }

  _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(Slider, [{
    key: "listeners",
    get: function get() {
      return {
        'wrapper.tap': '_onTap'
      };
    }
  }, {
    key: "ready",
    value: function ready() {
      _babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_3___default()(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_6___default()(Slider.prototype), "ready", this).call(this);

      this.touchtrack(this.$.handle, '_onTrack');
    }
  }, {
    key: "_filterValue",
    value: function _filterValue(e) {
      if (e < this.min) {
        return this.min;
      } else if (e > this.max) {
        return this.max;
      }

      return Math.round((e - this.min) / this.step) * this.step + this.min;
    }
  }, {
    key: "_revalicateRange",
    value: function _revalicateRange() {
      var n = this._filterValue(this.value);

      if (isDecimal(this.min) || isDecimal(this.max) || isDecimal(this.step)) {
        var i = Math.max(getPrecision(this.min), getPrecision(this.max), getPrecision(this.step));
        n = +n.toFixed(i);
      }

      this._filteredValue = n;
    }
  }, {
    key: "_getValueWidth",
    value: function _getValueWidth(e, min, max) {
      e = e || 0;

      if (max === min) {
        return e - min ? '100%' : '0%';
      }

      return "".concat(100 * (e - min) / (max - min), "%");
    }
  }, {
    key: "_getBlockSize",
    value: function _getBlockSize(e) {
      var t = 12;
      var n = 28;
      return e < t ? t : e > n ? n : e;
    }
  }, {
    key: "_getBackgroundColor",
    value: function _getBackgroundColor(e, t) {
      return t !== '#FFFFFF' ? t : e !== '#FFFFFF' ? e : '#FFFFFF';
    }
  }, {
    key: "_getActiveColor",
    value: function _getActiveColor(e, t) {
      return t !== '#F85959' ? t : e !== '#F85959' ? e : '#F85959';
    }
  }, {
    key: "_getThumbStyles",
    value: function _getThumbStyles(filteredValue) {
      var width = this._getBlockSize(this.blockSize);

      var height = width;
      var marginLeft = -width / 2;
      var marginTop = -width / 2;

      var left = this._getValueWidth(filteredValue, this.min, this.max);

      var backgroundColor = this.blockColor;
      return "width: ".concat(width, "px;height: ").concat(height, "px;margin-left: ").concat(marginLeft, "px;margin-top: ").concat(marginTop, "px;left: ").concat(left, ";background-color: ").concat(backgroundColor, ";");
    }
  }, {
    key: "_onUserChangedValue",
    value: function _onUserChangedValue(e) {
      var offsetWidth = this.$.step.offsetWidth;
      var n = this.$.step.getBoundingClientRect().left;
      var value = this.min + (e.detail.x - n) * (this.max - this.min) / offsetWidth;
      value = this._filterValue(value);
      this.value = value;
    }
  }, {
    key: "_onTrack",
    value: function _onTrack(e) {
      if (!this.disabled) {
        if (e.detail.state === 'move') {
          e.preventDefault();

          this._onUserChangedValue(e);

          this.triggerEvent('changing', {
            value: this.value
          });
          return false;
        }

        if (e.detail.state === 'end') {
          this.triggerEvent('change', {
            value: this.value
          });
        }
      }
    }
  }, {
    key: "_onTap",
    value: function _onTap(e) {
      if (!this.disabled) {
        this._onUserChangedValue(e);

        this.triggerEvent('change', {
          value: this.value
        });
      }
    }
  }, {
    key: "resetFormData",
    value: function resetFormData() {
      this.value = this.min;
    }
  }, {
    key: "disabledClass",
    value: function disabledClass(disabled) {
      return disabled ? 'slider-disabled' : '';
    }
  }], [{
    key: "is",
    get: function get() {
      return "".concat(_utils_config__WEBPACK_IMPORTED_MODULE_8__["elementPrefix"], "-slider");
    }
  }, {
    key: "properties",
    get: function get() {
      return {
        min: {
          type: Number,
          value: 0,
          observer: '_revalicateRange'
        },
        max: {
          type: Number,
          value: 100,
          observer: '_revalicateRange'
        },
        step: {
          type: Number,
          value: 1
        },
        value: {
          type: Number,
          value: 0,
          observer: '_revalicateRange'
        },
        showValue: {
          type: Boolean,
          value: false
        },
        activeColor: {
          type: String,
          value: '#F85959'
        },
        backgroundColor: {
          type: String,
          value: '#E8E8E8'
        },
        blockSize: {
          type: Number,
          value: 28
        },
        blockColor: {
          type: String,
          value: '#FFFFFF'
        },
        selectedColor: {
          type: String,
          value: '#F85959'
        },
        color: {
          type: String,
          value: '#E8E8E8'
        },
        _filteredValue: {
          type: Number
        }
      };
    }
  }, {
    key: "template",
    get: function get() {
      return Object(_polymer_polymer__WEBPACK_IMPORTED_MODULE_7__["html"])(_templateObject || (_templateObject = _babel_runtime_helpers_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0___default()(["\n      <style include=\"slider-style\"></style>\n\n      <div class$=\"slider-wrapper [[disabledClass(disabled)]]\">\n        <div id=\"wrapper\" class=\"slider-tap-area\">\n          <div class=\"slider-handle-wrapper\" style$=\"background-color: [[_getBackgroundColor(color, backgroundColor)]];\">\n            <div id=\"handle\" class=\"slider-handle\" style$=\"left: [[_getValueWidth(_filteredValue, min, max)]];\">\n            </div>\n            <div class=\"slider-thumb\" style$=\"[[_getThumbStyles(_filteredValue)]]\">\n            </div>\n            <div class=\"slider-track\" style$=\"width: [[_getValueWidth(_filteredValue, min, max)]];background-color: [[_getActiveColor(selectedColor, activeColor)]];\">\n            </div>\n            <div id=\"step\" class=\"slider-step\"></div>\n          </div>\n        </div>\n        <template is=\"dom-if\" if=\"{{showValue}}\">\n          <span class=\"slider-value\">[[_filteredValue]]</span>\n        </template>\n      </div>\n    "])));
    }
  }]);

  return Slider;
}(Object(_mixins__WEBPACK_IMPORTED_MODULE_9__["TouchTrack"])(Object(_mixins__WEBPACK_IMPORTED_MODULE_9__["Disabled"])(Object(_mixins__WEBPACK_IMPORTED_MODULE_9__["Data"])(Object(_mixins__WEBPACK_IMPORTED_MODULE_9__["Base"])(_polymer_polymer__WEBPACK_IMPORTED_MODULE_7__["PolymerElement"])))));

function isDecimal(e) {
  return e % 1 !== 0;
}

function getPrecision(t) {
  t = +t;
  return isNaN(t) || !isDecimal(t) ? 0 : t.toString().split('.')[1].length;
}

window.customElements.define(Slider.is, Slider);

/***/ }),

/***/ "./src/web-components/styles/index.less":
/*!**********************************************!*\
  !*** ./src/web-components/styles/index.less ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "./src/web-components/swiper-item.js":
/*!*******************************************!*\
  !*** ./src/web-components/swiper-item.js ***!
  \*******************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _babel_runtime_helpers_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/taggedTemplateLiteral */ "./node_modules/@babel/runtime/helpers/taggedTemplateLiteral.js");
/* harmony import */ var _babel_runtime_helpers_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/get */ "./node_modules/@babel/runtime/helpers/get.js");
/* harmony import */ var _babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _polymer_polymer__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @polymer/polymer */ "./node_modules/@polymer/polymer/polymer-element.js");
/* harmony import */ var _utils_config__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @/utils/config */ "./src/utils/config.js");
/* harmony import */ var _mixins__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./mixins */ "./src/web-components/mixins/index.js");








var _templateObject;

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_6___default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_6___default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_5___default()(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }





var SwiperItem = /*#__PURE__*/function (_Base) {
  _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_4___default()(SwiperItem, _Base);

  var _super = _createSuper(SwiperItem);

  function SwiperItem() {
    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, SwiperItem);

    return _super.apply(this, arguments);
  }

  _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(SwiperItem, [{
    key: "ready",
    value: function ready() {
      _babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_3___default()(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_6___default()(SwiperItem.prototype), "ready", this).call(this);

      this._relatedSwiper = this._findSwiper(this.parentElement);

      if (!this._relatedSwiper) {
        throw new Error('<swiper-item> can only be used as child of <swiper>');
      }
    }
  }, {
    key: "connectedCallback",
    value: function connectedCallback() {
      _babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_3___default()(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_6___default()(SwiperItem.prototype), "connectedCallback", this).call(this);

      this._originalDisplay = this.style.display;

      this._relatedSwiper.dispatchEvent(new CustomEvent('swiper-item-link', {
        detail: {
          el: this
        },
        bubbles: true
      }));
    }
  }, {
    key: "disconnectedCallback",
    value: function disconnectedCallback() {
      this._relatedSwiper.dispatchEvent(new CustomEvent('swiper-item-unlink', {
        detail: {
          el: this
        },
        bubbles: true
      }));

      _babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_3___default()(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_6___default()(SwiperItem.prototype), "disconnectedCallback", this).call(this);
    }
  }, {
    key: "_findSwiper",
    value: function _findSwiper(el) {
      if (el.tagName === "".concat(_utils_config__WEBPACK_IMPORTED_MODULE_8__["UpperCasePerfix"], "-SWIPER")) {
        return el;
      }

      var parent = el.parentElement;

      if (!parent) {
        return null;
      }

      return this._findSwiper(parent);
    }
  }, {
    key: "_updateId",
    value: function _updateId(e, t) {
      this.dispatchEvent(new CustomEvent('swiper-item-idupdate', {
        detail: {
          value: e,
          oldValue: t
        },
        bubbles: true
      }));
    }
  }], [{
    key: "is",
    get: function get() {
      return "".concat(_utils_config__WEBPACK_IMPORTED_MODULE_8__["elementPrefix"], "-swiper-item");
    }
  }, {
    key: "properties",
    get: function get() {
      return {
        itemId: {
          type: String,
          value: '',
          observer: '_updateId'
        }
      };
    }
  }, {
    key: "template",
    get: function get() {
      return Object(_polymer_polymer__WEBPACK_IMPORTED_MODULE_7__["html"])(_templateObject || (_templateObject = _babel_runtime_helpers_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0___default()(["\n      <style>\n        :host {\n          display: block;\n          overflow: hidden;\n          will-change: 'transform';\n        }\n\n        :host([ hidden ]) {\n          display: none;\n        }\n      </style>\n      <slot></slot>\n    "])));
    }
  }]);

  return SwiperItem;
}(Object(_mixins__WEBPACK_IMPORTED_MODULE_9__["Base"])(_polymer_polymer__WEBPACK_IMPORTED_MODULE_7__["PolymerElement"]));

window.customElements.define(SwiperItem.is, SwiperItem);

/***/ }),

/***/ "./src/web-components/swiper.js":
/*!**************************************!*\
  !*** ./src/web-components/swiper.js ***!
  \**************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _babel_runtime_helpers_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/taggedTemplateLiteral */ "./node_modules/@babel/runtime/helpers/taggedTemplateLiteral.js");
/* harmony import */ var _babel_runtime_helpers_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/assertThisInitialized.js");
/* harmony import */ var _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/get */ "./node_modules/@babel/runtime/helpers/get.js");
/* harmony import */ var _babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _polymer_polymer__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @polymer/polymer */ "./node_modules/@polymer/polymer/polymer-element.js");
/* harmony import */ var _utils_config__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @/utils/config */ "./src/utils/config.js");
/* harmony import */ var _mixins__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./mixins */ "./src/web-components/mixins/index.js");









var _templateObject;

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_7___default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_7___default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_6___default()(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }




var documentContainer = document.createElement('div');
documentContainer.setAttribute('style', 'display: none;');
documentContainer.innerHTML = "\n  <dom-module id=\"swiper-style\">\n    <template>\n      <style>\n        ::slotted(*) {\n          -webkit-user-select: none;\n          user-select: none;\n        }\n        :host {\n          display: block;\n          height: 150px;\n          -webkit-user-select: none;\n          user-select: none;\n        }\n        :host([hidden]) {\n          display: none;\n        }\n        :host .swiper-wrapper {\n          overflow: hidden;\n          position: relative;\n          width: 100%;\n          height: 100%;\n          -webkit-transform: translateZ(0);\n                  transform: translateZ(0);\n        }\n        :host .swiper-slides {\n          position: absolute;\n          left: 0;\n          top: 0;\n          right: 0;\n          bottom: 0;\n        }\n        :host .swiper-slide-frame {\n          position: absolute;\n          left: 0;\n          top: 0;\n          width: 100%;\n          height: 100%;\n          will-change: transform;\n        }\n        :host .swiper-dots {\n          position: absolute;\n          font-size: 0;\n        }\n        :host .swiper-dots-horizontal {\n          left: 50%;\n          bottom: 10px;\n          text-align: center;\n          white-space: nowrap;\n          -webkit-transform: translate(-50%, 0);\n          transform: translate(-50%, 0);\n        }\n        :host .swiper-dots-horizontal .swiper-dot {\n          margin-right: 8px;\n        }\n        :host .swiper-dots-horizontal .swiper-dot:last-child {\n          margin-right: 0;\n        }\n        :host .swiper-dots-vertical {\n          right: 10px;\n          top: 50%;\n          text-align: right;\n          -webkit-transform: translate(0, -50%);\n          transform: translate(0, -50%);\n        }\n        :host .swiper-dots-vertical .swiper-dot {\n          display: block;\n          margin-bottom: 9px;\n        }\n        :host .swiper-dots-vertical .swiper-dot:last-child {\n          margin-bottom: 0;\n        }\n        :host .swiper-dot {\n          display: inline-block;\n          width: 8px;\n          height: 8px;\n          cursor: pointer;\n          transition-property: background-color;\n          transition-timing-function: ease;\n          background: rgba(0, 0, 0, 0.3);\n          border-radius: 50%;\n        }\n        :host .swiper-dot-active {\n          background-color: #000000;\n        }\n      </style>\n    </template>\n  </dom-module>\n";
document.head.appendChild(documentContainer);
var scheduleIntersectionUpdate = null;

var Swiper = /*#__PURE__*/function (_TouchTrack) {
  _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_5___default()(Swiper, _TouchTrack);

  var _super = _createSuper(Swiper);

  function Swiper() {
    var _this;

    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, Swiper);

    _this = _super.call(this);
    _this._attached = false;
    _this._invalid = true;
    _this._circularEnabled = false;
    _this._currentChangeSource = '';
    _this._viewportPosition = 0;
    _this._marginSpecified = false;
    _this._viewportMoveRatio = 1;
    _this._scheduleTimeoutObj = null;
    _this._animating = null;
    _this._requestedAnimation = false;
    _this._animateFrameFunc = _this._animateFrameFuncProto.bind(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_3___default()(_this));
    _this._itemIdItemMap = {};
    _this._items = [];
    _this._itemListDirty = false;
    _this._userTracking = false;
    _this._userDirectionChecked = false;
    _this._contentTrackViewport = 0;
    _this._contentTrackSpeed = 0;
    _this._contentTrackT = 0;
    _this._skipHiddenItemLayoutModified = false;
    _this.__resetLayout_defer_id = null;

    _this.__resetLayout = function () {
      // Throttled layout function
      clearTimeout(_this.__resetLayout_defer_id);
      _this.__resetLayout_defer_id = setTimeout(_this._resetLayout.bind(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_3___default()(_this)), 0);
    };

    return _this;
  }

  _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(Swiper, [{
    key: "ready",
    value: function ready() {
      var _this2 = this;

      _babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_4___default()(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_7___default()(Swiper.prototype), "ready", this).call(this);

      if (this.touchable) {
        this.touchtrack(this.$.slidesWrapper, '_handleContentTrack', true);
      } // watch children


      this.addEventListener('swiper-item-link', function (e) {
        e.stopPropagation();

        _this2._itemListChanged();

        _this2.__resetLayout();
      });
      this.addEventListener('swiper-item-unlink', function (e) {
        e.stopPropagation();

        _this2._itemListChanged();

        if (_this2._getPositionFromCurrent() < 0 && _this2.current !== 0) {
          // 避免触发current的change回调
          _this2._currentChangeSource = '__none__'; // 说明原来的current值已经无效了

          _this2.current = 0;
        }

        _this2.__resetLayout();
      });
      this.addEventListener('swiper-item-idupdate', function (e) {
        e.stopPropagation();
        var _e$detail = e.detail,
            el = _e$detail.el,
            value = _e$detail.value,
            oldValue = _e$detail.oldValue;

        _this2._itemIdUpdated(el, value, oldValue);
      });
    }
  }, {
    key: "connectedCallback",
    value: function connectedCallback() {
      _babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_4___default()(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_7___default()(Swiper.prototype), "connectedCallback", this).call(this);

      this._attached = true;
    }
  }, {
    key: "disconnectedCallback",
    value: function disconnectedCallback() {
      _babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_4___default()(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_7___default()(Swiper.prototype), "disconnectedCallback", this).call(this);

      this._attached = false;

      this._cancelSchedule();
    }
  }, {
    key: "_itemIdUpdated",
    value: function _itemIdUpdated(e, t, n) {
      if (t !== n) {
        this._itemListChanged();

        this.currentItemId && this._currentItemIdChanged();
      }
    }
  }, {
    key: "_currentItemIdChanged",
    value: function _currentItemIdChanged(e) {
      if (this._currentChangeSource === '__none__') {
        this._currentChangeSource = '';
        return;
      }

      if (e !== '') {
        this.current = this._getPositionFromCurrent();
      }
    }
  }, {
    key: "_currentChanged",
    value: function _currentChanged(e, t) {
      if (this._currentChangeSource === '__none__') {
        this._currentChangeSource = '';
        return;
      }

      var n = this._currentChangeSource;
      this._currentChangeSource = '';

      if (!this._isCurrentValueLegal(e)) {
        this.__resetLayout();

        return;
      }

      if (!this._isCurrentValueLegal(t)) {
        this.__resetLayout();

        return;
      }

      if (!n) {
        this._animateViewport(e, '', 0);
      }

      if (e !== t) {
        var i = this._getItems()[e];

        if (i) {
          this.currentItemId = i.itemId;
          this.triggerEvent('change', {
            current: this.current,
            currentItemId: i.itemId,
            source: n
          });
        }

        this._updateDots(e);
      }
    }
  }, {
    key: "_updateMargin",
    value: function _updateMargin() {
      this._marginSpecified = true;

      this.__resetLayout();
    }
  }, {
    key: "_skipHiddenItemLayoutChanged",
    value: function _skipHiddenItemLayoutChanged() {
      this._skipHiddenItemLayoutModified = true;

      this._updateLayout();
    }
  }, {
    key: "_updateLayout",
    value: function _updateLayout() {
      this.__resetLayout();
    }
  }, {
    key: "_displayMultiItemsChanged",
    value: function _displayMultiItemsChanged() {
      var items = this._getItems();

      if (items.length >= this.displayMultipleItems && items.length - this.displayMultipleItems < this.current) {
        this.current = items.length - this.displayMultipleItems;

        if (this.currentItemId) {
          this.currentItemId = items[this.current].itemId;
        }

        this._currentChangeSource = '__none__';
      }

      this.__resetLayout();
    }
  }, {
    key: "_autoplayChanged",
    value: function _autoplayChanged(e) {
      e ? this._scheduleAutoplay() : this._cancelSchedule();
    }
  }, {
    key: "_itemListChanged",
    value: function _itemListChanged() {
      this._itemListDirty = true;
    }
  }, {
    key: "_updateItemList",
    value: function _updateItemList() {
      var _this3 = this;

      this._itemListDirty = false; // get children connected to me

      var swiperItems = Array.prototype.slice.call(this.querySelectorAll("".concat(_utils_config__WEBPACK_IMPORTED_MODULE_9__["elementPrefix"], "-swiper-item")));
      this._items = swiperItems.filter(function (i) {
        return _this3._isThatMyItem(i);
      });

      this._items.forEach(function (t) {
        if (t.itemId && !_this3._itemIdItemMap[t.itemId]) {
          _this3._itemIdItemMap[t.itemId] = t;
        }
      });
    }
  }, {
    key: "_getItems",
    value: function _getItems() {
      this._itemListDirty && this._updateItemList();
      return this._items;
    }
  }, {
    key: "_getItemByItemId",
    value: function _getItemByItemId(e) {
      this._itemListDirty && this._updateItemList();
      return this._itemIdItemMap[e];
    }
  }, {
    key: "_isThatMyItem",
    value: function _isThatMyItem(target) {
      var _this4 = this;

      var isMe = function isMe(node) {
        if (node.tagName.toUpperCase() === "".concat(_utils_config__WEBPACK_IMPORTED_MODULE_9__["UpperCasePerfix"], "-SWIPER")) {
          if (node === _this4) {
            return true;
          } else {
            return false;
          }
        }

        if (node.parentElement) {
          return isMe(node.parentElement);
        }

        return false;
      };

      return isMe(target.parentElement);
    }
  }, {
    key: "_scheduleAutoplay",
    value: function _scheduleAutoplay() {
      var e = this;

      this._cancelSchedule();

      if (!this._attached || this._invalid || this._getItems().length <= this.displayMultipleItems) {
        return;
      }

      var t = function t() {
        e._currentChangeSource = 'autoplay';

        if (e._circularEnabled) {
          e.current = e._normalizeCurrentValue(e.current + 1);
        } else {
          e.current = e.current + e.displayMultipleItems < e._getItems().length ? e.current + 1 : 0;
        }

        e._animateViewport(e.current, 'autoplay', e._circularEnabled ? 1 : 0);

        e._scheduleTimeoutObj = setTimeout(t, e.interval);
      };

      this._scheduleTimeoutObj = setTimeout(t, this.interval);
    }
  }, {
    key: "_cancelSchedule",
    value: function _cancelSchedule() {
      if (this._scheduleTimeoutObj) {
        clearTimeout(this._scheduleTimeoutObj);
        this._scheduleTimeoutObj = null;
      }
    }
  }, {
    key: "_updateDots",
    value: function _updateDots(current) {
      var valid = !this._invalid;
      var $slidesDots = this.$.slidesDots;
      $slidesDots.innerHTML = '';

      var items = this._getItems();

      for (var i = 0, l = items.length; i < l; i += 1) {
        var node = document.createElement('div');
        var MIN_INDICATOR_SIZE = 4;
        var size = this.indicatorSize > 0 ? this.indicatorSize : MIN_INDICATOR_SIZE;
        node.setAttribute('data-dot-index', i);
        node.style.width = "".concat(size, "px");
        node.style.height = "".concat(size, "px");
        node.style.marginRight = "".concat(size, "px");
        $slidesDots.appendChild(node);

        if (valid && i >= current && i < current + this.displayMultipleItems || i < current + this.displayMultipleItems - l) {
          node.setAttribute('class', 'swiper-dot swiper-dot-active');

          if (this.indicatorActiveColor) {
            node.style.backgroundColor = this.indicatorActiveColor;
          }
        } else {
          node.setAttribute('class', 'swiper-dot');

          if (this.indicatorColor) {
            node.style.backgroundColor = this.indicatorColor;
          }
        }
      }
    }
  }, {
    key: "_updateDotsColor",
    value: function _updateDotsColor() {
      for (var e = this.$.slidesDots, t = 0; t < e.childNodes.length; t += 1) {
        var n = e.childNodes[t];

        if (n.getAttribute('class').indexOf('swiper-dot-active') >= 0) {
          if (this.indicatorActiveColor) {
            n.style.backgroundColor = this.indicatorActiveColor;
          }
        } else if (this.indicatorColor) {
          n.style.backgroundColor = this.indicatorColor;
        }
      }
    }
  }, {
    key: "_normalizeCurrentValue",
    value: function _normalizeCurrentValue(e) {
      var t = this._getItems().length;

      if (!t) {
        return -1;
      }

      var n = (Math.round(e) % t + t) % t;

      if (this._circularEnabled) {
        if (t <= this.displayMultipleItems) {
          return 0;
        }
      } else if (n > t - this.displayMultipleItems) {
        return t - this.displayMultipleItems;
      }

      return n;
    }
  }, {
    key: "_isCurrentValueLegal",
    value: function _isCurrentValueLegal(e) {
      return !!this._getItems().length && e === this._normalizeCurrentValue(e);
    }
  }, {
    key: "_transformPropRpx",
    value: function _transformPropRpx(e) {
      if (/^\s*[+-]?\d+(\.\d+)?(px)?\s*$/i.test(e)) {
        return e.slice(-2) !== 'px' ? "".concat(e, "px") : e;
      } else if (/^\s*[+-]?\d+(\.\d+)?rpx\s*$/i.test(e)) {
        return tt.transformRpx(e);
      } else {
        return '';
      }
    }
  }, {
    key: "_getPositionFromCurrent",
    value: function _getPositionFromCurrent() {
      if (this.currentItemId) {
        return this._getItems().indexOf(this._getItemByItemId(this.currentItemId));
      }

      if (this._isCurrentValueLegal(this.current)) {
        return this.current;
      }

      return -2;
    }
  }, {
    key: "_updateHiddenItemDisplay",
    value: function _updateHiddenItemDisplay(e) {
      if (this._skipHiddenItemLayoutModified) {
        for (var t = this._getItems(), n = 0; n < t.length; n++) {
          var i = t[n];
          var r = i._position <= e - 2 || i._position >= e + this.displayMultipleItems + 1;
          i.style.display = r ? 'none' : i._originalDisplay;
        }
      }
    }
  }, {
    key: "_getElementSize",
    value: function _getElementSize(el) {
      return {
        width: this._getElementWidth(el),
        height: this._getElementHeight(el)
      };
    }
  }, {
    key: "_getElementWidth",
    value: function _getElementWidth(el) {
      return this._getElementSizeApi(el, 'width', 375);
    }
  }, {
    key: "_getElementHeight",
    value: function _getElementHeight(el) {
      return this._getElementSizeApi(el, 'height', 150);
    }
  }, {
    key: "_getElementSizeApi",
    value: function _getElementSizeApi(el, attrName, defaultValue) {
      var DEFAULT = defaultValue;
      var lowerAttrName = attrName.toLowerCase();
      var upperAttrName = lowerAttrName.replace(/[wh]/, function (match) {
        return match.toUpperCase();
      });

      if (el) {
        // e.g. offsetWidth或offsetHeight
        var attrValue = el["offset".concat(upperAttrName)]; // 通常执行路径

        if (attrValue > 0) {
          return attrValue;
        } // 元素初始为display:none时的执行路径
        // 尝试获取swiper元素的宽度或高度


        if (window.getComputedStyle) {
          var size = window.getComputedStyle(this)[lowerAttrName];
          size = parseFloat(size);
          return Number.isNaN(size) ? DEFAULT : size;
        }
      }

      return DEFAULT;
    }
  }, {
    key: "_resetLayout",
    value: function _resetLayout() {
      if (this._attached) {
        this._cancelSchedule();

        this._endViewportAnimation();

        var items = this._getItems();

        if (this.currentItemId) {
          this.current = this._getPositionFromCurrent();

          if (this._currentChangeSource === '__none__') {
            this._currentChangeSource = '';
          }
        }

        var $slides = this.$.slides;
        var $slideFrame = this.$.slideFrame;

        if (this.vertical) {
          if (this._marginSpecified) {
            $slides.style.left = 0;
            $slides.style.right = 0;
            $slides.style.top = this._transformPropRpx(this.previousMargin);
            $slides.style.bottom = this._transformPropRpx(this.nextMargin);
          }

          $slideFrame.style.width = '100%';
          $slideFrame.style.height = "".concat(Math.abs(100 / this.displayMultipleItems), "%");
        } else {
          if (this._marginSpecified) {
            $slides.style.top = 0;
            $slides.style.bottom = 0;
            $slides.style.left = this._transformPropRpx(this.previousMargin);
            $slides.style.right = this._transformPropRpx(this.nextMargin);
          }

          $slideFrame.style.height = '100%';
          $slideFrame.style.width = "".concat(Math.abs(100 / this.displayMultipleItems), "%");
        } // cache size for transition calculation


        var size = this._getElementSize($slideFrame);

        this._slidesFrameSizeX = size.width;
        this._slidesFrameSizeY = size.height;
        this._itemPos = [];

        for (var i = 0; i < items.length; i++) {
          if (this._skipHiddenItemLayoutModified) {
            items[i].style.display = items[i]._originalDisplay;
          }

          this._updateItemPos(i, i);
        }

        this._viewportMoveRatio = 1;

        if (this.displayMultipleItems === 1 && items.length) {
          var itemWidth = this._getElementWidth(items[0]);

          var slideFrameWidth = this._getElementWidth(this.$.slideFrame);

          this._viewportMoveRatio = itemWidth / slideFrameWidth;

          if (this._viewportMoveRatio > 1) {
            this._viewportMoveRatio = 1;
          }
        }

        this._circularEnabled = this.circular && items.length > this.displayMultipleItems;
        var a = this._viewportPosition;
        this._viewportPosition = -2;

        var s = this._getPositionFromCurrent();

        if (s >= 0) {
          this._invalid = false;

          if (this._userTracking) {
            this._updateViewport(a + s - this._contentTrackViewport);

            this._contentTrackViewport = s;
          } else {
            this._updateViewport(s);
          }

          this.autoplay && this._scheduleAutoplay();
        } else {
          this._invalid = true;

          this._updateViewport(-this.displayMultipleItems - 1);
        }

        this._updateDots(s);
      }
    }
  }, {
    key: "_checkCircularLayout",
    value: function _checkCircularLayout(e) {
      if (!this._invalid) {
        var t = this._getItems();

        var n = t.length;
        var i = e + this.displayMultipleItems;

        for (var r = 0; r < n; r++) {
          var o = t[r];
          var a = o._position;
          var s = Math.floor(e / n) * n + r;
          var l = s + n;
          var c = s - n;
          var u = Math.max(e - (s + 1), s - i, 0);
          var d = Math.max(e - (l + 1), l - i, 0);
          var h = Math.max(e - (c + 1), c - i, 0);
          var p = Math.min(u, d, h);
          var f = [s, l, c][[u, d, h].indexOf(p)];
          a !== f && this._updateItemPos(r, f);
        }
      }
    }
  }, {
    key: "_updateItemPos",
    value: function _updateItemPos(e, t) {
      // 计算各元素的位置偏移
      var x = this.vertical ? '0' : "".concat(100 * t, "%");
      var y = this.vertical ? "".concat(100 * t, "%") : '0';
      var transfrom = "translate(".concat(x, ", ").concat(y, ") translateZ(0)");

      var item = this._getItems()[e];

      item.style['-webkit-transform'] = transfrom;
      item.style.transform = transfrom;
      item.style.position = 'absolute';
      item.style.width = '100%';
      item.style.height = '100%';
      item._position = t;
    }
  }, {
    key: "_updateViewport",
    value: function _updateViewport(e) {
      if (Math.floor(2 * this._viewportPosition) !== Math.floor(2 * e) || Math.ceil(2 * this._viewportPosition) === Math.ceil(2 * e)) {
        this._circularEnabled && this._checkCircularLayout(e);
        this.skipHiddenItemLayout && this._updateHiddenItemDisplay(e);
      }

      var t = this.vertical ? '0' : "".concat(100 * -e * this._viewportMoveRatio, "%");
      var n = this.vertical ? "".concat(100 * -e * this._viewportMoveRatio, "%") : '0';
      var i = "translate(".concat(t, ", ").concat(n, ") translateZ(0)");
      this.$.slideFrame.style['-webkit-transform'] = i;
      this.$.slideFrame.style.transform = i;
      this._viewportPosition = e;
    }
  }, {
    key: "_animateFrameFuncProto",
    value: function _animateFrameFuncProto() {
      if (!this._animating) {
        this._requestedAnimation = false;
        return;
      }

      var animating = this._animating; // let toPos = animating.toPos;
      // let acc = animating.acc;
      // let endTime = animating.endTime;
      // let source = animating.source;

      var toPos = animating.toPos;
      var acc = animating.acc;
      var endTime = animating.endTime;
      var source = animating.source;
      var transitionStart = animating.transitionStart;
      var o = endTime - Date.now();

      if (o <= 0) {
        this._updateViewport(toPos);

        this._animating = null;
        this._requestedAnimation = false;

        var a = this._getItems()[this.current];

        a && this.triggerEvent('animationfinish', {
          current: this.current,
          currentItemId: a.itemId,
          source: source
        });
        return;
      }

      var s = acc * o * o / 2;
      var l = toPos + s; // transition calculation

      var dx = 0;
      var dy = 0;

      if (this.vertical) {
        dy = ~~((l - transitionStart) * this._slidesFrameSizeY);
      } else {
        dx = ~~((l - transitionStart) * this._slidesFrameSizeX);
      }

      this.dispatchEvent(new CustomEvent('transition', {
        detail: {
          dx: dx,
          dy: dy
        },
        bubbles: true,
        composed: true
      }));

      this._updateViewport(l);

      window.requestAnimationFrame(this._animateFrameFunc);
    }
    /**
     *
     * @param {number} targetIndex 动画将要移动到的swiper-item的下标
     * @param {string} source 触发动画的原因
     * @param {number} n 枚举值
     */

  }, {
    key: "_animateViewport",
    value: function _animateViewport(targetIndex, source, n) {
      this._cancelViewportAnimation();

      var duration = this.duration;

      var itemsNum = this._getItems().length;

      var vp = this._viewportPosition;

      if (n < 0) {
        while (vp < targetIndex) {
          vp += itemsNum;
        }

        while (vp - itemsNum > targetIndex) {
          vp -= itemsNum;
        }
      } else if (n > 0) {
        while (vp > targetIndex) {
          vp -= itemsNum;
        }

        while (vp + itemsNum < targetIndex) {
          vp += itemsNum;
        }
      } else {
        while (vp + itemsNum < targetIndex) {
          vp += itemsNum;
        }

        while (vp - itemsNum > targetIndex) {
          vp -= itemsNum;
        }

        if (vp + itemsNum - targetIndex < targetIndex - vp && this.circular) {
          vp += itemsNum;
        }
      }

      this._animating = {
        toPos: targetIndex,
        acc: 2 * (vp - targetIndex) / (duration * duration),
        endTime: Date.now() + duration,
        source: source,
        transitionStart: source === 'touch' ? this._contentTrackViewport : this._viewportPosition
      };

      if (!this._requestedAnimation) {
        this._requestedAnimation = true;
        window.requestAnimationFrame(this._animateFrameFunc);
      }
    }
  }, {
    key: "_cancelViewportAnimation",
    value: function _cancelViewportAnimation() {
      this._animating = null;
    }
  }, {
    key: "_endViewportAnimation",
    value: function _endViewportAnimation() {
      if (this._animating) {
        this._updateViewport(this._animating.toPos);

        this._animating = null;
      }
    }
  }, {
    key: "_handleTrackStart",
    value: function _handleTrackStart(e) {
      this._inDangerArea = e.x <= 13; // ios设备在屏幕左侧该区域右滑会触发webview返回

      this._cancelSchedule();

      this._contentTrackViewport = this._viewportPosition;
      this._contentTrackSpeed = 0;
      this._contentTrackT = Date.now();

      this._cancelViewportAnimation();
    }
  }, {
    key: "_handleTrackMove",
    value: function _handleTrackMove(e) {
      var _this5 = this;

      var lastT = this._contentTrackT;
      this._contentTrackT = Date.now();
      var ellapsedT = this._contentTrackT - lastT;

      if (this._frozen) {
        return;
      }

      if (e.x < 0 || e.y < 0) {
        this._frozen = true;
        return;
      }

      if (e.x <= 55 && e.ddx > 0 && this._inDangerArea) {
        this._frozen = true;
        return;
      }

      if (ellapsedT === 0) {
        return;
      }

      var i = this._getItems().length;

      var r = i - this.displayMultipleItems;

      var o = function o(e) {
        return 0.5 - 0.25 / (e + 0.5);
      };

      var a = function a(e, n) {
        var i = _this5._contentTrackViewport + e;
        _this5._contentTrackSpeed = 0.6 * _this5._contentTrackSpeed + 0.4 * n;

        if (!_this5._circularEnabled && (i < 0 || i > r)) {
          if (i < 0) {
            i = -o(-i);
          } else if (i > r) {
            i = r + o(i - r);
          }

          _this5._contentTrackSpeed = 0;
        }

        _this5._updateViewport(i);
      }; // transition event


      var dx = e.dx,
          dy = e.dy;

      if (this.vertical) {
        dx = 0;
        a(-e.dy / this._slidesFrameSizeY, -e.ddy / ellapsedT);
      } else {
        dy = 0;
        a(-e.dx / this._slidesFrameSizeX, -e.ddx / ellapsedT);
      }

      this.dispatchEvent(new CustomEvent('transition', {
        detail: {
          dx: -dx,
          dy: -dy
        },
        bubbles: true,
        composed: true
      }));
    }
  }, {
    key: "_handleTrackEnd",
    value: function _handleTrackEnd(e) {
      this.autoplay && this._scheduleAutoplay();
      this._userTracking = false;
      this._frozen = false;
      var t = this._contentTrackSpeed / Math.abs(this._contentTrackSpeed);
      var n = 0;

      if (!e && Math.abs(this._contentTrackSpeed) > 0.2) {
        n = 0.5 * t;
      }

      var i = this._normalizeCurrentValue(this._viewportPosition + n);

      if (e) {
        this._updateViewport(this._contentTrackViewport);
      } else if (this.current !== i) {
        // 判断滑动的方向
        // 变量t不可靠，因为它表示手指的移动方向，而手指移动方向并不总是决定swiper滑动的方向
        var direction = this.current < this._viewportPosition ? 1 : -1;
        this._currentChangeSource = 'touch';
        this.current = i; // 修复：
        // swiper循环播放开启并且当前视口中是最后一个Item的情况下，用手缓慢将第一个item滑到视口中，并占视口面积一半以上，再松手时，
        // swiper疯狂向右滑（->）经过中间全部的item，到达第一个item的问题
        // 预期应该是向左滑动（<-）一些，停在第一个item上

        this._circularEnabled && (n = direction);

        this._animateViewport(i, 'touch', n);
      } else {
        this._animateViewport(i, 'touch', n);
      }
    }
  }, {
    key: "_handleContentTrack",
    value: function _handleContentTrack(e) {
      if (!this._invalid) {
        if (e.detail.state === 'start') {
          this._userTracking = true;
          this._userDirectionChecked = false;
          return this._handleTrackStart(e.detail);
        }

        if (e.detail.state === 'end') {
          return this._handleTrackEnd(false);
        }

        if (e.detail.state === 'cancel') {
          return this._handleTrackEnd(true);
        }

        if (this._userTracking) {
          if (!this._userDirectionChecked) {
            this._userDirectionChecked = true;
            var t = Math.abs(e.detail.dx);
            var n = Math.abs(e.detail.dy);

            if (t >= n && this.vertical) {
              this._userTracking = false;
            } else if (t <= n && !this.vertical) {
              this._userTracking = false;
            }

            if (!this._userTracking) {
              this.autoplay && this._scheduleAutoplay();
              return;
            }
          } // touchmove事件不冒泡，与微信对齐


          e.stopPropagation();
          this.dispatchEvent(new CustomEvent('touchmove', {
            detail: {
              srcMoveEvent: e
            },
            bubbles: true,
            composed: true
          })); // 避免页面滑动

          e.preventDefault();

          this._handleTrackMove(e.detail);

          return false;
        }
      }
    }
  }, {
    key: "getScrollPosition",
    value: function getScrollPosition() {
      return {
        scrollLeft: 0,
        scrollTop: 0
      };
    }
  }, {
    key: "dotsClassIfVertical",
    value: function dotsClassIfVertical(vertical) {
      return vertical ? 'swiper-dots-vertical' : 'swiper-dots-horizontal';
    }
  }, {
    key: "showDots",
    value: function showDots(yes) {
      return yes ? 'block' : 'none';
    }
  }], [{
    key: "is",
    get: function get() {
      return "".concat(_utils_config__WEBPACK_IMPORTED_MODULE_9__["elementPrefix"], "-swiper");
    }
  }, {
    key: "properties",
    get: function get() {
      return {
        indicatorDots: {
          type: Boolean,
          value: false
        },
        vertical: {
          type: Boolean,
          value: false,
          observer: '_updateLayout'
        },
        autoplay: {
          type: Boolean,
          value: false,
          observer: '_autoplayChanged'
        },
        circular: {
          type: Boolean,
          value: false,
          observer: '_updateLayout'
        },
        interval: {
          type: Number,
          value: 5e3,
          observer: '_autoplayChanged'
        },
        duration: {
          type: Number,
          value: 500
        },
        current: {
          type: Number,
          value: 0,
          observer: '_currentChanged'
        },
        indicatorSize: {
          type: Number,
          value: 8
        },
        indicatorColor: {
          type: String,
          value: '',
          observer: '_updateDotsColor'
        },
        indicatorActiveColor: {
          type: String,
          value: '',
          observer: '_updateDotsColor'
        },
        previousMargin: {
          type: String,
          value: '',
          observer: '_updateMargin'
        },
        nextMargin: {
          type: String,
          value: '',
          observer: '_updateMargin',
          "public": true
        },
        currentItemId: {
          type: String,
          value: '',
          observer: '_currentItemIdChanged'
        },
        skipHiddenItemLayout: {
          type: Boolean,
          value: false,
          observer: '_skipHiddenItemLayoutChanged'
        },
        displayMultipleItems: {
          type: Number,
          value: 1,
          observer: '_displayMultiItemsChanged'
        },
        touchable: {
          type: Boolean,
          value: true
        }
      };
    }
  }, {
    key: "template",
    get: function get() {
      return Object(_polymer_polymer__WEBPACK_IMPORTED_MODULE_8__["html"])(_templateObject || (_templateObject = _babel_runtime_helpers_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0___default()(["\n      <style include=\"swiper-style\"></style>\n      <div id=\"slidesWrapper\" class=\"swiper-wrapper\">\n        <div id=\"slides\" class=\"swiper-slides\">\n          <div id=\"slideFrame\" class=\"swiper-slide-frame\">\n            <slot></slot>\n          </div>\n        </div>\n\n        <div\n          id=\"slidesDots\"\n          style$=\"display: [[showDots(indicatorDots)]]\"\n          class$=\"swiper-dots [[dotsClassIfVertical(vertical)]]\"\n        ></div>\n      </div>\n    "])));
    }
  }]);

  return Swiper;
}(Object(_mixins__WEBPACK_IMPORTED_MODULE_10__["TouchTrack"])(Object(_mixins__WEBPACK_IMPORTED_MODULE_10__["Base"])(_polymer_polymer__WEBPACK_IMPORTED_MODULE_8__["PolymerElement"])));

window.customElements.define(Swiper.is, Swiper);

/***/ }),

/***/ "./src/web-components/switch.js":
/*!**************************************!*\
  !*** ./src/web-components/switch.js ***!
  \**************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _babel_runtime_helpers_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/taggedTemplateLiteral */ "./node_modules/@babel/runtime/helpers/taggedTemplateLiteral.js");
/* harmony import */ var _babel_runtime_helpers_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _polymer_polymer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @polymer/polymer */ "./node_modules/@polymer/polymer/polymer-element.js");
/* harmony import */ var _utils_config__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @/utils/config */ "./src/utils/config.js");
/* harmony import */ var _mixins__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./mixins */ "./src/web-components/mixins/index.js");







var _templateObject;

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5___default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5___default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4___default()(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }




var documentContainer = document.createElement('div');
documentContainer.setAttribute('style', 'display: none;');
documentContainer.innerHTML = "\n  <dom-module id=\"switch-style\">\n    <template>\n      <style>\n        :host {\n          -webkit-tap-highlight-color: transparent;\n          display: inline-block;\n        }\n\n        :host([ hidden ]) {\n          display: none;\n        }\n\n        :host .switch-wrapper {\n          display: -webkit-inline-flex;\n          display: inline-flex;\n          -webkit-align-items: center;\n                  align-items: center;\n          vertical-align: middle;\n        }\n        :host .switch-input {\n          -webkit-appearance: none;\n                  appearance: none;\n          position: relative;\n          width: 52px;\n          height: 32px;\n          margin-right: 5px;\n          border: 1px solid #DFDFDF;\n          outline: 0;\n          border-radius: 16px;\n          box-sizing: border-box;\n          background-color: #DFDFDF;\n          transition: background-color 0.1s, border 0.1s;\n        }\n        :host .switch-input .before {\n          content: \" \";\n          position: absolute;\n          top: 0;\n          left: 0;\n          width: 50px;\n          height: 30px;\n          border-radius: 15px;\n          background-color: #FDFDFD;\n          transition: -webkit-transform .3s;\n          transition: transform .3s;\n          transition: transform .3s, -webkit-transform .3s;\n        }\n        :host .switch-input:after {\n          content: \" \";\n          position: absolute;\n          top: 0;\n          left: 0;\n          width: 30px;\n          height: 30px;\n          border-radius: 15px;\n          background-color: #FFFFFF;\n          box-shadow: 0 1px 3px rgba(0, 0, 0, 0.4);\n          transition: -webkit-transform .3s;\n          transition: transform .3s;\n          transition: transform .3s, -webkit-transform .3s;\n        }\n        :host .switch-input.switch-input-checked {\n          border-color: #F85959;\n          background-color: #F85959;\n        }\n        :host .switch-input.switch-input-checked .before {\n          -webkit-transform: scale(0);\n                  transform: scale(0);\n        }\n        :host .switch-input.switch-input-checked:after {\n          -webkit-transform: translateX(20px);\n                  transform: translateX(20px);\n        }\n        :host .checkbox-input {\n          margin-right: 5px;\n          -webkit-appearance: none;\n                  appearance: none;\n          outline: 0;\n          border: 1px solid #D1D1D1;\n          background-color: #FFFFFF;\n          border-radius: 3px;\n          width: 22px;\n          height: 22px;\n          position: relative;\n          color: #09BB07;\n        }\n        :host .checkbox-input.checkbox-input-checked:before {\n          font: normal normal normal 14px/1 \"mpui\";\n          content: \"e601\";\n          color: inherit;\n          font-size: 28px;\n          position: absolute;\n          top: 50%;\n          left: 50%;\n          transform: translate(-50%, -48%) scale(0.73);\n          -webkit-transform: translate(-50%, -48%) scale(0.73);\n        }\n        :host .checkbox-input.checkbox-input-disabled {\n          background-color: #E1E1E1;\n        }\n        :host .checkbox-input.checkbox-input-disabled:before {\n          color: #ADADAD;\n        }\n      </style>\n    </template>\n  </dom-module>\n";
document.head.appendChild(documentContainer);

var Switch = /*#__PURE__*/function (_Data) {
  _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3___default()(Switch, _Data);

  var _super = _createSuper(Switch);

  function Switch() {
    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, Switch);

    return _super.apply(this, arguments);
  }

  _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(Switch, [{
    key: "listeners",
    get: function get() {
      return {
        tap: 'onInputChange'
      };
    }
  }, {
    key: "_isSwitch",
    value: function _isSwitch(e) {
      return e !== 'checkbox';
    }
  }, {
    key: "_getSwitchBorderColor",
    value: function _getSwitchBorderColor(e, t) {
      return e ? t : '';
    }
  }, {
    key: "handleLabelTap",
    value: function handleLabelTap() {
      this.onInputChange();
    }
  }, {
    key: "onInputChange",
    value: function onInputChange() {
      if (this.disabled) {
        return;
      }

      this.checked = !this.checked;
      this.triggerEvent('change', {
        value: this.checked
      });
    }
  }, {
    key: "getFormData",
    value: function getFormData(callback) {
      callback(this.checked);
    }
  }, {
    key: "resetFormData",
    value: function resetFormData() {
      this.checked = false;
    }
  }, {
    key: "checkedClsSwitch",
    value: function checkedClsSwitch(checked) {
      if (!this.isSwitch) {
        return '';
      }

      return checked ? 'switch-input-checked' : '';
    }
  }, {
    key: "disabledClsSwitch",
    value: function disabledClsSwitch(disabled) {
      if (!this.isSwitch) {
        return '';
      }

      return disabled ? 'switch-input-disabled' : '';
    }
  }, {
    key: "checkedClsBox",
    value: function checkedClsBox(checked) {
      if (this.isSwitch) {
        return '';
      }

      return checked ? 'checkbox-input-checked' : '';
    }
  }, {
    key: "disabledClsBox",
    value: function disabledClsBox(disabled) {
      if (this.isSwitch) {
        return '';
      }

      return disabled ? 'checkbox-input-disabled' : '';
    }
  }], [{
    key: "is",
    get: function get() {
      return "".concat(_utils_config__WEBPACK_IMPORTED_MODULE_7__["elementPrefix"], "-switch");
    }
  }, {
    key: "properties",
    get: function get() {
      return {
        checked: {
          type: Boolean,
          value: false
        },
        type: {
          type: String,
          value: 'switch'
        },
        color: {
          type: String,
          value: '#F85959'
        },
        checkedColor: {
          type: String,
          computed: '_getSwitchBorderColor(checked, color)'
        },
        isSwitch: {
          type: String,
          computed: '_isSwitch(type)'
        }
      };
    }
  }, {
    key: "template",
    get: function get() {
      return Object(_polymer_polymer__WEBPACK_IMPORTED_MODULE_6__["html"])(_templateObject || (_templateObject = _babel_runtime_helpers_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0___default()(["\n      <style include=\"switch-style\">\n      </style>\n      <div class=\"switch-wrapper\">\n        <template is=\"dom-if\" if=\"[[isSwitch]]\">\n          <div id=\"switchInput\"\n            class$=\"switch-input [[checkedClsSwitch(checked)]] [[disabledClsSwitch(disabled)]]\"\n            style$=\"background-color: [[color]]; border-color: [[checkedColor]]\"><i class=\"before\"/></div>\n          <slot></slot>\n        </template>\n        <template is=\"dom-if\" if=\"[[!isSwitch]]\">\n          <div id=\"checkboxInput\" class$=\"checkbox-input [[checkedClsBox(checked)]] [[disabledClsBox(disabled)]]\" style$=\"color: [[color]]\"></div>\n          <slot></slot>\n        </template>\n      </div>\n    "])));
    }
  }]);

  return Switch;
}(Object(_mixins__WEBPACK_IMPORTED_MODULE_8__["Data"])(Object(_mixins__WEBPACK_IMPORTED_MODULE_8__["Disabled"])(Object(_mixins__WEBPACK_IMPORTED_MODULE_8__["LabelTarget"])(Object(_mixins__WEBPACK_IMPORTED_MODULE_8__["Base"])(_polymer_polymer__WEBPACK_IMPORTED_MODULE_6__["PolymerElement"])))));

window.customElements.define(Switch.is, Switch);

/***/ }),

/***/ "./src/web-components/text.js":
/*!************************************!*\
  !*** ./src/web-components/text.js ***!
  \************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _babel_runtime_helpers_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/taggedTemplateLiteral */ "./node_modules/@babel/runtime/helpers/taggedTemplateLiteral.js");
/* harmony import */ var _babel_runtime_helpers_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/get */ "./node_modules/@babel/runtime/helpers/get.js");
/* harmony import */ var _babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _polymer_polymer__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @polymer/polymer */ "./node_modules/@polymer/polymer/polymer-element.js");
/* harmony import */ var _utils_config__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @/utils/config */ "./src/utils/config.js");
/* harmony import */ var _mixins__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./mixins */ "./src/web-components/mixins/index.js");








var _templateObject;

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_6___default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_6___default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_5___default()(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }





var Text = /*#__PURE__*/function (_Base) {
  _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_4___default()(Text, _Base);

  var _super = _createSuper(Text);

  function Text() {
    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, Text);

    return _super.apply(this, arguments);
  }

  _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(Text, [{
    key: "connectedCallback",
    value: function connectedCallback() {
      _babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_3___default()(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_6___default()(Text.prototype), "connectedCallback", this).call(this);

      this._update();

      this._observer = new MutationObserver(this._update.bind(this));

      this._observer.observe(this, {
        childList: true,
        subtree: true,
        characterData: true // 必须

      });
    }
  }, {
    key: "disconnectedCallback",
    value: function disconnectedCallback() {
      _babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_3___default()(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_6___default()(Text.prototype), "disconnectedCallback", this).call(this);

      this._observer && this._observer.disconnect();
    }
  }, {
    key: "_styleChanged",
    value: function _styleChanged(styles) {
      this.setAttribute('style', styles);
    }
  }, {
    key: "_classChanged",
    value: function _classChanged(cls) {
      this.setAttribute('class', cls);
    }
  }, {
    key: "_decode",
    value: function _decode(txt) {
      this.space && (this.space === 'nbsp' ? txt = txt.replace(/ /g, ' ') : this.space === 'ensp' ? txt = txt.replace(/ /g, ' ') : this.space === 'emsp' && (txt = txt.replace(/ /g, ' ')));
      return this.decode ? txt.replace(/&nbsp;/g, ' ').replace(/&ensp;/g, ' ').replace(/&emsp;/g, ' ').replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&quot;/g, '"').replace(/&apos;/g, "'").replace(/&amp;/g, '&') : txt;
    }
  }, {
    key: "_update",
    value: function _update() {
      var _this = this;

      var textNode = document.createDocumentFragment();
      Array.from(this.childNodes).forEach(function (shadowNode) {
        if (shadowNode.nodeType === shadowNode.TEXT_NODE) {
          var lines = _this._decode(shadowNode.textContent).split('\n');

          for (var i = 0; i < lines.length; i += 1) {
            i && textNode.appendChild(document.createElement('br'));
            textNode.appendChild(document.createTextNode(lines[i]));
          }
        } else if (shadowNode.nodeType === 1 && shadowNode.tagName === "".concat(_utils_config__WEBPACK_IMPORTED_MODULE_8__["UpperCasePerfix"], "-TEXT")) {
          var cloneNode = Node.prototype.cloneNode || Element.prototype.cloneNode;

          var _clone = function _clone(root) {
            var outer = cloneNode.call(root);
            outer.$$data = root.$$data;
            Array.from(root.childNodes).forEach(function (child) {
              if (child.nodeType === 1 && child.tagName === "".concat(_utils_config__WEBPACK_IMPORTED_MODULE_8__["UpperCasePerfix"], "-TEXT")) {
                outer.appendChild(_clone(child));
              } else {
                outer.appendChild(child.cloneNode());
              }
            });
            return outer;
          };

          textNode.appendChild(_clone(shadowNode));
        }
      });
      this.$.main.innerHTML = '';
      this.$.main.appendChild(textNode);
    }
  }], [{
    key: "is",
    get: function get() {
      return "".concat(_utils_config__WEBPACK_IMPORTED_MODULE_8__["elementPrefix"], "-text");
    }
  }, {
    key: "properties",
    get: function get() {
      return {
        style: {
          type: String,
          observer: '_styleChanged'
        },
        "class": {
          type: String,
          observer: '_classChanged'
        },
        selectable: {
          type: Boolean,
          value: false
        },
        decode: {
          type: Boolean,
          value: false
        },
        space: {
          type: String,
          value: ''
        }
      };
    }
  }, {
    key: "template",
    get: function get() {
      return Object(_polymer_polymer__WEBPACK_IMPORTED_MODULE_7__["html"])(_templateObject || (_templateObject = _babel_runtime_helpers_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0___default()(["\n      <slot id=\"slot\" style=\"display: none;\"></slot>\n      <span id=\"main\"></span>\n    "])));
    }
  }]);

  return Text;
}(Object(_mixins__WEBPACK_IMPORTED_MODULE_9__["Base"])(_polymer_polymer__WEBPACK_IMPORTED_MODULE_7__["PolymerElement"]));

window.customElements.define(Text.is, Text);

/***/ }),

/***/ "./src/web-components/utils/bezier.js":
/*!********************************************!*\
  !*** ./src/web-components/utils/bezier.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return bezier; });
var kSplineTableSize = 11;
var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);

function A(aA1, aA2) {
  return 1.0 - 3.0 * aA2 + 3.0 * aA1;
}

function B(aA1, aA2) {
  return 3.0 * aA2 - 6.0 * aA1;
}

function C(aA1) {
  return 3.0 * aA1;
}

function calcBezier(aT, aA1, aA2) {
  return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;
}

function getSlope(aT, aA1, aA2) {
  return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);
}

function binarySubdivide(aX, aA, aB, mX1, mX2) {
  var currentX;
  var currentT;
  var i = 0;

  do {
    currentT = aA + (aB - aA) / 2.0;
    currentX = calcBezier(currentT, mX1, mX2) - aX;

    if (currentX > 0.0) {
      aB = currentT;
    } else {
      aA = currentT;
    }
  } while (Math.abs(currentX) > 0.0000001 && ++i < 10);

  return currentT;
}

function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {
  for (var i = 0; i < 4; ++i) {
    var currentSlope = getSlope(aGuessT, mX1, mX2);

    if (currentSlope === 0.0) {
      return aGuessT;
    }

    var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
    aGuessT -= currentX / currentSlope;
  }

  return aGuessT;
}

function bezier(mX1, mY1, mX2, mY2) {
  if (!(mX1 >= 0 && mX1 <= 1 && mX2 >= 0 && mX2 <= 1)) {
    return;
  }

  var sampleValues = new Float32Array(kSplineTableSize);

  if (mX1 !== mY1 || mX2 !== mY2) {
    for (var i = 0; i < kSplineTableSize; ++i) {
      sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
    }
  }

  function getTForX(aX) {
    var intervalStart = 0.0;
    var currentSample = 1;
    var lastSample = kSplineTableSize - 1;

    for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {
      intervalStart += kSampleStepSize;
    }

    --currentSample;
    var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
    var guessForT = intervalStart + dist * kSampleStepSize;
    var initialSlope = getSlope(guessForT, mX1, mX2);

    if (initialSlope >= 0.001) {
      return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
    } else if (initialSlope === 0.0) {
      return guessForT;
    } else {
      return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
    }
  }

  return function (x) {
    if (mX1 === mY1 && mX2 === mY2) {
      return x;
    }

    if (x === 0) {
      return 0;
    }

    if (x === 1) {
      return 1;
    }

    return calcBezier(getTForX(x), mY1, mY2);
  };
}

/***/ }),

/***/ "./src/web-components/utils/scrollUtil.js":
/*!************************************************!*\
  !*** ./src/web-components/utils/scrollUtil.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utils_debounce__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/debounce */ "./src/utils/debounce.js");
/* harmony import */ var _utils_config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/utils/config */ "./src/utils/config.js");


var registeredImages = {};
var uid = 0;

var i = function i() {
  for (var id in registeredImages) {
    var n = registeredImages[id];
    hasScrollViewParent(n) && isNodeVisible(n) && n._showImage(n._changeId);
  }
};

var checkUnloadedImages = Object(_utils_debounce__WEBPACK_IMPORTED_MODULE_0__["default"])(function () {
  for (var id in registeredImages) {
    var n = registeredImages[id];
    isNodeVisible(n) && n._showImage(n._changeId);
  }
}, 200);
document.addEventListener("".concat(_utils_config__WEBPACK_IMPORTED_MODULE_1__["elementPrefix"], "-scroll-view"), Object(_utils_debounce__WEBPACK_IMPORTED_MODULE_0__["default"])(i, 200));
document.addEventListener('h5-scroll', checkUnloadedImages);
document.addEventListener('scroll', checkUnloadedImages);

var hasScrollViewParent = function hasScrollViewParent(t) {
  var n = t.parentNode;

  if (!n) {
    return false;
  }

  if (n.tagName === "".concat(_utils_config__WEBPACK_IMPORTED_MODULE_1__["UpperCasePerfix"], "-SCROLL-VIEW")) {
    return true;
  }

  return hasScrollViewParent(n);
};

var l = function l(e, t) {
  return !(e.left > t.right || e.top > t.bottom || t.left > e.right || t.top > e.bottom);
};

var isNodeVisible = function isNodeVisible(e) {
  var t = 2 * document.documentElement.clientWidth;
  var n = 2 * document.documentElement.clientHeight;
  return l(e.getBoundingClientRect(), {
    top: -n,
    right: document.documentElement.clientWidth + t,
    bottom: document.documentElement.clientHeight + n,
    left: -t
  });
};

var scrollUtil = {
  registerInstance: function registerInstance(item) {
    if (!item._imageInstanceId) {
      item._imageInstanceId = uid++;
      var id = item._imageInstanceId;
      e[id] = item;
    }
  },
  deregisterInstance: function deregisterInstance(item) {
    if (item._imageInstanceId) {
      delete e[item._imageInstanceId];
      item._imageInstanceId = undefined;
    }
  },
  hasScrollViewParent: hasScrollViewParent,
  isNodeVisible: isNodeVisible,
  checkUnloadedImages: checkUnloadedImages
};
/* harmony default export */ __webpack_exports__["default"] = (scrollUtil);

/***/ }),

/***/ "./src/web-components/utils/uuid.js":
/*!******************************************!*\
  !*** ./src/web-components/utils/uuid.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return uuid; });
function uuid() {
  var s = [];
  var ts = Date.now().toString(16);
  var hexDigits = '0123456789abcdef';

  for (var i = 0, l = 32 - ts.length; i < l; i += 1) {
    s[i] = hexDigits.substr(Math.floor(Math.random() * 16), 1);
  }

  return ts + s.join('');
}

/***/ }),

/***/ "./src/web-components/view.js":
/*!************************************!*\
  !*** ./src/web-components/view.js ***!
  \************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _babel_runtime_helpers_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/taggedTemplateLiteral */ "./node_modules/@babel/runtime/helpers/taggedTemplateLiteral.js");
/* harmony import */ var _babel_runtime_helpers_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _polymer_polymer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @polymer/polymer */ "./node_modules/@polymer/polymer/polymer-element.js");
/* harmony import */ var _utils_config__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @/utils/config */ "./src/utils/config.js");
/* harmony import */ var _mixins__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./mixins */ "./src/web-components/mixins/index.js");







var _templateObject;

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5___default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5___default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4___default()(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }





var View = /*#__PURE__*/function (_Hover) {
  _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3___default()(View, _Hover);

  var _super = _createSuper(View);

  function View() {
    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, View);

    return _super.apply(this, arguments);
  }

  _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(View, null, [{
    key: "is",
    get: function get() {
      return "".concat(_utils_config__WEBPACK_IMPORTED_MODULE_7__["elementPrefix"], "-view");
    }
  }, {
    key: "template",
    get: function get() {
      return Object(_polymer_polymer__WEBPACK_IMPORTED_MODULE_6__["html"])(_templateObject || (_templateObject = _babel_runtime_helpers_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0___default()(["\n      <style>      \n        :host {\n          display: block;\n          white-space: normal;\n        }\n        #main {\n          /* ios12 special */\n          text-decoration: inherit;      \n        }\n      </style>\n      <slot id=\"main\"></slot>\n    "])));
    }
  }]);

  return View;
}(Object(_mixins__WEBPACK_IMPORTED_MODULE_8__["Hover"])(Object(_mixins__WEBPACK_IMPORTED_MODULE_8__["Base"])(_polymer_polymer__WEBPACK_IMPORTED_MODULE_6__["PolymerElement"])));

window.customElements.define(View.is, View);

/***/ }),

/***/ "./src/xml-runtime/EmptyComponent.js":
/*!*******************************************!*\
  !*** ./src/xml-runtime/EmptyComponent.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return EmptyComponent; });
/* harmony import */ var _nerv__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/nerv */ "./src/nerv/index.ts");

function EmptyComponent(props) {
  var _ref = props || {},
      _ref$children = _ref.children,
      children = _ref$children === void 0 ? null : _ref$children;

  return children;
}

/***/ }),

/***/ "./src/xml-runtime/EmptyComponentFactory.js":
/*!**************************************************!*\
  !*** ./src/xml-runtime/EmptyComponentFactory.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return EmptyComponentFactory; });
var caches = {};
function EmptyComponentFactory(type) {
  if (caches[type]) {
    return caches[type];
  }

  function EmptyComponent(props) {
    var _props$children = props.children,
        children = _props$children === void 0 ? null : _props$children;
    return children;
  }

  EmptyComponent.displayName = type;
  caches[type] = EmptyComponent;
  return EmptyComponent;
}

/***/ }),

/***/ "./src/xml-runtime/createBlock.js":
/*!****************************************!*\
  !*** ./src/xml-runtime/createBlock.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return createBlock; });
/* harmony import */ var _nerv__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/nerv */ "./src/nerv/index.ts");

function createBlock(element, props) {
  var arrayElements = element;

  if (!Array.isArray(arrayElements)) {
    arrayElements = [arrayElements];
  }

  if (_nerv__WEBPACK_IMPORTED_MODULE_0__["Fragment"]) {
    return _nerv__WEBPACK_IMPORTED_MODULE_0__["default"].createElement(_nerv__WEBPACK_IMPORTED_MODULE_0__["Fragment"], props, arrayElements);
  } else {
    return arrayElements;
  }
}

/***/ }),

/***/ "./src/xml-runtime/createRoot.js":
/*!***************************************!*\
  !*** ./src/xml-runtime/createRoot.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return createRoot; });
/* harmony import */ var _nerv__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/nerv */ "./src/nerv/index.ts");

function createRoot(element) {
  if (Array.isArray(element) && _nerv__WEBPACK_IMPORTED_MODULE_0__["Fragment"]) {
    return _nerv__WEBPACK_IMPORTED_MODULE_0__["default"].createElement(_nerv__WEBPACK_IMPORTED_MODULE_0__["Fragment"], null, element);
  }

  return element;
}

/***/ }),

/***/ "./src/xml-runtime/createTemplate.js":
/*!*******************************************!*\
  !*** ./src/xml-runtime/createTemplate.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _babel_runtime_helpers_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/objectWithoutProperties */ "./node_modules/@babel/runtime/helpers/objectWithoutProperties.js");
/* harmony import */ var _babel_runtime_helpers_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _nerv__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/nerv */ "./src/nerv/index.ts");







function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5___default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5___default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4___default()(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }



function transformChildrenToSlots(children) {
  var slots = {};
  _nerv__WEBPACK_IMPORTED_MODULE_6__["default"].Children.forEach(children, function (c) {
    var slot = c && c.props && c.props.slot || '$default';
    var holder = slots[slot] || [];
    holder.push(c);
    slots[slot] = holder;
  });
  return slots;
}

/* harmony default export */ __webpack_exports__["default"] = (function (name, elementFactory) {
  var RMLTemplate = /*#__PURE__*/function (_PureComponent) {
    _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3___default()(RMLTemplate, _PureComponent);

    var _super = _createSuper(RMLTemplate);

    function RMLTemplate() {
      _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, RMLTemplate);

      return _super.apply(this, arguments);
    }

    _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(RMLTemplate, [{
      key: "render",
      value: function render() {
        var _this$props = this.props,
            $context = _this$props.$context,
            slot = _this$props.slot,
            children = _this$props.children,
            props = _babel_runtime_helpers_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_0___default()(_this$props, ["$context", "slot", "children"]);

        props.$slots = transformChildrenToSlots(children);
        var renderChildren = elementFactory.call($context, props);
        return renderChildren;
      }
    }]);

    return RMLTemplate;
  }(_nerv__WEBPACK_IMPORTED_MODULE_6__["PureComponent"]);

  RMLTemplate.displayName = name;
  return RMLTemplate;
});

/***/ }),

/***/ "./src/xml-runtime/getLooseDataMember.js":
/*!***********************************************!*\
  !*** ./src/xml-runtime/getLooseDataMember.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utils_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/types */ "./src/utils/types.js");

var F = Function;
var E = eval;

function danger(ret) {
  if (ret === F || ret === E) {
    return true;
  }

  return false;
}

/* harmony default export */ __webpack_exports__["default"] = (function (fullArgs, isFunction) {
  var args = fullArgs.slice(1);
  var ret = fullArgs[0];
  var lastArg;

  for (var i = 0; i < args.length; i += 1) {
    if (danger(ret)) {
      return _utils_types__WEBPACK_IMPORTED_MODULE_0__["noop"];
    }
    /* eslint eqeqeq:0 */


    if (ret == null) {
      break;
    }

    lastArg = ret;
    ret = ret[args[i]];
  }

  if (isFunction) {
    if (typeof ret !== 'function' || danger(ret)) {
      return _utils_types__WEBPACK_IMPORTED_MODULE_0__["noop"];
    }

    return ret.bind(lastArg);
  }

  if (danger(ret)) {
    return _utils_types__WEBPACK_IMPORTED_MODULE_0__["noop"];
  }

  return ret;
});

/***/ }),

/***/ "./src/xml-runtime/getSJSMember.js":
/*!*****************************************!*\
  !*** ./src/xml-runtime/getSJSMember.js ***!
  \*****************************************/
/*! exports provided: prefix, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "prefix", function() { return prefix; });
/* harmony import */ var _utils_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/types */ "./src/utils/types.js");

var PREFIX = '$sjs_';
var messageReg = new RegExp(PREFIX, 'g');
var stackReg = new RegExp("\\s".concat(PREFIX), 'g');
var SJS_FUNC = 1;

function startsWithPrefix(str) {
  return str.lastIndexOf(PREFIX, 0) === 0;
}

function is(target, type) {
  return Object.prototype.toString.call(target) === "[object ".concat(type, "]");
}

function prefix(target) {
  var p = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  var r = arguments.length > 2 ? arguments[2] : undefined;

  if (!target) {
    return target;
  }

  var constructor = target.constructor;

  if (is(target, 'String') || is(target, 'Boolean') || is(target, 'Number')) {
    return target;
  }

  if (is(target, 'Object')) {
    var ret = {};

    for (var k in target) {
      if (target.hasOwnProperty(k)) {
        var v = prefix(target[k], p, r);

        if (p) {
          if (!startsWithPrefix(k)) {
            k = PREFIX + k;
          }

          ret[k] = v;
        } else {
          if (startsWithPrefix(k)) {
            k = k.slice(PREFIX.length);
          }

          ret[k] = v;
        }
      }
    }

    return ret;
  } else if (Array.isArray(target)) {
    var _ret = [];

    for (var i = 0; i < target.length; i += 1) {
      _ret.push(prefix(target[i], p, r));
    }

    return _ret;
  } else if (is(target, 'Date')) {
    var _ret2 = new Date();

    _ret2.setTime(target.getTime());

    return _ret2;
  } else if (is(target, 'RegExp')) {
    var f = '';

    if (target.global) {
      f += 'g';
    }

    if (target.ignoreCase) {
      f += 'i';
    }

    if (target.multiline) {
      f += 'm';
    }

    return new RegExp(target.source, f);
  } else if (is(target, 'Function')) {
    if (r === SJS_FUNC) return target;
  }

  return null;
}
/* harmony default export */ __webpack_exports__["default"] = (function (fullArgs, isFunction) {
  var args = fullArgs.slice(1);
  var ret = fullArgs[0];
  var lastArg = void 0;

  for (var i = 0; i < args.length; i++) {
    /* eslint eqeqeq:0 */
    if (ret == null) {
      break;
    }

    lastArg = ret;
    var key = args[i];

    if (typeof key === 'string') {
      key = PREFIX + key;
    }

    ret = ret[key];
  }

  if (isFunction) {
    if (typeof ret !== 'function') {
      return _utils_types__WEBPACK_IMPORTED_MODULE_0__["noop"];
    }

    return function () {
      for (var _len = arguments.length, runArgs = new Array(_len), _key = 0; _key < _len; _key++) {
        runArgs[_key] = arguments[_key];
      }

      runArgs = runArgs.map(function (arg) {
        return prefix(arg);
      });

      try {
        return prefix(ret.apply(lastArg, runArgs), false);
      } catch (e) {
        e.message = e.message.replace(messageReg, '');
        e.stack = e.stack.substring(0, e.stack.indexOf('\n', e.stack.lastIndexOf("at ".concat(PREFIX))));
        e.stack = e.stack.replace(stackReg, ' ');
        throw e;
      }
    };
  }
  /** TIPS: SJS handler 不支持axml中调用函数返回函数的场景
   * 若用户调用了在 sjs 内的一个函数，然后这个函数返回了一个函数。
   * 这个时候这个返回值（函数）不能作为 SJS 事件handler。
   * 虽然类型也是函数，但是会在上面直接判掉
   */


  if (typeof ret === 'function') {
    ret.sjs = true;
    ret.prefix = prefix;
    return ret;
  }

  return prefix(ret, false);
});

/***/ }),

/***/ "./src/xml-runtime/index.js":
/*!**********************************!*\
  !*** ./src/xml-runtime/index.js ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _createBlock__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./createBlock */ "./src/xml-runtime/createBlock.js");
/* harmony import */ var _createRoot__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./createRoot */ "./src/xml-runtime/createRoot.js");
/* harmony import */ var _createTemplate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./createTemplate */ "./src/xml-runtime/createTemplate.js");
/* harmony import */ var _EmptyComponent__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./EmptyComponent */ "./src/xml-runtime/EmptyComponent.js");
/* harmony import */ var _EmptyComponentFactory__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./EmptyComponentFactory */ "./src/xml-runtime/EmptyComponentFactory.js");
/* harmony import */ var _getLooseDataMember__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./getLooseDataMember */ "./src/xml-runtime/getLooseDataMember.js");
/* harmony import */ var _getSJSMember__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./getSJSMember */ "./src/xml-runtime/getSJSMember.js");
/* harmony import */ var _iterate__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./iterate */ "./src/xml-runtime/iterate.js");
/* harmony import */ var _renderSlot__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./renderSlot */ "./src/xml-runtime/renderSlot.js");
/* harmony import */ var _resolveScopedSlots__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./resolveScopedSlots */ "./src/xml-runtime/resolveScopedSlots.js");
/* harmony import */ var _toString__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./toString */ "./src/xml-runtime/toString.js");
/* harmony import */ var _useTemplate__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./useTemplate */ "./src/xml-runtime/useTemplate.js");












/* harmony default export */ __webpack_exports__["default"] = ({
  createBlock: _createBlock__WEBPACK_IMPORTED_MODULE_0__["default"],
  createRoot: _createRoot__WEBPACK_IMPORTED_MODULE_1__["default"],
  createTemplate: _createTemplate__WEBPACK_IMPORTED_MODULE_2__["default"],
  EmptyComponent: _EmptyComponent__WEBPACK_IMPORTED_MODULE_3__["default"],
  EmptyComponentFactory: _EmptyComponentFactory__WEBPACK_IMPORTED_MODULE_4__["default"],
  getLooseDataMember: _getLooseDataMember__WEBPACK_IMPORTED_MODULE_5__["default"],
  getSJSMember: _getSJSMember__WEBPACK_IMPORTED_MODULE_6__["default"],
  iterate: _iterate__WEBPACK_IMPORTED_MODULE_7__["default"],
  renderSlot: _renderSlot__WEBPACK_IMPORTED_MODULE_8__["default"],
  resolveScopedSlots: _resolveScopedSlots__WEBPACK_IMPORTED_MODULE_9__["default"],
  toString: _toString__WEBPACK_IMPORTED_MODULE_10__["default"],
  useTemplate: _useTemplate__WEBPACK_IMPORTED_MODULE_11__["default"]
});

/***/ }),

/***/ "./src/xml-runtime/iterate.js":
/*!************************************!*\
  !*** ./src/xml-runtime/iterate.js ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return iterate; });
/* harmony import */ var _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/typeof */ "./node_modules/@babel/runtime/helpers/typeof.js");
/* harmony import */ var _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__);

var isArray = Array.isArray;
function iterate(items, fn) {
  var ret = null;

  if (items) {
    ret = [];

    if (isArray(items)) {
      ret = items.map(fn);
    } else if (typeof items === 'number') {
      for (var i = 0; i < items; i += 1) {
        ret.push(fn(i + 1, i));
      }
    } else if (_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0___default()(items) === 'object') {
      Object.keys(items).forEach(function (key) {
        ret.push(fn(items[key], key));
      });
    }
  }

  return ret;
}

/***/ }),

/***/ "./src/xml-runtime/renderSlot.js":
/*!***************************************!*\
  !*** ./src/xml-runtime/renderSlot.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return renderSlot; });
var empty = {};
function renderSlot(data, slot, fallback, props) {
  var _data$$scopedSlots = data.$scopedSlots,
      $scopedSlots = _data$$scopedSlots === void 0 ? empty : _data$$scopedSlots,
      _data$$slots = data.$slots,
      $slots = _data$$slots === void 0 ? empty : _data$$slots;
  var scopedSlotFn = $scopedSlots[slot];
  var nodes;

  if (scopedSlotFn) {
    nodes = [];
    var isEmptyChildren = true;
    scopedSlotFn.forEach(function (f) {
      var ret = f(props);

      if (ret) {
        isEmptyChildren = false;
      }

      nodes.push(ret);
    });

    if (isEmptyChildren) {
      nodes = fallback;
    }
  } else {
    var slotNodes = $slots[slot];
    nodes = slotNodes || fallback;
  }

  return nodes;
}

/***/ }),

/***/ "./src/xml-runtime/resolveScopedSlots.js":
/*!***********************************************!*\
  !*** ./src/xml-runtime/resolveScopedSlots.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return resolveScopedSlots; });
function resolveScopedSlots(arrScopedSlots) {
  var objScopedSlots = {};
  arrScopedSlots.forEach(function (arr) {
    var fn = arr.fn,
        _arr$slot = arr.slot,
        slot = _arr$slot === void 0 ? '$default' : _arr$slot;
    objScopedSlots[slot] = objScopedSlots[slot] || [];
    objScopedSlots[slot].push(fn);
  });
  return objScopedSlots;
}

/***/ }),

/***/ "./src/xml-runtime/toString.js":
/*!*************************************!*\
  !*** ./src/xml-runtime/toString.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return toString; });
function toString(str) {
  if (str == null) {
    return str;
  }

  return "".concat(str);
}

/***/ }),

/***/ "./src/xml-runtime/useTemplate.js":
/*!****************************************!*\
  !*** ./src/xml-runtime/useTemplate.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return useTemplate; });
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _nerv__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/nerv */ "./src/nerv/index.ts");


function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }


function useTemplate(template, data, key, context) {
  var Component = template && template.Component;
  return Component ? _nerv__WEBPACK_IMPORTED_MODULE_1__["default"].createElement(Component, _objectSpread(_objectSpread({}, data), {}, {
    $context: context,
    key: key
  })) : null;
}

/***/ })

/******/ });
//# sourceMappingURL=mp.js.map